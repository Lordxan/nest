var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
var __decorateParam = (index2, decorator) => (target, key) => decorator(target, key, index2);

// node_modules/tsup/assets/esm_shims.js
import { fileURLToPath } from "url";
import path from "path";
var getFilename, getDirname, __dirname;
var init_esm_shims = __esm({
  "node_modules/tsup/assets/esm_shims.js"() {
    getFilename = () => fileURLToPath(import.meta.url);
    getDirname = () => path.dirname(getFilename());
    __dirname = /* @__PURE__ */ getDirname();
  }
});

// node_modules/cache-manager/lib/callback_filler.js
var require_callback_filler = __commonJS({
  "node_modules/cache-manager/lib/callback_filler.js"(exports2, module2) {
    init_esm_shims();
    function CallbackFiller() {
      this.queues = {};
    }
    CallbackFiller.prototype.fill = function(key, err, data) {
      var waiting = this.queues[key];
      delete this.queues[key];
      if (waiting && waiting.length) {
        waiting.forEach(function(task) {
          task.cb(err, data);
        });
      }
    };
    CallbackFiller.prototype.has = function(key) {
      return this.queues[key];
    };
    CallbackFiller.prototype.add = function(key, funcObj) {
      if (this.queues[key]) {
        this.queues[key].push(funcObj);
      } else {
        this.queues[key] = [funcObj];
      }
    };
    module2.exports = CallbackFiller;
  }
});

// node_modules/cache-manager/lib/utils.js
var require_utils = __commonJS({
  "node_modules/cache-manager/lib/utils.js"(exports2, module2) {
    init_esm_shims();
    var isObject2 = function isObject3(value) {
      return value instanceof Object && value.constructor === Object;
    };
    var parseWrapArguments = function parseWrapArguments2(args2) {
      var length = args2.length;
      var work;
      var options = {};
      var cb;
      for (var i = 0; i < length; i += 1) {
        if (typeof args2[i] === "function") {
          if (typeof args2[i + 2] === "function") {
            cb = args2.pop();
          } else if (typeof args2[i + 1] === "function") {
            cb = args2.pop();
          }
          if (isObject2(args2[i + 1])) {
            options = args2.pop();
          }
          work = args2.pop();
          break;
        }
      }
      return {
        keys: args2,
        work,
        options,
        cb
      };
    };
    module2.exports = {
      isObject: isObject2,
      parseWrapArguments
    };
  }
});

// node_modules/cache-manager/lib/caching.js
var require_caching = __commonJS({
  "node_modules/cache-manager/lib/caching.js"(exports2, module2) {
    init_esm_shims();
    var CallbackFiller = require_callback_filler();
    var utils = require_utils();
    var parseWrapArguments = utils.parseWrapArguments;
    var caching = function(args2) {
      args2 = args2 || {};
      var self = {};
      if (typeof args2.store === "object") {
        if (args2.store.create) {
          self.store = args2.store.create(args2);
        } else {
          self.store = args2.store;
        }
      } else {
        var storeName = args2.store || "memory";
        self.store = __require("./stores/" + storeName + ".js").create(args2);
      }
      self.ignoreCacheErrors = args2.ignoreCacheErrors || false;
      self.refreshThreshold = args2.refreshThreshold || false;
      var Promise2 = args2.promiseDependency || global.Promise;
      var callbackFiller = new CallbackFiller();
      var backgroundQueue = /* @__PURE__ */ new Set();
      if (typeof args2.isCacheableValue === "function") {
        self._isCacheableValue = args2.isCacheableValue;
      } else if (typeof self.store.isCacheableValue === "function") {
        self._isCacheableValue = self.store.isCacheableValue.bind(self.store);
      } else {
        self._isCacheableValue = function(value) {
          return value !== void 0;
        };
      }
      function wrapPromise(key, promise, options) {
        return new Promise2(function(resolve, reject2) {
          self.wrap(key, function(cb) {
            Promise2.resolve().then(promise).then(function(result) {
              cb(null, result);
              return null;
            }).catch(cb);
          }, options, function(err, result) {
            if (err) {
              return reject2(err);
            }
            resolve(result);
          });
        });
      }
      function handleBackgroundRefresh(key, work, options) {
        if (self.refreshThreshold && !backgroundQueue.has(key)) {
          backgroundQueue.add(key);
          self.checkRefreshThreshold(key, function(err, isExpiring) {
            if (err) {
              backgroundQueue.delete(key);
              return;
            }
            if (isExpiring) {
              work(function(err2, data) {
                if (err2 || !self._isCacheableValue(data)) {
                  backgroundQueue.delete(key);
                  return;
                }
                if (options && typeof options.ttl === "function") {
                  options.ttl = options.ttl(data);
                }
                self.store.set(key, data, options, function() {
                  backgroundQueue.delete(key);
                });
              });
            } else {
              backgroundQueue.delete(key);
            }
          });
        }
      }
      self.checkRefreshThreshold = function(key, cb) {
        if (self.refreshThreshold && typeof self.store.ttl === "function") {
          return self.store.ttl(key, function(ttlErr, ttl) {
            if (ttlErr || typeof ttl !== "number") {
              return cb(new Error("Invalid TTL response"));
            }
            if (self.refreshThreshold > ttl) {
              return cb(null, true);
            }
            return cb(null, false);
          });
        } else {
          return cb(new Error("Unhandled refresh"));
        }
      };
      self.wrap = function() {
        var parsedArgs = parseWrapArguments(Array.prototype.slice.apply(arguments));
        var keys = parsedArgs.keys;
        var work = parsedArgs.work;
        var options = parsedArgs.options;
        var cb = parsedArgs.cb;
        if (!cb) {
          keys.push(work);
          keys.push(options);
          return wrapPromise.apply(this, keys);
        }
        if (keys.length > 1) {
          return wrapMultiple(keys, work, options, cb);
        }
        var key = keys[0];
        var hasKey = callbackFiller.has(key);
        callbackFiller.add(key, { cb });
        if (hasKey) {
          return;
        }
        self.store.get(key, options, function(err, result) {
          if (err && !self.ignoreCacheErrors) {
            callbackFiller.fill(key, err);
          } else if (self._isCacheableValue(result)) {
            handleBackgroundRefresh(key, work, options);
            callbackFiller.fill(key, null, result);
          } else {
            work(function(err2, data) {
              if (err2) {
                callbackFiller.fill(key, err2);
                return;
              }
              if (!self._isCacheableValue(data)) {
                callbackFiller.fill(key, null, data);
                return;
              }
              if (options && typeof options.ttl === "function") {
                options.ttl = options.ttl(data);
              }
              self.store.set(key, data, options, function(err3) {
                if (err3 && !self.ignoreCacheErrors) {
                  callbackFiller.fill(key, err3);
                } else {
                  callbackFiller.fill(key, null, data);
                }
              });
            });
          }
        });
      };
      function wrapMultiple(keys, work, options, cb) {
        var combinedKey = keys.reduce(function(acc, k) {
          return acc + k;
        }, "");
        var hasKey = callbackFiller.has(combinedKey);
        callbackFiller.add(combinedKey, { cb });
        if (hasKey) {
          return;
        }
        keys.push(options);
        keys.push(onResult);
        self.store.mget.apply(self.store, keys);
        function onResult(err, result) {
          if (err && !self.ignoreCacheErrors) {
            return callbackFiller.fill(combinedKey, err);
          }
          var cacheOk = Array.isArray(result) && result.filter(function(_result) {
            return self._isCacheableValue(_result);
          }).length === result.length;
          if (cacheOk) {
            return callbackFiller.fill(combinedKey, null, result);
          }
          return work(function(err2, data) {
            if (err2 || !data) {
              return done(err2);
            }
            var _args = [];
            data.forEach(function(value, i) {
              if (self._isCacheableValue(value)) {
                _args.push(keys[i]);
                _args.push(value);
              }
            });
            if (_args.length === 0) {
              return done(null);
            }
            if (options && typeof options.ttl === "function") {
              options.ttl = options.ttl(data);
            }
            _args.push(options);
            _args.push(done);
            self.store.mset.apply(self.store, _args);
            function done(err3) {
              if (err3 && !self.ignoreCacheErrors) {
                callbackFiller.fill(combinedKey, err3);
              } else {
                callbackFiller.fill(combinedKey, null, data);
              }
            }
          });
        }
      }
      self.get = self.store.get.bind(self.store);
      if (typeof self.store.mget === "function") {
        self.mget = self.store.mget.bind(self.store);
      }
      self.set = self.store.set.bind(self.store);
      if (typeof self.store.mset === "function") {
        self.mset = self.store.mset.bind(self.store);
      }
      if (typeof self.store.del === "function") {
        self.del = self.store.del.bind(self.store);
      }
      if (typeof self.store.setex === "function") {
        self.setex = self.store.setex.bind(self.store);
      }
      if (typeof self.store.reset === "function") {
        self.reset = self.store.reset.bind(self.store);
      }
      if (typeof self.store.keys === "function") {
        self.keys = self.store.keys.bind(self.store);
      }
      if (typeof self.store.ttl === "function") {
        self.ttl = self.store.ttl.bind(self.store);
      }
      return self;
    };
    module2.exports = caching;
  }
});

// node_modules/cache-manager/node_modules/async/dist/async.mjs
var async_exports = {};
__export(async_exports, {
  all: () => every$1,
  allLimit: () => everyLimit$1,
  allSeries: () => everySeries$1,
  any: () => some$1,
  anyLimit: () => someLimit$1,
  anySeries: () => someSeries$1,
  apply: () => apply,
  applyEach: () => applyEach$1,
  applyEachSeries: () => applyEachSeries,
  asyncify: () => asyncify,
  auto: () => auto,
  autoInject: () => autoInject,
  cargo: () => cargo,
  cargoQueue: () => cargo$1,
  compose: () => compose,
  concat: () => concat$1,
  concatLimit: () => concatLimit$1,
  concatSeries: () => concatSeries$1,
  constant: () => constant,
  default: () => async_default,
  detect: () => detect$1,
  detectLimit: () => detectLimit$1,
  detectSeries: () => detectSeries$1,
  dir: () => dir,
  doDuring: () => doWhilst$1,
  doUntil: () => doUntil,
  doWhilst: () => doWhilst$1,
  during: () => whilst$1,
  each: () => each,
  eachLimit: () => eachLimit$2,
  eachOf: () => eachOf$1,
  eachOfLimit: () => eachOfLimit$2,
  eachOfSeries: () => eachOfSeries$1,
  eachSeries: () => eachSeries$1,
  ensureAsync: () => ensureAsync,
  every: () => every$1,
  everyLimit: () => everyLimit$1,
  everySeries: () => everySeries$1,
  filter: () => filter$1,
  filterLimit: () => filterLimit$1,
  filterSeries: () => filterSeries$1,
  find: () => detect$1,
  findLimit: () => detectLimit$1,
  findSeries: () => detectSeries$1,
  flatMap: () => concat$1,
  flatMapLimit: () => concatLimit$1,
  flatMapSeries: () => concatSeries$1,
  foldl: () => reduce$1,
  foldr: () => reduceRight,
  forEach: () => each,
  forEachLimit: () => eachLimit$2,
  forEachOf: () => eachOf$1,
  forEachOfLimit: () => eachOfLimit$2,
  forEachOfSeries: () => eachOfSeries$1,
  forEachSeries: () => eachSeries$1,
  forever: () => forever$1,
  groupBy: () => groupBy,
  groupByLimit: () => groupByLimit$1,
  groupBySeries: () => groupBySeries,
  inject: () => reduce$1,
  log: () => log2,
  map: () => map$1,
  mapLimit: () => mapLimit$1,
  mapSeries: () => mapSeries$1,
  mapValues: () => mapValues,
  mapValuesLimit: () => mapValuesLimit$1,
  mapValuesSeries: () => mapValuesSeries,
  memoize: () => memoize,
  nextTick: () => nextTick,
  parallel: () => parallel,
  parallelLimit: () => parallelLimit,
  priorityQueue: () => priorityQueue,
  queue: () => queue$1,
  race: () => race$1,
  reduce: () => reduce$1,
  reduceRight: () => reduceRight,
  reflect: () => reflect,
  reflectAll: () => reflectAll,
  reject: () => reject$2,
  rejectLimit: () => rejectLimit$1,
  rejectSeries: () => rejectSeries$1,
  retry: () => retry,
  retryable: () => retryable,
  select: () => filter$1,
  selectLimit: () => filterLimit$1,
  selectSeries: () => filterSeries$1,
  seq: () => seq,
  series: () => series,
  setImmediate: () => setImmediate$1,
  some: () => some$1,
  someLimit: () => someLimit$1,
  someSeries: () => someSeries$1,
  sortBy: () => sortBy$1,
  timeout: () => timeout,
  times: () => times,
  timesLimit: () => timesLimit,
  timesSeries: () => timesSeries,
  transform: () => transform,
  tryEach: () => tryEach$1,
  unmemoize: () => unmemoize,
  until: () => until,
  waterfall: () => waterfall$1,
  whilst: () => whilst$1,
  wrapSync: () => asyncify
});
function apply(fn2, ...args2) {
  return (...callArgs) => fn2(...args2, ...callArgs);
}
function initialParams(fn2) {
  return function(...args2) {
    var callback = args2.pop();
    return fn2.call(this, args2, callback);
  };
}
function fallback(fn2) {
  setTimeout(fn2, 0);
}
function wrap(defer) {
  return (fn2, ...args2) => defer(() => fn2(...args2));
}
function asyncify(func) {
  if (isAsync(func)) {
    return function(...args2) {
      const callback = args2.pop();
      const promise = func.apply(this, args2);
      return handlePromise(promise, callback);
    };
  }
  return initialParams(function(args2, callback) {
    var result;
    try {
      result = func.apply(this, args2);
    } catch (e) {
      return callback(e);
    }
    if (result && typeof result.then === "function") {
      return handlePromise(result, callback);
    } else {
      callback(null, result);
    }
  });
}
function handlePromise(promise, callback) {
  return promise.then((value) => {
    invokeCallback(callback, null, value);
  }, (err) => {
    invokeCallback(callback, err && err.message ? err : new Error(err));
  });
}
function invokeCallback(callback, error, value) {
  try {
    callback(error, value);
  } catch (err) {
    setImmediate$1((e) => {
      throw e;
    }, err);
  }
}
function isAsync(fn2) {
  return fn2[Symbol.toStringTag] === "AsyncFunction";
}
function isAsyncGenerator(fn2) {
  return fn2[Symbol.toStringTag] === "AsyncGenerator";
}
function isAsyncIterable(obj) {
  return typeof obj[Symbol.asyncIterator] === "function";
}
function wrapAsync(asyncFn) {
  if (typeof asyncFn !== "function")
    throw new Error("expected a function");
  return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
}
function awaitify(asyncFn, arity = asyncFn.length) {
  if (!arity)
    throw new Error("arity is undefined");
  function awaitable(...args2) {
    if (typeof args2[arity - 1] === "function") {
      return asyncFn.apply(this, args2);
    }
    return new Promise((resolve, reject2) => {
      args2[arity - 1] = (err, ...cbArgs) => {
        if (err)
          return reject2(err);
        resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
      };
      asyncFn.apply(this, args2);
    });
  }
  return awaitable;
}
function applyEach(eachfn) {
  return function applyEach2(fns, ...callArgs) {
    const go = awaitify(function(callback) {
      var that = this;
      return eachfn(fns, (fn2, cb) => {
        wrapAsync(fn2).apply(that, callArgs.concat(cb));
      }, callback);
    });
    return go;
  };
}
function _asyncMap(eachfn, arr, iteratee, callback) {
  arr = arr || [];
  var results = [];
  var counter = 0;
  var _iteratee = wrapAsync(iteratee);
  return eachfn(arr, (value, _, iterCb) => {
    var index2 = counter++;
    _iteratee(value, (err, v) => {
      results[index2] = v;
      iterCb(err);
    });
  }, (err) => {
    callback(err, results);
  });
}
function isArrayLike(value) {
  return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
}
function once(fn2) {
  function wrapper(...args2) {
    if (fn2 === null)
      return;
    var callFn = fn2;
    fn2 = null;
    callFn.apply(this, args2);
  }
  Object.assign(wrapper, fn2);
  return wrapper;
}
function getIterator(coll) {
  return coll[Symbol.iterator] && coll[Symbol.iterator]();
}
function createArrayIterator(coll) {
  var i = -1;
  var len = coll.length;
  return function next() {
    return ++i < len ? { value: coll[i], key: i } : null;
  };
}
function createES2015Iterator(iterator) {
  var i = -1;
  return function next() {
    var item = iterator.next();
    if (item.done)
      return null;
    i++;
    return { value: item.value, key: i };
  };
}
function createObjectIterator(obj) {
  var okeys = obj ? Object.keys(obj) : [];
  var i = -1;
  var len = okeys.length;
  return function next() {
    var key = okeys[++i];
    return i < len ? { value: obj[key], key } : null;
  };
}
function createIterator(coll) {
  if (isArrayLike(coll)) {
    return createArrayIterator(coll);
  }
  var iterator = getIterator(coll);
  return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
}
function onlyOnce(fn2) {
  return function(...args2) {
    if (fn2 === null)
      throw new Error("Callback was already called.");
    var callFn = fn2;
    fn2 = null;
    callFn.apply(this, args2);
  };
}
function asyncEachOfLimit(generator, limit, iteratee, callback) {
  let done = false;
  let canceled = false;
  let awaiting = false;
  let running = 0;
  let idx = 0;
  function replenish() {
    if (running >= limit || awaiting || done)
      return;
    awaiting = true;
    generator.next().then(({ value, done: iterDone }) => {
      if (canceled || done)
        return;
      awaiting = false;
      if (iterDone) {
        done = true;
        if (running <= 0) {
          callback(null);
        }
        return;
      }
      running++;
      iteratee(value, idx, iterateeCallback);
      idx++;
      replenish();
    }).catch(handleError);
  }
  function iterateeCallback(err, result) {
    running -= 1;
    if (canceled)
      return;
    if (err)
      return handleError(err);
    if (err === false) {
      done = true;
      canceled = true;
      return;
    }
    if (result === breakLoop || done && running <= 0) {
      done = true;
      return callback(null);
    }
    replenish();
  }
  function handleError(err) {
    if (canceled)
      return;
    awaiting = false;
    done = true;
    callback(err);
  }
  replenish();
}
function eachOfLimit$1(coll, limit, iteratee, callback) {
  return eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
}
function eachOfArrayLike(coll, iteratee, callback) {
  callback = once(callback);
  var index2 = 0, completed = 0, { length } = coll, canceled = false;
  if (length === 0) {
    callback(null);
  }
  function iteratorCallback(err, value) {
    if (err === false) {
      canceled = true;
    }
    if (canceled === true)
      return;
    if (err) {
      callback(err);
    } else if (++completed === length || value === breakLoop) {
      callback(null);
    }
  }
  for (; index2 < length; index2++) {
    iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
  }
}
function eachOfGeneric(coll, iteratee, callback) {
  return eachOfLimit$2(coll, Infinity, iteratee, callback);
}
function eachOf(coll, iteratee, callback) {
  var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
  return eachOfImplementation(coll, wrapAsync(iteratee), callback);
}
function map(coll, iteratee, callback) {
  return _asyncMap(eachOf$1, coll, iteratee, callback);
}
function eachOfSeries(coll, iteratee, callback) {
  return eachOfLimit$2(coll, 1, iteratee, callback);
}
function mapSeries(coll, iteratee, callback) {
  return _asyncMap(eachOfSeries$1, coll, iteratee, callback);
}
function promiseCallback() {
  let resolve, reject2;
  function callback(err, ...args2) {
    if (err)
      return reject2(err);
    resolve(args2.length > 1 ? args2 : args2[0]);
  }
  callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
    resolve = res, reject2 = rej;
  });
  return callback;
}
function auto(tasks, concurrency, callback) {
  if (typeof concurrency !== "number") {
    callback = concurrency;
    concurrency = null;
  }
  callback = once(callback || promiseCallback());
  var numTasks = Object.keys(tasks).length;
  if (!numTasks) {
    return callback(null);
  }
  if (!concurrency) {
    concurrency = numTasks;
  }
  var results = {};
  var runningTasks = 0;
  var canceled = false;
  var hasError = false;
  var listeners = /* @__PURE__ */ Object.create(null);
  var readyTasks = [];
  var readyToCheck = [];
  var uncheckedDependencies = {};
  Object.keys(tasks).forEach((key) => {
    var task = tasks[key];
    if (!Array.isArray(task)) {
      enqueueTask(key, [task]);
      readyToCheck.push(key);
      return;
    }
    var dependencies = task.slice(0, task.length - 1);
    var remainingDependencies = dependencies.length;
    if (remainingDependencies === 0) {
      enqueueTask(key, task);
      readyToCheck.push(key);
      return;
    }
    uncheckedDependencies[key] = remainingDependencies;
    dependencies.forEach((dependencyName) => {
      if (!tasks[dependencyName]) {
        throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
      }
      addListener(dependencyName, () => {
        remainingDependencies--;
        if (remainingDependencies === 0) {
          enqueueTask(key, task);
        }
      });
    });
  });
  checkForDeadlocks();
  processQueue();
  function enqueueTask(key, task) {
    readyTasks.push(() => runTask(key, task));
  }
  function processQueue() {
    if (canceled)
      return;
    if (readyTasks.length === 0 && runningTasks === 0) {
      return callback(null, results);
    }
    while (readyTasks.length && runningTasks < concurrency) {
      var run = readyTasks.shift();
      run();
    }
  }
  function addListener(taskName, fn2) {
    var taskListeners = listeners[taskName];
    if (!taskListeners) {
      taskListeners = listeners[taskName] = [];
    }
    taskListeners.push(fn2);
  }
  function taskComplete(taskName) {
    var taskListeners = listeners[taskName] || [];
    taskListeners.forEach((fn2) => fn2());
    processQueue();
  }
  function runTask(key, task) {
    if (hasError)
      return;
    var taskCallback = onlyOnce((err, ...result) => {
      runningTasks--;
      if (err === false) {
        canceled = true;
        return;
      }
      if (result.length < 2) {
        [result] = result;
      }
      if (err) {
        var safeResults = {};
        Object.keys(results).forEach((rkey) => {
          safeResults[rkey] = results[rkey];
        });
        safeResults[key] = result;
        hasError = true;
        listeners = /* @__PURE__ */ Object.create(null);
        if (canceled)
          return;
        callback(err, safeResults);
      } else {
        results[key] = result;
        taskComplete(key);
      }
    });
    runningTasks++;
    var taskFn = wrapAsync(task[task.length - 1]);
    if (task.length > 1) {
      taskFn(results, taskCallback);
    } else {
      taskFn(taskCallback);
    }
  }
  function checkForDeadlocks() {
    var currentTask;
    var counter = 0;
    while (readyToCheck.length) {
      currentTask = readyToCheck.pop();
      counter++;
      getDependents(currentTask).forEach((dependent) => {
        if (--uncheckedDependencies[dependent] === 0) {
          readyToCheck.push(dependent);
        }
      });
    }
    if (counter !== numTasks) {
      throw new Error("async.auto cannot execute tasks due to a recursive dependency");
    }
  }
  function getDependents(taskName) {
    var result = [];
    Object.keys(tasks).forEach((key) => {
      const task = tasks[key];
      if (Array.isArray(task) && task.indexOf(taskName) >= 0) {
        result.push(key);
      }
    });
    return result;
  }
  return callback[PROMISE_SYMBOL];
}
function parseParams(func) {
  const src = func.toString().replace(STRIP_COMMENTS, "");
  let match = src.match(FN_ARGS);
  if (!match) {
    match = src.match(ARROW_FN_ARGS);
  }
  if (!match)
    throw new Error("could not parse args in autoInject\nSource:\n" + src);
  let [, args2] = match;
  return args2.replace(/\s/g, "").split(FN_ARG_SPLIT).map((arg) => arg.replace(FN_ARG, "").trim());
}
function autoInject(tasks, callback) {
  var newTasks = {};
  Object.keys(tasks).forEach((key) => {
    var taskFn = tasks[key];
    var params;
    var fnIsAsync = isAsync(taskFn);
    var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
    if (Array.isArray(taskFn)) {
      params = [...taskFn];
      taskFn = params.pop();
      newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
    } else if (hasNoDeps) {
      newTasks[key] = taskFn;
    } else {
      params = parseParams(taskFn);
      if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
        throw new Error("autoInject task functions require explicit parameters.");
      }
      if (!fnIsAsync)
        params.pop();
      newTasks[key] = params.concat(newTask);
    }
    function newTask(results, taskCb) {
      var newArgs = params.map((name) => results[name]);
      newArgs.push(taskCb);
      wrapAsync(taskFn)(...newArgs);
    }
  });
  return auto(newTasks, callback);
}
function setInitial(dll, node) {
  dll.length = 1;
  dll.head = dll.tail = node;
}
function queue(worker, concurrency, payload) {
  if (concurrency == null) {
    concurrency = 1;
  } else if (concurrency === 0) {
    throw new RangeError("Concurrency must not be zero");
  }
  var _worker = wrapAsync(worker);
  var numRunning = 0;
  var workersList = [];
  const events = {
    error: [],
    drain: [],
    saturated: [],
    unsaturated: [],
    empty: []
  };
  function on(event, handler) {
    events[event].push(handler);
  }
  function once2(event, handler) {
    const handleAndRemove = (...args2) => {
      off(event, handleAndRemove);
      handler(...args2);
    };
    events[event].push(handleAndRemove);
  }
  function off(event, handler) {
    if (!event)
      return Object.keys(events).forEach((ev) => events[ev] = []);
    if (!handler)
      return events[event] = [];
    events[event] = events[event].filter((ev) => ev !== handler);
  }
  function trigger(event, ...args2) {
    events[event].forEach((handler) => handler(...args2));
  }
  var processingScheduled = false;
  function _insert(data, insertAtFront, rejectOnError, callback) {
    if (callback != null && typeof callback !== "function") {
      throw new Error("task callback must be a function");
    }
    q.started = true;
    var res, rej;
    function promiseCallback2(err, ...args2) {
      if (err)
        return rejectOnError ? rej(err) : res();
      if (args2.length <= 1)
        return res(args2[0]);
      res(args2);
    }
    var item = {
      data,
      callback: rejectOnError ? promiseCallback2 : callback || promiseCallback2
    };
    if (insertAtFront) {
      q._tasks.unshift(item);
    } else {
      q._tasks.push(item);
    }
    if (!processingScheduled) {
      processingScheduled = true;
      setImmediate$1(() => {
        processingScheduled = false;
        q.process();
      });
    }
    if (rejectOnError || !callback) {
      return new Promise((resolve, reject2) => {
        res = resolve;
        rej = reject2;
      });
    }
  }
  function _createCB(tasks) {
    return function(err, ...args2) {
      numRunning -= 1;
      for (var i = 0, l = tasks.length; i < l; i++) {
        var task = tasks[i];
        var index2 = workersList.indexOf(task);
        if (index2 === 0) {
          workersList.shift();
        } else if (index2 > 0) {
          workersList.splice(index2, 1);
        }
        task.callback(err, ...args2);
        if (err != null) {
          trigger("error", err, task.data);
        }
      }
      if (numRunning <= q.concurrency - q.buffer) {
        trigger("unsaturated");
      }
      if (q.idle()) {
        trigger("drain");
      }
      q.process();
    };
  }
  function _maybeDrain(data) {
    if (data.length === 0 && q.idle()) {
      setImmediate$1(() => trigger("drain"));
      return true;
    }
    return false;
  }
  const eventMethod = (name) => (handler) => {
    if (!handler) {
      return new Promise((resolve, reject2) => {
        once2(name, (err, data) => {
          if (err)
            return reject2(err);
          resolve(data);
        });
      });
    }
    off(name);
    on(name, handler);
  };
  var isProcessing = false;
  var q = {
    _tasks: new DLL(),
    *[Symbol.iterator]() {
      yield* q._tasks[Symbol.iterator]();
    },
    concurrency,
    payload,
    buffer: concurrency / 4,
    started: false,
    paused: false,
    push(data, callback) {
      if (Array.isArray(data)) {
        if (_maybeDrain(data))
          return;
        return data.map((datum) => _insert(datum, false, false, callback));
      }
      return _insert(data, false, false, callback);
    },
    pushAsync(data, callback) {
      if (Array.isArray(data)) {
        if (_maybeDrain(data))
          return;
        return data.map((datum) => _insert(datum, false, true, callback));
      }
      return _insert(data, false, true, callback);
    },
    kill() {
      off();
      q._tasks.empty();
    },
    unshift(data, callback) {
      if (Array.isArray(data)) {
        if (_maybeDrain(data))
          return;
        return data.map((datum) => _insert(datum, true, false, callback));
      }
      return _insert(data, true, false, callback);
    },
    unshiftAsync(data, callback) {
      if (Array.isArray(data)) {
        if (_maybeDrain(data))
          return;
        return data.map((datum) => _insert(datum, true, true, callback));
      }
      return _insert(data, true, true, callback);
    },
    remove(testFn) {
      q._tasks.remove(testFn);
    },
    process() {
      if (isProcessing) {
        return;
      }
      isProcessing = true;
      while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
        var tasks = [], data = [];
        var l = q._tasks.length;
        if (q.payload)
          l = Math.min(l, q.payload);
        for (var i = 0; i < l; i++) {
          var node = q._tasks.shift();
          tasks.push(node);
          workersList.push(node);
          data.push(node.data);
        }
        numRunning += 1;
        if (q._tasks.length === 0) {
          trigger("empty");
        }
        if (numRunning === q.concurrency) {
          trigger("saturated");
        }
        var cb = onlyOnce(_createCB(tasks));
        _worker(data, cb);
      }
      isProcessing = false;
    },
    length() {
      return q._tasks.length;
    },
    running() {
      return numRunning;
    },
    workersList() {
      return workersList;
    },
    idle() {
      return q._tasks.length + numRunning === 0;
    },
    pause() {
      q.paused = true;
    },
    resume() {
      if (q.paused === false) {
        return;
      }
      q.paused = false;
      setImmediate$1(q.process);
    }
  };
  Object.defineProperties(q, {
    saturated: {
      writable: false,
      value: eventMethod("saturated")
    },
    unsaturated: {
      writable: false,
      value: eventMethod("unsaturated")
    },
    empty: {
      writable: false,
      value: eventMethod("empty")
    },
    drain: {
      writable: false,
      value: eventMethod("drain")
    },
    error: {
      writable: false,
      value: eventMethod("error")
    }
  });
  return q;
}
function cargo(worker, payload) {
  return queue(worker, 1, payload);
}
function cargo$1(worker, concurrency, payload) {
  return queue(worker, concurrency, payload);
}
function reduce(coll, memo, iteratee, callback) {
  callback = once(callback);
  var _iteratee = wrapAsync(iteratee);
  return eachOfSeries$1(coll, (x, i, iterCb) => {
    _iteratee(memo, x, (err, v) => {
      memo = v;
      iterCb(err);
    });
  }, (err) => callback(err, memo));
}
function seq(...functions) {
  var _functions = functions.map(wrapAsync);
  return function(...args2) {
    var that = this;
    var cb = args2[args2.length - 1];
    if (typeof cb == "function") {
      args2.pop();
    } else {
      cb = promiseCallback();
    }
    reduce$1(_functions, args2, (newargs, fn2, iterCb) => {
      fn2.apply(that, newargs.concat((err, ...nextargs) => {
        iterCb(err, nextargs);
      }));
    }, (err, results) => cb(err, ...results));
    return cb[PROMISE_SYMBOL];
  };
}
function compose(...args2) {
  return seq(...args2.reverse());
}
function mapLimit(coll, limit, iteratee, callback) {
  return _asyncMap(eachOfLimit(limit), coll, iteratee, callback);
}
function concatLimit(coll, limit, iteratee, callback) {
  var _iteratee = wrapAsync(iteratee);
  return mapLimit$1(coll, limit, (val, iterCb) => {
    _iteratee(val, (err, ...args2) => {
      if (err)
        return iterCb(err);
      return iterCb(err, args2);
    });
  }, (err, mapResults) => {
    var result = [];
    for (var i = 0; i < mapResults.length; i++) {
      if (mapResults[i]) {
        result = result.concat(...mapResults[i]);
      }
    }
    return callback(err, result);
  });
}
function concat(coll, iteratee, callback) {
  return concatLimit$1(coll, Infinity, iteratee, callback);
}
function concatSeries(coll, iteratee, callback) {
  return concatLimit$1(coll, 1, iteratee, callback);
}
function constant(...args2) {
  return function(...ignoredArgs) {
    var callback = ignoredArgs.pop();
    return callback(null, ...args2);
  };
}
function _createTester(check, getResult) {
  return (eachfn, arr, _iteratee, cb) => {
    var testPassed = false;
    var testResult;
    const iteratee = wrapAsync(_iteratee);
    eachfn(arr, (value, _, callback) => {
      iteratee(value, (err, result) => {
        if (err || err === false)
          return callback(err);
        if (check(result) && !testResult) {
          testPassed = true;
          testResult = getResult(true, value);
          return callback(null, breakLoop);
        }
        callback();
      });
    }, (err) => {
      if (err)
        return cb(err);
      cb(null, testPassed ? testResult : getResult(false));
    });
  };
}
function detect(coll, iteratee, callback) {
  return _createTester((bool) => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback);
}
function detectLimit(coll, limit, iteratee, callback) {
  return _createTester((bool) => bool, (res, item) => item)(eachOfLimit(limit), coll, iteratee, callback);
}
function detectSeries(coll, iteratee, callback) {
  return _createTester((bool) => bool, (res, item) => item)(eachOfLimit(1), coll, iteratee, callback);
}
function consoleFunc(name) {
  return (fn2, ...args2) => wrapAsync(fn2)(...args2, (err, ...resultArgs) => {
    if (typeof console === "object") {
      if (err) {
        if (console.error) {
          console.error(err);
        }
      } else if (console[name]) {
        resultArgs.forEach((x) => console[name](x));
      }
    }
  });
}
function doWhilst(iteratee, test, callback) {
  callback = onlyOnce(callback);
  var _fn = wrapAsync(iteratee);
  var _test = wrapAsync(test);
  var results;
  function next(err, ...args2) {
    if (err)
      return callback(err);
    if (err === false)
      return;
    results = args2;
    _test(...args2, check);
  }
  function check(err, truth) {
    if (err)
      return callback(err);
    if (err === false)
      return;
    if (!truth)
      return callback(null, ...results);
    _fn(next);
  }
  return check(null, true);
}
function doUntil(iteratee, test, callback) {
  const _test = wrapAsync(test);
  return doWhilst$1(iteratee, (...args2) => {
    const cb = args2.pop();
    _test(...args2, (err, truth) => cb(err, !truth));
  }, callback);
}
function _withoutIndex(iteratee) {
  return (value, index2, callback) => iteratee(value, callback);
}
function eachLimit(coll, iteratee, callback) {
  return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}
function eachLimit$1(coll, limit, iteratee, callback) {
  return eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}
function eachSeries(coll, iteratee, callback) {
  return eachLimit$2(coll, 1, iteratee, callback);
}
function ensureAsync(fn2) {
  if (isAsync(fn2))
    return fn2;
  return function(...args2) {
    var callback = args2.pop();
    var sync = true;
    args2.push((...innerArgs) => {
      if (sync) {
        setImmediate$1(() => callback(...innerArgs));
      } else {
        callback(...innerArgs);
      }
    });
    fn2.apply(this, args2);
    sync = false;
  };
}
function every(coll, iteratee, callback) {
  return _createTester((bool) => !bool, (res) => !res)(eachOf$1, coll, iteratee, callback);
}
function everyLimit(coll, limit, iteratee, callback) {
  return _createTester((bool) => !bool, (res) => !res)(eachOfLimit(limit), coll, iteratee, callback);
}
function everySeries(coll, iteratee, callback) {
  return _createTester((bool) => !bool, (res) => !res)(eachOfSeries$1, coll, iteratee, callback);
}
function filterArray(eachfn, arr, iteratee, callback) {
  var truthValues = new Array(arr.length);
  eachfn(arr, (x, index2, iterCb) => {
    iteratee(x, (err, v) => {
      truthValues[index2] = !!v;
      iterCb(err);
    });
  }, (err) => {
    if (err)
      return callback(err);
    var results = [];
    for (var i = 0; i < arr.length; i++) {
      if (truthValues[i])
        results.push(arr[i]);
    }
    callback(null, results);
  });
}
function filterGeneric(eachfn, coll, iteratee, callback) {
  var results = [];
  eachfn(coll, (x, index2, iterCb) => {
    iteratee(x, (err, v) => {
      if (err)
        return iterCb(err);
      if (v) {
        results.push({ index: index2, value: x });
      }
      iterCb(err);
    });
  }, (err) => {
    if (err)
      return callback(err);
    callback(null, results.sort((a, b) => a.index - b.index).map((v) => v.value));
  });
}
function _filter(eachfn, coll, iteratee, callback) {
  var filter2 = isArrayLike(coll) ? filterArray : filterGeneric;
  return filter2(eachfn, coll, wrapAsync(iteratee), callback);
}
function filter(coll, iteratee, callback) {
  return _filter(eachOf$1, coll, iteratee, callback);
}
function filterLimit(coll, limit, iteratee, callback) {
  return _filter(eachOfLimit(limit), coll, iteratee, callback);
}
function filterSeries(coll, iteratee, callback) {
  return _filter(eachOfSeries$1, coll, iteratee, callback);
}
function forever(fn2, errback) {
  var done = onlyOnce(errback);
  var task = wrapAsync(ensureAsync(fn2));
  function next(err) {
    if (err)
      return done(err);
    if (err === false)
      return;
    task(next);
  }
  return next();
}
function groupByLimit(coll, limit, iteratee, callback) {
  var _iteratee = wrapAsync(iteratee);
  return mapLimit$1(coll, limit, (val, iterCb) => {
    _iteratee(val, (err, key) => {
      if (err)
        return iterCb(err);
      return iterCb(err, { key, val });
    });
  }, (err, mapResults) => {
    var result = {};
    var { hasOwnProperty } = Object.prototype;
    for (var i = 0; i < mapResults.length; i++) {
      if (mapResults[i]) {
        var { key } = mapResults[i];
        var { val } = mapResults[i];
        if (hasOwnProperty.call(result, key)) {
          result[key].push(val);
        } else {
          result[key] = [val];
        }
      }
    }
    return callback(err, result);
  });
}
function groupBy(coll, iteratee, callback) {
  return groupByLimit$1(coll, Infinity, iteratee, callback);
}
function groupBySeries(coll, iteratee, callback) {
  return groupByLimit$1(coll, 1, iteratee, callback);
}
function mapValuesLimit(obj, limit, iteratee, callback) {
  callback = once(callback);
  var newObj = {};
  var _iteratee = wrapAsync(iteratee);
  return eachOfLimit(limit)(obj, (val, key, next) => {
    _iteratee(val, key, (err, result) => {
      if (err)
        return next(err);
      newObj[key] = result;
      next(err);
    });
  }, (err) => callback(err, newObj));
}
function mapValues(obj, iteratee, callback) {
  return mapValuesLimit$1(obj, Infinity, iteratee, callback);
}
function mapValuesSeries(obj, iteratee, callback) {
  return mapValuesLimit$1(obj, 1, iteratee, callback);
}
function memoize(fn2, hasher = (v) => v) {
  var memo = /* @__PURE__ */ Object.create(null);
  var queues = /* @__PURE__ */ Object.create(null);
  var _fn = wrapAsync(fn2);
  var memoized = initialParams((args2, callback) => {
    var key = hasher(...args2);
    if (key in memo) {
      setImmediate$1(() => callback(null, ...memo[key]));
    } else if (key in queues) {
      queues[key].push(callback);
    } else {
      queues[key] = [callback];
      _fn(...args2, (err, ...resultArgs) => {
        if (!err) {
          memo[key] = resultArgs;
        }
        var q = queues[key];
        delete queues[key];
        for (var i = 0, l = q.length; i < l; i++) {
          q[i](err, ...resultArgs);
        }
      });
    }
  });
  memoized.memo = memo;
  memoized.unmemoized = fn2;
  return memoized;
}
function parallel(tasks, callback) {
  return _parallel(eachOf$1, tasks, callback);
}
function parallelLimit(tasks, limit, callback) {
  return _parallel(eachOfLimit(limit), tasks, callback);
}
function queue$1(worker, concurrency) {
  var _worker = wrapAsync(worker);
  return queue((items, cb) => {
    _worker(items[0], cb);
  }, concurrency, 1);
}
function leftChi(i) {
  return (i << 1) + 1;
}
function parent(i) {
  return (i + 1 >> 1) - 1;
}
function smaller(x, y) {
  if (x.priority !== y.priority) {
    return x.priority < y.priority;
  } else {
    return x.pushCount < y.pushCount;
  }
}
function priorityQueue(worker, concurrency) {
  var q = queue$1(worker, concurrency);
  q._tasks = new Heap();
  q.push = function(data, priority = 0, callback = () => {
  }) {
    if (typeof callback !== "function") {
      throw new Error("task callback must be a function");
    }
    q.started = true;
    if (!Array.isArray(data)) {
      data = [data];
    }
    if (data.length === 0 && q.idle()) {
      return setImmediate$1(() => q.drain());
    }
    for (var i = 0, l = data.length; i < l; i++) {
      var item = {
        data: data[i],
        priority,
        callback
      };
      q._tasks.push(item);
    }
    setImmediate$1(q.process);
  };
  delete q.unshift;
  return q;
}
function race(tasks, callback) {
  callback = once(callback);
  if (!Array.isArray(tasks))
    return callback(new TypeError("First argument to race must be an array of functions"));
  if (!tasks.length)
    return callback();
  for (var i = 0, l = tasks.length; i < l; i++) {
    wrapAsync(tasks[i])(callback);
  }
}
function reduceRight(array, memo, iteratee, callback) {
  var reversed = [...array].reverse();
  return reduce$1(reversed, memo, iteratee, callback);
}
function reflect(fn2) {
  var _fn = wrapAsync(fn2);
  return initialParams(function reflectOn(args2, reflectCallback) {
    args2.push((error, ...cbArgs) => {
      let retVal = {};
      if (error) {
        retVal.error = error;
      }
      if (cbArgs.length > 0) {
        var value = cbArgs;
        if (cbArgs.length <= 1) {
          [value] = cbArgs;
        }
        retVal.value = value;
      }
      reflectCallback(null, retVal);
    });
    return _fn.apply(this, args2);
  });
}
function reflectAll(tasks) {
  var results;
  if (Array.isArray(tasks)) {
    results = tasks.map(reflect);
  } else {
    results = {};
    Object.keys(tasks).forEach((key) => {
      results[key] = reflect.call(this, tasks[key]);
    });
  }
  return results;
}
function reject(eachfn, arr, _iteratee, callback) {
  const iteratee = wrapAsync(_iteratee);
  return _filter(eachfn, arr, (value, cb) => {
    iteratee(value, (err, v) => {
      cb(err, !v);
    });
  }, callback);
}
function reject$1(coll, iteratee, callback) {
  return reject(eachOf$1, coll, iteratee, callback);
}
function rejectLimit(coll, limit, iteratee, callback) {
  return reject(eachOfLimit(limit), coll, iteratee, callback);
}
function rejectSeries(coll, iteratee, callback) {
  return reject(eachOfSeries$1, coll, iteratee, callback);
}
function constant$1(value) {
  return function() {
    return value;
  };
}
function retry(opts, task, callback) {
  var options = {
    times: DEFAULT_TIMES,
    intervalFunc: constant$1(DEFAULT_INTERVAL)
  };
  if (arguments.length < 3 && typeof opts === "function") {
    callback = task || promiseCallback();
    task = opts;
  } else {
    parseTimes(options, opts);
    callback = callback || promiseCallback();
  }
  if (typeof task !== "function") {
    throw new Error("Invalid arguments for async.retry");
  }
  var _task = wrapAsync(task);
  var attempt = 1;
  function retryAttempt() {
    _task((err, ...args2) => {
      if (err === false)
        return;
      if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err))) {
        setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
      } else {
        callback(err, ...args2);
      }
    });
  }
  retryAttempt();
  return callback[PROMISE_SYMBOL];
}
function parseTimes(acc, t2) {
  if (typeof t2 === "object") {
    acc.times = +t2.times || DEFAULT_TIMES;
    acc.intervalFunc = typeof t2.interval === "function" ? t2.interval : constant$1(+t2.interval || DEFAULT_INTERVAL);
    acc.errorFilter = t2.errorFilter;
  } else if (typeof t2 === "number" || typeof t2 === "string") {
    acc.times = +t2 || DEFAULT_TIMES;
  } else {
    throw new Error("Invalid arguments for async.retry");
  }
}
function retryable(opts, task) {
  if (!task) {
    task = opts;
    opts = null;
  }
  let arity = opts && opts.arity || task.length;
  if (isAsync(task)) {
    arity += 1;
  }
  var _task = wrapAsync(task);
  return initialParams((args2, callback) => {
    if (args2.length < arity - 1 || callback == null) {
      args2.push(callback);
      callback = promiseCallback();
    }
    function taskFn(cb) {
      _task(...args2, cb);
    }
    if (opts)
      retry(opts, taskFn, callback);
    else
      retry(taskFn, callback);
    return callback[PROMISE_SYMBOL];
  });
}
function series(tasks, callback) {
  return _parallel(eachOfSeries$1, tasks, callback);
}
function some(coll, iteratee, callback) {
  return _createTester(Boolean, (res) => res)(eachOf$1, coll, iteratee, callback);
}
function someLimit(coll, limit, iteratee, callback) {
  return _createTester(Boolean, (res) => res)(eachOfLimit(limit), coll, iteratee, callback);
}
function someSeries(coll, iteratee, callback) {
  return _createTester(Boolean, (res) => res)(eachOfSeries$1, coll, iteratee, callback);
}
function sortBy(coll, iteratee, callback) {
  var _iteratee = wrapAsync(iteratee);
  return map$1(coll, (x, iterCb) => {
    _iteratee(x, (err, criteria) => {
      if (err)
        return iterCb(err);
      iterCb(err, { value: x, criteria });
    });
  }, (err, results) => {
    if (err)
      return callback(err);
    callback(null, results.sort(comparator).map((v) => v.value));
  });
  function comparator(left, right) {
    var a = left.criteria, b = right.criteria;
    return a < b ? -1 : a > b ? 1 : 0;
  }
}
function timeout(asyncFn, milliseconds, info) {
  var fn2 = wrapAsync(asyncFn);
  return initialParams((args2, callback) => {
    var timedOut = false;
    var timer;
    function timeoutCallback() {
      var name = asyncFn.name || "anonymous";
      var error = new Error('Callback function "' + name + '" timed out.');
      error.code = "ETIMEDOUT";
      if (info) {
        error.info = info;
      }
      timedOut = true;
      callback(error);
    }
    args2.push((...cbArgs) => {
      if (!timedOut) {
        callback(...cbArgs);
        clearTimeout(timer);
      }
    });
    timer = setTimeout(timeoutCallback, milliseconds);
    fn2(...args2);
  });
}
function range(size) {
  var result = Array(size);
  while (size--) {
    result[size] = size;
  }
  return result;
}
function timesLimit(count, limit, iteratee, callback) {
  var _iteratee = wrapAsync(iteratee);
  return mapLimit$1(range(count), limit, _iteratee, callback);
}
function times(n, iteratee, callback) {
  return timesLimit(n, Infinity, iteratee, callback);
}
function timesSeries(n, iteratee, callback) {
  return timesLimit(n, 1, iteratee, callback);
}
function transform(coll, accumulator, iteratee, callback) {
  if (arguments.length <= 3 && typeof accumulator === "function") {
    callback = iteratee;
    iteratee = accumulator;
    accumulator = Array.isArray(coll) ? [] : {};
  }
  callback = once(callback || promiseCallback());
  var _iteratee = wrapAsync(iteratee);
  eachOf$1(coll, (v, k, cb) => {
    _iteratee(accumulator, v, k, cb);
  }, (err) => callback(err, accumulator));
  return callback[PROMISE_SYMBOL];
}
function tryEach(tasks, callback) {
  var error = null;
  var result;
  return eachSeries$1(tasks, (task, taskCb) => {
    wrapAsync(task)((err, ...args2) => {
      if (err === false)
        return taskCb(err);
      if (args2.length < 2) {
        [result] = args2;
      } else {
        result = args2;
      }
      error = err;
      taskCb(err ? null : {});
    });
  }, () => callback(error, result));
}
function unmemoize(fn2) {
  return (...args2) => {
    return (fn2.unmemoized || fn2)(...args2);
  };
}
function whilst(test, iteratee, callback) {
  callback = onlyOnce(callback);
  var _fn = wrapAsync(iteratee);
  var _test = wrapAsync(test);
  var results = [];
  function next(err, ...rest) {
    if (err)
      return callback(err);
    results = rest;
    if (err === false)
      return;
    _test(check);
  }
  function check(err, truth) {
    if (err)
      return callback(err);
    if (err === false)
      return;
    if (!truth)
      return callback(null, ...results);
    _fn(next);
  }
  return _test(check);
}
function until(test, iteratee, callback) {
  const _test = wrapAsync(test);
  return whilst$1((cb) => _test((err, truth) => cb(err, !truth)), iteratee, callback);
}
function waterfall(tasks, callback) {
  callback = once(callback);
  if (!Array.isArray(tasks))
    return callback(new Error("First argument to waterfall must be an array of functions"));
  if (!tasks.length)
    return callback();
  var taskIndex = 0;
  function nextTask(args2) {
    var task = wrapAsync(tasks[taskIndex++]);
    task(...args2, onlyOnce(next));
  }
  function next(err, ...args2) {
    if (err === false)
      return;
    if (err || taskIndex === tasks.length) {
      return callback(err, ...args2);
    }
    nextTask(args2);
  }
  nextTask([]);
}
var hasSetImmediate, hasNextTick, _defer, setImmediate$1, breakLoop, eachOfLimit, eachOfLimit$2, eachOf$1, map$1, applyEach$1, eachOfSeries$1, mapSeries$1, applyEachSeries, PROMISE_SYMBOL, FN_ARGS, ARROW_FN_ARGS, FN_ARG_SPLIT, FN_ARG, STRIP_COMMENTS, DLL, reduce$1, mapLimit$1, concatLimit$1, concat$1, concatSeries$1, detect$1, detectLimit$1, detectSeries$1, dir, doWhilst$1, each, eachLimit$2, eachSeries$1, every$1, everyLimit$1, everySeries$1, filter$1, filterLimit$1, filterSeries$1, forever$1, groupByLimit$1, log2, mapValuesLimit$1, _defer$1, nextTick, _parallel, Heap, race$1, reject$2, rejectLimit$1, rejectSeries$1, DEFAULT_TIMES, DEFAULT_INTERVAL, some$1, someLimit$1, someSeries$1, sortBy$1, tryEach$1, whilst$1, waterfall$1, index, async_default;
var init_async = __esm({
  "node_modules/cache-manager/node_modules/async/dist/async.mjs"() {
    init_esm_shims();
    hasSetImmediate = typeof setImmediate === "function" && setImmediate;
    hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    if (hasSetImmediate) {
      _defer = setImmediate;
    } else if (hasNextTick) {
      _defer = process.nextTick;
    } else {
      _defer = fallback;
    }
    setImmediate$1 = wrap(_defer);
    breakLoop = {};
    eachOfLimit = (limit) => {
      return (obj, iteratee, callback) => {
        callback = once(callback);
        if (limit <= 0) {
          throw new RangeError("concurrency limit cannot be less than 1");
        }
        if (!obj) {
          return callback(null);
        }
        if (isAsyncGenerator(obj)) {
          return asyncEachOfLimit(obj, limit, iteratee, callback);
        }
        if (isAsyncIterable(obj)) {
          return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback);
        }
        var nextElem = createIterator(obj);
        var done = false;
        var canceled = false;
        var running = 0;
        var looping = false;
        function iterateeCallback(err, value) {
          if (canceled)
            return;
          running -= 1;
          if (err) {
            done = true;
            callback(err);
          } else if (err === false) {
            done = true;
            canceled = true;
          } else if (value === breakLoop || done && running <= 0) {
            done = true;
            return callback(null);
          } else if (!looping) {
            replenish();
          }
        }
        function replenish() {
          looping = true;
          while (running < limit && !done) {
            var elem = nextElem();
            if (elem === null) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running += 1;
            iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
          }
          looping = false;
        }
        replenish();
      };
    };
    eachOfLimit$2 = awaitify(eachOfLimit$1, 4);
    eachOf$1 = awaitify(eachOf, 3);
    map$1 = awaitify(map, 3);
    applyEach$1 = applyEach(map$1);
    eachOfSeries$1 = awaitify(eachOfSeries, 3);
    mapSeries$1 = awaitify(mapSeries, 3);
    applyEachSeries = applyEach(mapSeries$1);
    PROMISE_SYMBOL = Symbol("promiseCallback");
    FN_ARGS = /^(?:async\s+)?(?:function)?\s*\w*\s*\(\s*([^)]+)\s*\)(?:\s*{)/;
    ARROW_FN_ARGS = /^(?:async\s+)?\(?\s*([^)=]+)\s*\)?(?:\s*=>)/;
    FN_ARG_SPLIT = /,/;
    FN_ARG = /(=.+)?(\s*)$/;
    STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
    DLL = class {
      constructor() {
        this.head = this.tail = null;
        this.length = 0;
      }
      removeLink(node) {
        if (node.prev)
          node.prev.next = node.next;
        else
          this.head = node.next;
        if (node.next)
          node.next.prev = node.prev;
        else
          this.tail = node.prev;
        node.prev = node.next = null;
        this.length -= 1;
        return node;
      }
      empty() {
        while (this.head)
          this.shift();
        return this;
      }
      insertAfter(node, newNode) {
        newNode.prev = node;
        newNode.next = node.next;
        if (node.next)
          node.next.prev = newNode;
        else
          this.tail = newNode;
        node.next = newNode;
        this.length += 1;
      }
      insertBefore(node, newNode) {
        newNode.prev = node.prev;
        newNode.next = node;
        if (node.prev)
          node.prev.next = newNode;
        else
          this.head = newNode;
        node.prev = newNode;
        this.length += 1;
      }
      unshift(node) {
        if (this.head)
          this.insertBefore(this.head, node);
        else
          setInitial(this, node);
      }
      push(node) {
        if (this.tail)
          this.insertAfter(this.tail, node);
        else
          setInitial(this, node);
      }
      shift() {
        return this.head && this.removeLink(this.head);
      }
      pop() {
        return this.tail && this.removeLink(this.tail);
      }
      toArray() {
        return [...this];
      }
      *[Symbol.iterator]() {
        var cur = this.head;
        while (cur) {
          yield cur.data;
          cur = cur.next;
        }
      }
      remove(testFn) {
        var curr = this.head;
        while (curr) {
          var { next } = curr;
          if (testFn(curr)) {
            this.removeLink(curr);
          }
          curr = next;
        }
        return this;
      }
    };
    reduce$1 = awaitify(reduce, 4);
    mapLimit$1 = awaitify(mapLimit, 4);
    concatLimit$1 = awaitify(concatLimit, 4);
    concat$1 = awaitify(concat, 3);
    concatSeries$1 = awaitify(concatSeries, 3);
    detect$1 = awaitify(detect, 3);
    detectLimit$1 = awaitify(detectLimit, 4);
    detectSeries$1 = awaitify(detectSeries, 3);
    dir = consoleFunc("dir");
    doWhilst$1 = awaitify(doWhilst, 3);
    each = awaitify(eachLimit, 3);
    eachLimit$2 = awaitify(eachLimit$1, 4);
    eachSeries$1 = awaitify(eachSeries, 3);
    every$1 = awaitify(every, 3);
    everyLimit$1 = awaitify(everyLimit, 4);
    everySeries$1 = awaitify(everySeries, 3);
    filter$1 = awaitify(filter, 3);
    filterLimit$1 = awaitify(filterLimit, 4);
    filterSeries$1 = awaitify(filterSeries, 3);
    forever$1 = awaitify(forever, 2);
    groupByLimit$1 = awaitify(groupByLimit, 4);
    log2 = consoleFunc("log");
    mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
    if (hasNextTick) {
      _defer$1 = process.nextTick;
    } else if (hasSetImmediate) {
      _defer$1 = setImmediate;
    } else {
      _defer$1 = fallback;
    }
    nextTick = wrap(_defer$1);
    _parallel = awaitify((eachfn, tasks, callback) => {
      var results = isArrayLike(tasks) ? [] : {};
      eachfn(tasks, (task, key, taskCb) => {
        wrapAsync(task)((err, ...result) => {
          if (result.length < 2) {
            [result] = result;
          }
          results[key] = result;
          taskCb(err);
        });
      }, (err) => callback(err, results));
    }, 3);
    Heap = class {
      constructor() {
        this.heap = [];
        this.pushCount = Number.MIN_SAFE_INTEGER;
      }
      get length() {
        return this.heap.length;
      }
      empty() {
        this.heap = [];
        return this;
      }
      percUp(index2) {
        let p;
        while (index2 > 0 && smaller(this.heap[index2], this.heap[p = parent(index2)])) {
          let t2 = this.heap[index2];
          this.heap[index2] = this.heap[p];
          this.heap[p] = t2;
          index2 = p;
        }
      }
      percDown(index2) {
        let l;
        while ((l = leftChi(index2)) < this.heap.length) {
          if (l + 1 < this.heap.length && smaller(this.heap[l + 1], this.heap[l])) {
            l = l + 1;
          }
          if (smaller(this.heap[index2], this.heap[l])) {
            break;
          }
          let t2 = this.heap[index2];
          this.heap[index2] = this.heap[l];
          this.heap[l] = t2;
          index2 = l;
        }
      }
      push(node) {
        node.pushCount = ++this.pushCount;
        this.heap.push(node);
        this.percUp(this.heap.length - 1);
      }
      unshift(node) {
        return this.heap.push(node);
      }
      shift() {
        let [top] = this.heap;
        this.heap[0] = this.heap[this.heap.length - 1];
        this.heap.pop();
        this.percDown(0);
        return top;
      }
      toArray() {
        return [...this];
      }
      *[Symbol.iterator]() {
        for (let i = 0; i < this.heap.length; i++) {
          yield this.heap[i].data;
        }
      }
      remove(testFn) {
        let j = 0;
        for (let i = 0; i < this.heap.length; i++) {
          if (!testFn(this.heap[i])) {
            this.heap[j] = this.heap[i];
            j++;
          }
        }
        this.heap.splice(j);
        for (let i = parent(this.heap.length - 1); i >= 0; i--) {
          this.percDown(i);
        }
        return this;
      }
    };
    race$1 = awaitify(race, 2);
    reject$2 = awaitify(reject$1, 3);
    rejectLimit$1 = awaitify(rejectLimit, 4);
    rejectSeries$1 = awaitify(rejectSeries, 3);
    DEFAULT_TIMES = 5;
    DEFAULT_INTERVAL = 0;
    some$1 = awaitify(some, 3);
    someLimit$1 = awaitify(someLimit, 4);
    someSeries$1 = awaitify(someSeries, 3);
    sortBy$1 = awaitify(sortBy, 3);
    tryEach$1 = awaitify(tryEach);
    whilst$1 = awaitify(whilst, 3);
    waterfall$1 = awaitify(waterfall);
    index = {
      apply,
      applyEach: applyEach$1,
      applyEachSeries,
      asyncify,
      auto,
      autoInject,
      cargo,
      cargoQueue: cargo$1,
      compose,
      concat: concat$1,
      concatLimit: concatLimit$1,
      concatSeries: concatSeries$1,
      constant,
      detect: detect$1,
      detectLimit: detectLimit$1,
      detectSeries: detectSeries$1,
      dir,
      doUntil,
      doWhilst: doWhilst$1,
      each,
      eachLimit: eachLimit$2,
      eachOf: eachOf$1,
      eachOfLimit: eachOfLimit$2,
      eachOfSeries: eachOfSeries$1,
      eachSeries: eachSeries$1,
      ensureAsync,
      every: every$1,
      everyLimit: everyLimit$1,
      everySeries: everySeries$1,
      filter: filter$1,
      filterLimit: filterLimit$1,
      filterSeries: filterSeries$1,
      forever: forever$1,
      groupBy,
      groupByLimit: groupByLimit$1,
      groupBySeries,
      log: log2,
      map: map$1,
      mapLimit: mapLimit$1,
      mapSeries: mapSeries$1,
      mapValues,
      mapValuesLimit: mapValuesLimit$1,
      mapValuesSeries,
      memoize,
      nextTick,
      parallel,
      parallelLimit,
      priorityQueue,
      queue: queue$1,
      race: race$1,
      reduce: reduce$1,
      reduceRight,
      reflect,
      reflectAll,
      reject: reject$2,
      rejectLimit: rejectLimit$1,
      rejectSeries: rejectSeries$1,
      retry,
      retryable,
      seq,
      series,
      setImmediate: setImmediate$1,
      some: some$1,
      someLimit: someLimit$1,
      someSeries: someSeries$1,
      sortBy: sortBy$1,
      timeout,
      times,
      timesLimit,
      timesSeries,
      transform,
      tryEach: tryEach$1,
      unmemoize,
      until,
      waterfall: waterfall$1,
      whilst: whilst$1,
      all: every$1,
      allLimit: everyLimit$1,
      allSeries: everySeries$1,
      any: some$1,
      anyLimit: someLimit$1,
      anySeries: someSeries$1,
      find: detect$1,
      findLimit: detectLimit$1,
      findSeries: detectSeries$1,
      flatMap: concat$1,
      flatMapLimit: concatLimit$1,
      flatMapSeries: concatSeries$1,
      forEach: each,
      forEachSeries: eachSeries$1,
      forEachLimit: eachLimit$2,
      forEachOf: eachOf$1,
      forEachOfSeries: eachOfSeries$1,
      forEachOfLimit: eachOfLimit$2,
      inject: reduce$1,
      foldl: reduce$1,
      foldr: reduceRight,
      select: filter$1,
      selectLimit: filterLimit$1,
      selectSeries: filterSeries$1,
      wrapSync: asyncify,
      during: whilst$1,
      doDuring: doWhilst$1
    };
    async_default = index;
  }
});

// node_modules/cache-manager/lib/multi_caching.js
var require_multi_caching = __commonJS({
  "node_modules/cache-manager/lib/multi_caching.js"(exports2, module2) {
    init_esm_shims();
    var async = (init_async(), __toCommonJS(async_exports));
    var CallbackFiller = require_callback_filler();
    var utils = require_utils();
    var isObject2 = utils.isObject;
    var parseWrapArguments = utils.parseWrapArguments;
    var multiCaching = function(caches, options) {
      var self = {};
      options = options || {};
      var Promise2 = options.promiseDependency || global.Promise;
      if (!Array.isArray(caches)) {
        throw new Error("multiCaching requires an array of caches");
      }
      var callbackFiller = new CallbackFiller();
      var backgroundQueue = /* @__PURE__ */ new Set();
      if (typeof options.isCacheableValue === "function") {
        self._isCacheableValue = options.isCacheableValue;
      } else {
        self._isCacheableValue = function(value) {
          return value !== void 0;
        };
      }
      function getIsCacheableValueFunction(cache) {
        if (cache.store && typeof cache.store.isCacheableValue === "function") {
          return cache.store.isCacheableValue.bind(cache.store);
        } else {
          return self._isCacheableValue;
        }
      }
      function getFromHighestPriorityCachePromise() {
        var args2 = Array.prototype.slice.apply(arguments).filter(function(v) {
          return typeof v !== "undefined";
        });
        return new Promise2(function(resolve, reject2) {
          var cb = function(err, result) {
            if (err) {
              return reject2(err);
            }
            resolve(result);
          };
          args2.push(cb);
          getFromHighestPriorityCache.apply(null, args2);
        });
      }
      function getFromHighestPriorityCache() {
        var args2 = Array.prototype.slice.apply(arguments).filter(function(v) {
          return typeof v !== "undefined";
        });
        var cb;
        var options2 = {};
        if (typeof args2[args2.length - 1] === "function") {
          cb = args2.pop();
        }
        if (!cb) {
          return getFromHighestPriorityCachePromise.apply(this, args2);
        }
        if (isObject2(args2[args2.length - 1])) {
          options2 = args2.pop();
        }
        var keys = Array.prototype.slice.apply(args2);
        var multi = keys.length > 1;
        args2.push(options2);
        if (multi) {
          var keysToFetch = Array.prototype.slice.apply(keys);
          var mapResult = {};
        }
        var i = 0;
        async.eachSeries(caches, function(cache, next) {
          var callback = function(err, result) {
            if (err) {
              return next(err);
            }
            var _isCacheableValue = getIsCacheableValueFunction(cache);
            if (multi) {
              addResultToMap(result, _isCacheableValue);
              if (keysToFetch.length === 0 || i === caches.length - 1) {
                return cb(null, keys.map(function(k) {
                  return mapResult[k] || void 0;
                }), i);
              }
            } else if (_isCacheableValue(result)) {
              return cb(err, result, i);
            }
            i += 1;
            next();
          };
          if (multi) {
            if (typeof cache.store.mget !== "function") {
              return callback(null, []);
            }
            var _args = Array.prototype.slice.apply(keysToFetch);
            _args.push(options2);
            _args.push(callback);
            cache.store.mget.apply(cache.store, _args);
          } else {
            try {
              cache.store.get(args2[0], options2, callback);
            } catch (err) {
              callback(err);
            }
          }
        }, function(err, result) {
          return cb(err, result);
        });
        function addResultToMap(result, isCacheable) {
          var key;
          var diff = 0;
          result.forEach(function(res, i2) {
            if (isCacheable(res)) {
              key = keysToFetch[i2 - diff];
              mapResult[key] = res;
              keysToFetch.splice(i2 - diff, 1);
              diff += 1;
            }
          });
        }
      }
      function setInMultipleCachesPromise() {
        var args2 = Array.prototype.slice.apply(arguments);
        return new Promise2(function(resolve, reject2) {
          var cb = function(err, result) {
            if (err) {
              return reject2(err);
            }
            resolve(result);
          };
          args2.push(cb);
          setInMultipleCaches.apply(null, args2);
        });
      }
      function setInMultipleCaches() {
        var args2 = Array.prototype.slice.apply(arguments);
        var _caches = Array.isArray(args2[0]) ? args2.shift() : caches;
        var cb;
        var options2 = {};
        if (typeof args2[args2.length - 1] === "function") {
          cb = args2.pop();
        }
        if (!cb) {
          return setInMultipleCachesPromise.apply(this, args2);
        }
        if (args2.length % 2 > 0 && isObject2(args2[args2.length - 1])) {
          options2 = args2.pop();
        }
        var length = args2.length;
        var multi = length > 2;
        var i;
        async.each(_caches, function(cache, next) {
          var _isCacheableValue = getIsCacheableValueFunction(cache);
          var keysValues = Array.prototype.slice.apply(args2);
          for (i = 0; i < length; i += 2) {
            if (!_isCacheableValue(keysValues[i + 1])) {
              keysValues.splice(i, 2);
            }
          }
          if (keysValues.length === 0) {
            return next();
          }
          var cacheOptions = options2;
          if (typeof options2.ttl === "function") {
            cacheOptions = {};
            cacheOptions.ttl = options2.ttl(keysValues, cache.store.name);
          }
          if (multi) {
            if (typeof cache.store.mset !== "function") {
              return next();
            }
            keysValues.push(cacheOptions);
            keysValues.push(next);
            cache.store.mset.apply(cache.store, keysValues);
          } else {
            cache.store.set(keysValues[0], keysValues[1], cacheOptions, next);
          }
        }, function(err, result) {
          cb(err, result);
        });
      }
      function getAndPassUpPromise(key) {
        return new Promise2(function(resolve, reject2) {
          self.getAndPassUp(key, function(err, result) {
            if (err) {
              return reject2(err);
            }
            resolve(result);
          });
        });
      }
      self.getAndPassUp = function(key, cb) {
        if (!cb) {
          return getAndPassUpPromise(key);
        }
        getFromHighestPriorityCache(key, function(err, result, index2) {
          if (err) {
            return cb(err);
          }
          if (index2) {
            var cachesToUpdate = caches.slice(0, index2);
            async.each(cachesToUpdate, function(cache, next) {
              var _isCacheableValue = getIsCacheableValueFunction(cache);
              if (_isCacheableValue(result)) {
                cache.set(key, result, next);
              }
            });
          }
          return cb(err, result);
        });
      };
      function wrapPromise(key, promise, options2) {
        return new Promise2(function(resolve, reject2) {
          self.wrap(key, function(cb) {
            Promise2.resolve().then(promise).then(function(result) {
              cb(null, result);
            }).catch(cb);
          }, options2, function(err, result) {
            if (err) {
              return reject2(err);
            }
            resolve(result);
          });
        });
      }
      function handleBackgroundRefresh(caches2, index2, key, work, options2) {
        if (caches2[index2].refreshThreshold && !backgroundQueue.has(key)) {
          backgroundQueue.add(key);
          caches2[index2].checkRefreshThreshold(key, function(err, isExpiring) {
            if (err) {
              backgroundQueue.delete(key);
              return;
            }
            if (isExpiring) {
              work(function(workErr, workData) {
                if (workErr || !self._isCacheableValue(workData)) {
                  backgroundQueue.delete(key);
                  return;
                }
                var args2 = [caches2, key, workData, options2, function() {
                  backgroundQueue.delete(key);
                }];
                setInMultipleCaches.apply(null, args2);
              });
            } else {
              backgroundQueue.delete(key);
            }
          });
        }
      }
      self.wrap = function() {
        var parsedArgs = parseWrapArguments(Array.prototype.slice.apply(arguments));
        var keys = parsedArgs.keys;
        var work = parsedArgs.work;
        var options2 = parsedArgs.options;
        var cb = parsedArgs.cb;
        if (!cb) {
          keys.push(work);
          keys.push(options2);
          return wrapPromise.apply(this, keys);
        }
        if (keys.length > 1) {
          return wrapMultiple(keys, work, options2, cb);
        }
        var key = keys[0];
        var hasKey = callbackFiller.has(key);
        callbackFiller.add(key, { cb });
        if (hasKey) {
          return;
        }
        getFromHighestPriorityCache(key, function(err, result, index2) {
          if (err) {
            return callbackFiller.fill(key, err);
          } else if (self._isCacheableValue(result)) {
            handleBackgroundRefresh(caches, index2, key, work, options2);
            var cachesToUpdate = caches.slice(0, index2);
            var args2 = [cachesToUpdate, key, result, options2, function(err2) {
              callbackFiller.fill(key, err2, result);
            }];
            setInMultipleCaches.apply(null, args2);
          } else {
            work(function(err2, data) {
              if (err2) {
                return callbackFiller.fill(key, err2);
              }
              if (!self._isCacheableValue(data)) {
                return callbackFiller.fill(key, err2, data);
              }
              var args3 = [caches, key, data, options2, function(err3) {
                callbackFiller.fill(key, err3, data);
              }];
              setInMultipleCaches.apply(null, args3);
            });
          }
        });
      };
      function wrapMultiple(keys, work, options2, cb) {
        var combinedKey = keys.reduce(function(acc, k) {
          return acc + k;
        }, "");
        var hasKey = callbackFiller.has(combinedKey);
        callbackFiller.add(combinedKey, { cb });
        if (hasKey) {
          return;
        }
        keys.push(options2);
        keys.push(onResult);
        getFromHighestPriorityCache.apply(this, keys);
        function onResult(err, result, index2) {
          if (err) {
            return done(err);
          }
          var cacheOK = result.filter(function(_result) {
            return self._isCacheableValue(_result);
          }).length === result.length;
          if (!cacheOK) {
            return work(workCallback);
          }
          var cachesToUpdate = caches.slice(0, index2);
          var _args = [cachesToUpdate];
          result.forEach(function(value, i) {
            _args.push(keys[i]);
            _args.push(value);
          });
          _args.push(options2);
          _args.push(function(err2) {
            done(err2, result);
          });
          return setInMultipleCaches.apply(null, _args);
          function workCallback(err2, data) {
            if (err2) {
              return done(err2);
            }
            var _args2;
            _args2 = [];
            data.forEach(function(value, i) {
              if (self._isCacheableValue(value)) {
                _args2.push(keys[i]);
                _args2.push(value);
              }
            });
            if (_args2.length === 0) {
              return done(null);
            }
            _args2.push(options2);
            _args2.push(function(err3) {
              done(err3, data);
            });
            setInMultipleCaches.apply(null, _args2);
          }
          function done(err2, data) {
            callbackFiller.fill(combinedKey, err2, data);
          }
        }
      }
      self.set = setInMultipleCaches;
      self.mset = setInMultipleCaches;
      self.get = getFromHighestPriorityCache;
      self.mget = getFromHighestPriorityCache;
      self.del = function() {
        var args2 = Array.prototype.slice.apply(arguments);
        var cb;
        var options2 = {};
        if (typeof args2[args2.length - 1] === "function") {
          cb = args2.pop();
        }
        if (isObject2(args2[args2.length - 1])) {
          options2 = args2.pop();
        }
        args2.push(options2);
        async.each(caches, function(cache, next) {
          var _args = Array.prototype.slice.apply(args2);
          _args.push(next);
          cache.store.del.apply(cache.store, _args);
        }, cb);
      };
      self.reset = function(cb) {
        async.each(caches, function(cache, next) {
          cache.store.reset(next);
        }, cb);
      };
      return self;
    };
    module2.exports = multiCaching;
  }
});

// node_modules/cache-manager/lib/index.js
var require_lib = __commonJS({
  "node_modules/cache-manager/lib/index.js"(exports2, module2) {
    init_esm_shims();
    var cacheManager = {
      caching: require_caching(),
      multiCaching: require_multi_caching()
    };
    module2.exports = cacheManager;
  }
});

// node_modules/cache-manager/index.js
var require_cache_manager = __commonJS({
  "node_modules/cache-manager/index.js"(exports2, module2) {
    init_esm_shims();
    module2.exports = require_lib();
  }
});

// packages/platform-fastify/node_modules/reusify/reusify.js
var require_reusify = __commonJS({
  "packages/platform-fastify/node_modules/reusify/reusify.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    function reusify(Constructor) {
      var head = new Constructor();
      var tail = head;
      function get() {
        var current = head;
        if (current.next) {
          head = current.next;
        } else {
          head = new Constructor();
          tail = head;
        }
        current.next = null;
        return current;
      }
      function release(obj) {
        tail.next = obj;
        tail = obj;
      }
      return {
        get,
        release
      };
    }
    module2.exports = reusify;
  }
});

// packages/platform-fastify/node_modules/fastq/queue.js
var require_queue = __commonJS({
  "packages/platform-fastify/node_modules/fastq/queue.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var reusify = require_reusify();
    function fastqueue(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      if (concurrency < 1) {
        throw new Error("fastqueue concurrency must be greater than 1");
      }
      var cache = reusify(Task);
      var queueHead = null;
      var queueTail = null;
      var _running = 0;
      var errorHandler = null;
      var self = {
        push,
        drain: noop,
        saturated: noop,
        pause,
        paused: false,
        concurrency,
        running,
        resume,
        idle,
        length,
        getQueue,
        unshift,
        empty: noop,
        kill,
        killAndDrain,
        error
      };
      return self;
      function running() {
        return _running;
      }
      function pause() {
        self.paused = true;
      }
      function length() {
        var current = queueHead;
        var counter = 0;
        while (current) {
          current = current.next;
          counter++;
        }
        return counter;
      }
      function getQueue() {
        var current = queueHead;
        var tasks = [];
        while (current) {
          tasks.push(current.value);
          current = current.next;
        }
        return tasks;
      }
      function resume() {
        if (!self.paused)
          return;
        self.paused = false;
        for (var i = 0; i < self.concurrency; i++) {
          _running++;
          release();
        }
      }
      function idle() {
        return _running === 0 && self.length() === 0;
      }
      function push(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        current.errorHandler = errorHandler;
        if (_running === self.concurrency || self.paused) {
          if (queueTail) {
            queueTail.next = current;
            queueTail = current;
          } else {
            queueHead = current;
            queueTail = current;
            self.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function unshift(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        if (_running === self.concurrency || self.paused) {
          if (queueHead) {
            current.next = queueHead;
            queueHead = current;
          } else {
            queueHead = current;
            queueTail = current;
            self.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function release(holder) {
        if (holder) {
          cache.release(holder);
        }
        var next = queueHead;
        if (next) {
          if (!self.paused) {
            if (queueTail === queueHead) {
              queueTail = null;
            }
            queueHead = next.next;
            next.next = null;
            worker.call(context, next.value, next.worked);
            if (queueTail === null) {
              self.empty();
            }
          } else {
            _running--;
          }
        } else if (--_running === 0) {
          self.drain();
        }
      }
      function kill() {
        queueHead = null;
        queueTail = null;
        self.drain = noop;
      }
      function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self.drain();
        self.drain = noop;
      }
      function error(handler) {
        errorHandler = handler;
      }
    }
    function noop() {
    }
    function Task() {
      this.value = null;
      this.callback = noop;
      this.next = null;
      this.release = noop;
      this.context = null;
      this.errorHandler = null;
      var self = this;
      this.worked = function worked(err, result) {
        var callback = self.callback;
        var errorHandler = self.errorHandler;
        var val = self.value;
        self.value = null;
        self.callback = noop;
        if (self.errorHandler) {
          errorHandler(err, val);
        }
        callback.call(self.context, err, result);
        self.release(self);
      };
    }
    function queueAsPromised(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue2 = fastqueue(context, asyncWrapper, concurrency);
      var pushCb = queue2.push;
      var unshiftCb = queue2.unshift;
      queue2.push = push;
      queue2.unshift = unshift;
      queue2.drained = drained;
      return queue2;
      function push(value) {
        var p = new Promise(function(resolve, reject2) {
          pushCb(value, function(err, result) {
            if (err) {
              reject2(err);
              return;
            }
            resolve(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function unshift(value) {
        var p = new Promise(function(resolve, reject2) {
          unshiftCb(value, function(err, result) {
            if (err) {
              reject2(err);
              return;
            }
            resolve(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function drained() {
        var previousDrain = queue2.drain;
        var p = new Promise(function(resolve) {
          queue2.drain = function() {
            previousDrain();
            resolve();
          };
        });
        return p;
      }
    }
    module2.exports = fastqueue;
    module2.exports.promise = queueAsPromised;
  }
});

// packages/platform-fastify/node_modules/archy/index.js
var require_archy = __commonJS({
  "packages/platform-fastify/node_modules/archy/index.js"(exports2, module2) {
    init_esm_shims();
    module2.exports = function archy(obj, prefix, opts) {
      if (prefix === void 0)
        prefix = "";
      if (!opts)
        opts = {};
      var chr = function(s2) {
        var chars = {
          "\u2502": "|",
          "\u2514": "`",
          "\u251C": "+",
          "\u2500": "-",
          "\u252C": "-"
        };
        return opts.unicode === false ? chars[s2] : s2;
      };
      if (typeof obj === "string")
        obj = { label: obj };
      var nodes = obj.nodes || [];
      var lines = (obj.label || "").split("\n");
      var splitter = "\n" + prefix + (nodes.length ? chr("\u2502") : " ") + " ";
      return prefix + lines.join(splitter) + "\n" + nodes.map(function(node, ix) {
        var last = ix === nodes.length - 1;
        var more = node.nodes && node.nodes.length;
        var prefix_ = prefix + (last ? " " : chr("\u2502")) + " ";
        return prefix + (last ? chr("\u2514") : chr("\u251C")) + chr("\u2500") + (more ? chr("\u252C") : chr("\u2500")) + " " + archy(node, prefix_, opts).slice(prefix.length + 2);
      }).join("");
    };
  }
});

// packages/platform-fastify/node_modules/avvio/time-tree.js
var require_time_tree = __commonJS({
  "packages/platform-fastify/node_modules/avvio/time-tree.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var archy = require_archy();
    function TimeTree() {
      this.root = null;
      this.tableId = /* @__PURE__ */ new Map();
      this.tableLabel = /* @__PURE__ */ new Map();
    }
    TimeTree.prototype.trackNode = function(node) {
      this.tableId.set(node.id, node);
      if (this.tableLabel.has(node.label)) {
        this.tableLabel.get(node.label).push(node);
      } else {
        this.tableLabel.set(node.label, [node]);
      }
    };
    TimeTree.prototype.untrackNode = function(node) {
      this.tableId.delete(node.id);
      const labelNode = this.tableLabel.get(node.label);
      if (labelNode.id) {
        this.tableLabel.delete(node.label);
        return;
      }
      labelNode.pop();
      if (labelNode.length === 0) {
        this.tableLabel.delete(node.label);
      }
    };
    TimeTree.prototype.getParent = function(parent2) {
      if (parent2 === null) {
        return this.root;
      }
      const parentNode = this.tableLabel.get(parent2);
      if (parentNode.id) {
        return parentNode;
      }
      return parentNode[parentNode.length - 1];
    };
    TimeTree.prototype.getNode = function(nodeId) {
      return this.tableId.get(nodeId);
    };
    TimeTree.prototype.add = function(parent2, child, start) {
      const isRoot = parent2 === null;
      if (isRoot) {
        this.root = {
          id: "root",
          label: child,
          start,
          nodes: []
        };
        this.trackNode(this.root);
        return this.root.id;
      }
      const parentNode = this.getParent(parent2);
      const nodeId = `${child}-${Math.random()}`;
      const childNode = {
        id: nodeId,
        parent: parent2,
        start,
        label: child,
        nodes: []
      };
      parentNode.nodes.push(childNode);
      this.trackNode(childNode);
      return nodeId;
    };
    TimeTree.prototype.start = function(parent2, child, start) {
      return this.add(parent2, child, start || Date.now());
    };
    TimeTree.prototype.stop = function(nodeId, stop) {
      const node = this.getNode(nodeId);
      if (node) {
        node.stop = stop || Date.now();
        node.diff = node.stop - node.start || 0;
        this.untrackNode(node);
      }
    };
    TimeTree.prototype.toJSON = function() {
      return Object.assign({}, this.root);
    };
    TimeTree.prototype.prittyPrint = function() {
      const decorateText = (node) => {
        node.label = `${node.label} ${node.diff} ms`;
        if (node.nodes.length > 0) {
          node.nodes = node.nodes.map((_) => decorateText(_));
        }
        return node;
      };
      const out = decorateText(this.toJSON());
      return archy(out);
    };
    module2.exports = TimeTree;
  }
});

// packages/platform-fastify/node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS({
  "packages/platform-fastify/node_modules/queue-microtask/index.js"(exports2, module2) {
    init_esm_shims();
    var promise;
    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
  }
});

// packages/platform-fastify/node_modules/ms/index.js
var require_ms = __commonJS({
  "packages/platform-fastify/node_modules/ms/index.js"(exports2, module2) {
    init_esm_shims();
    var s2 = 1e3;
    var m = s2 * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms / s2) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms, msAbs, s2, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// packages/platform-fastify/node_modules/debug/src/common.js
var require_common = __commonJS({
  "packages/platform-fastify/node_modules/debug/src/common.js"(exports2, module2) {
    init_esm_shims();
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args2) {
          if (!debug.enabled) {
            return;
          }
          const self = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args2[0] = createDebug.coerce(args2[0]);
          if (typeof args2[0] !== "string") {
            args2.unshift("%O");
          }
          let index2 = 0;
          args2[0] = args2[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index2++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args2[index2];
              match = formatter.call(self, val);
              args2.splice(index2, 1);
              index2--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args2);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args2);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// packages/platform-fastify/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "packages/platform-fastify/node_modules/debug/src/browser.js"(exports2, module2) {
    init_esm_shims();
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args2) {
      args2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args2[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args2.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args2[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args2.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// packages/platform-fastify/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "packages/platform-fastify/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// packages/platform-fastify/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "packages/platform-fastify/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var os = __require("os");
    var tty = __require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// packages/platform-fastify/node_modules/debug/src/node.js
var require_node = __commonJS({
  "packages/platform-fastify/node_modules/debug/src/node.js"(exports2, module2) {
    init_esm_shims();
    var tty = __require("tty");
    var util = __require("util");
    exports2.init = init;
    exports2.log = log3;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args2) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args2[0] = prefix + args2[0].split("\n").join("\n" + prefix);
        args2.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args2[0] = getDate() + name + " " + args2[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log3(...args2) {
      return process.stderr.write(util.format(...args2) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// packages/platform-fastify/node_modules/debug/src/index.js
var require_src = __commonJS({
  "packages/platform-fastify/node_modules/debug/src/index.js"(exports2, module2) {
    init_esm_shims();
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// packages/platform-fastify/node_modules/avvio/plugin.js
var require_plugin = __commonJS({
  "packages/platform-fastify/node_modules/avvio/plugin.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var queueMicrotask2 = require_queue_microtask();
    var fastq = require_queue();
    var EE = __require("events").EventEmitter;
    var inherits = __require("util").inherits;
    var debug = require_src()("avvio");
    var CODE_PLUGIN_TIMEOUT = "ERR_AVVIO_PLUGIN_TIMEOUT";
    function getName(func) {
      const cache = __require.cache;
      const keys = Object.keys(cache);
      for (var i = 0; i < keys.length; i++) {
        if (cache[keys[i]].exports === func) {
          return keys[i];
        }
      }
      if (func.name) {
        return func.name;
      }
      return func.toString().split("\n").slice(0, 2).map((s2) => s2.trim()).join(" -- ");
    }
    function promise() {
      const obj = {};
      obj.promise = new Promise((resolve, reject2) => {
        obj.resolve = resolve;
        obj.reject = reject2;
      });
      return obj;
    }
    function Plugin(parent2, func, optsOrFunc, isAfter, timeout2) {
      this.started = false;
      this.func = func;
      this.opts = optsOrFunc;
      this.onFinish = null;
      this.parent = parent2;
      this.timeout = timeout2 === void 0 ? parent2._timeout : timeout2;
      this.name = getName(func);
      this.isAfter = isAfter;
      this.q = fastq(parent2, loadPluginNextTick, 1);
      this.q.pause();
      this._error = null;
      this.loaded = false;
      this._promise = null;
    }
    inherits(Plugin, EE);
    Plugin.prototype.exec = function(server, cb) {
      const func = this.func;
      let completed = false;
      const name = this.name;
      if (this.parent._error && !this.isAfter) {
        debug("skipping loading of plugin as parent errored and it is not an after", name);
        process.nextTick(cb);
        return;
      }
      if (!this.isAfter) {
        try {
          this.server = this.parent.override(server, func, this.opts);
        } catch (err) {
          debug("override errored", name);
          return cb(err);
        }
      } else {
        this.server = server;
      }
      this.opts = typeof this.opts === "function" ? this.opts(this.server) : this.opts;
      debug("exec", name);
      let timer;
      const done = (err) => {
        if (completed) {
          debug("loading complete", name);
          return;
        }
        this._error = err;
        if (err) {
          debug("exec errored", name);
        } else {
          debug("exec completed", name);
        }
        completed = true;
        if (timer) {
          clearTimeout(timer);
        }
        cb(err);
      };
      if (this.timeout > 0) {
        debug("setting up timeout", name, this.timeout);
        timer = setTimeout(function() {
          debug("timed out", name);
          timer = null;
          const err = new Error(`${CODE_PLUGIN_TIMEOUT}: plugin did not start in time: ${name}. You may have forgotten to call 'done' function or to resolve a Promise`);
          err.code = CODE_PLUGIN_TIMEOUT;
          err.fn = func;
          done(err);
        }, this.timeout);
      }
      this.started = true;
      this.emit("start", this.server ? this.server.name : null, this.name, Date.now());
      const promise2 = func(this.server, this.opts, done);
      if (promise2 && typeof promise2.then === "function") {
        debug("exec: resolving promise", name);
        promise2.then(() => process.nextTick(done), (e) => process.nextTick(done, e));
      }
    };
    Plugin.prototype.loadedSoFar = function() {
      if (this.loaded) {
        return Promise.resolve();
      }
      const setup = () => {
        this.server.after((err, cb) => {
          this._error = err;
          this.q.pause();
          if (err) {
            debug("rejecting promise", this.name, err);
            this._promise.reject(err);
          } else {
            debug("resolving promise", this.name);
            this._promise.resolve();
          }
          this._promise = null;
          process.nextTick(cb, err);
        });
        this.q.resume();
      };
      let res;
      if (!this._promise) {
        this._promise = promise();
        res = this._promise.promise;
        if (!this.server) {
          this.on("start", setup);
        } else {
          setup();
        }
      } else {
        res = Promise.resolve();
      }
      return res;
    };
    Plugin.prototype.enqueue = function(obj, cb) {
      debug("enqueue", this.name, obj.name);
      this.emit("enqueue", this.server ? this.server.name : null, this.name, Date.now());
      this.q.push(obj, cb);
    };
    Plugin.prototype.finish = function(err, cb) {
      debug("finish", this.name, err);
      const done = () => {
        if (this.loaded) {
          return;
        }
        debug("loaded", this.name);
        this.emit("loaded", this.server ? this.server.name : null, this.name, Date.now());
        this.loaded = true;
        cb(err);
      };
      if (err) {
        if (this._promise) {
          this._promise.reject(err);
          this._promise = null;
        }
        done();
        return;
      }
      const check = () => {
        debug("check", this.name, this.q.length(), this.q.running(), this._promise);
        if (this.q.length() === 0 && this.q.running() === 0) {
          if (this._promise) {
            const wrap2 = () => {
              debug("wrap");
              queueMicrotask2(check);
            };
            this._promise.resolve();
            this._promise.promise.then(wrap2, wrap2);
            this._promise = null;
          } else {
            done();
          }
        } else {
          debug("delayed", this.name);
          this.q.drain = () => {
            debug("drain", this.name);
            this.q.drain = noop;
            queueMicrotask2(check);
          };
        }
      };
      queueMicrotask2(check);
      this.q.resume();
    };
    function loadPluginNextTick(toLoad, cb) {
      const parent2 = this;
      process.nextTick(loadPlugin.bind(parent2), toLoad, cb);
    }
    function loadPlugin(toLoad, cb) {
      if (typeof toLoad.func.then === "function") {
        toLoad.func.then((fn2) => {
          if (typeof fn2.default === "function") {
            fn2 = fn2.default;
          }
          toLoad.func = fn2;
          loadPlugin.call(this, toLoad, cb);
        }, cb);
        return;
      }
      const last = this._current[0];
      this._current.unshift(toLoad);
      toLoad.exec(last && last.server || this._server, (err) => {
        toLoad.finish(err, (err2) => {
          this._current.shift();
          cb(err2);
        });
      });
    }
    function noop() {
    }
    module2.exports = Plugin;
    module2.exports.loadPlugin = loadPlugin;
  }
});

// packages/platform-fastify/node_modules/avvio/boot.js
var require_boot = __commonJS({
  "packages/platform-fastify/node_modules/avvio/boot.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var fastq = require_queue();
    var EE = __require("events").EventEmitter;
    var inherits = __require("util").inherits;
    var TimeTree = require_time_tree();
    var Plugin = require_plugin();
    var debug = require_src()("avvio");
    var kAvvio = Symbol("kAvvio");
    var kThenifyDoNotWrap = Symbol("kThenifyDoNotWrap");
    function wrap2(server, opts, instance) {
      const expose = opts.expose || {};
      const useKey = expose.use || "use";
      const afterKey = expose.after || "after";
      const readyKey = expose.ready || "ready";
      const onCloseKey = expose.onClose || "onClose";
      const closeKey = expose.close || "close";
      if (server[useKey]) {
        throw new Error(useKey + "() is already defined, specify an expose option");
      }
      if (server[afterKey]) {
        throw new Error(afterKey + "() is already defined, specify an expose option");
      }
      if (server[readyKey]) {
        throw new Error(readyKey + "() is already defined, specify an expose option");
      }
      server[useKey] = function(fn2, opts2) {
        instance.use(fn2, opts2);
        return this;
      };
      Object.defineProperty(server, "then", { get: thenify.bind(instance) });
      server[kAvvio] = true;
      server[afterKey] = function(func) {
        if (typeof func !== "function") {
          return instance._loadRegistered();
        }
        instance.after(encapsulateThreeParam(func, this));
        return this;
      };
      server[readyKey] = function(func) {
        if (func && typeof func !== "function") {
          throw new Error("not a function");
        }
        return instance.ready(func ? encapsulateThreeParam(func, this) : void 0);
      };
      server[onCloseKey] = function(func) {
        if (typeof func !== "function") {
          throw new Error("not a function");
        }
        instance.onClose(encapsulateTwoParam(func, this));
        return this;
      };
      server[closeKey] = function(func) {
        if (func && typeof func !== "function") {
          throw new Error("not a function");
        }
        if (func) {
          instance.close(encapsulateThreeParam(func, this));
          return this;
        }
        return instance.close();
      };
    }
    function Boot(server, opts, done) {
      if (typeof server === "function" && arguments.length === 1) {
        done = server;
        opts = {};
        server = null;
      }
      if (typeof opts === "function") {
        done = opts;
        opts = {};
      }
      opts = opts || {};
      if (!(this instanceof Boot)) {
        const instance = new Boot(server, opts, done);
        if (server) {
          wrap2(server, opts, instance);
        }
        return instance;
      }
      if (opts.autostart !== false) {
        opts.autostart = true;
      }
      server = server || this;
      this._timeout = Number(opts.timeout) || 0;
      this._server = server;
      this._current = [];
      this._error = null;
      this._isOnCloseHandlerKey = Symbol("isOnCloseHandler");
      this._lastUsed = null;
      this.setMaxListeners(0);
      if (done) {
        this.once("start", done);
      }
      this.started = false;
      this.booted = false;
      this.pluginTree = new TimeTree();
      this._readyQ = fastq(this, callWithCbOrNextTick, 1);
      this._readyQ.pause();
      this._readyQ.drain = () => {
        this.emit("start");
        this._readyQ.drain = noop;
      };
      this._closeQ = fastq(this, closeWithCbOrNextTick, 1);
      this._closeQ.pause();
      this._closeQ.drain = () => {
        this.emit("close");
        this._closeQ.drain = noop;
      };
      this._doStart = null;
      this._root = new Plugin(this, root.bind(this), opts, false, 0);
      this._root.once("start", (serverName, funcName, time) => {
        const nodeId = this.pluginTree.start(null, funcName, time);
        this._root.once("loaded", (serverName2, funcName2, time2) => {
          this.pluginTree.stop(nodeId, time2);
        });
      });
      Plugin.loadPlugin.call(this, this._root, (err) => {
        debug("root plugin ready");
        try {
          this.emit("preReady");
          this._root = null;
        } catch (prereadyError) {
          err = err || this._error || prereadyError;
        }
        if (err) {
          this._error = err;
          if (this._readyQ.length() === 0) {
            throw err;
          }
        } else {
          this.booted = true;
        }
        this._readyQ.resume();
      });
    }
    function root(s2, opts, done) {
      this._doStart = done;
      if (opts.autostart) {
        this.start();
      }
    }
    inherits(Boot, EE);
    Boot.prototype.start = function() {
      this.started = true;
      process.nextTick(this._doStart);
      return this;
    };
    Boot.prototype.override = function(server, func, opts) {
      return server;
    };
    function assertPlugin(plugin) {
      if (plugin && typeof plugin === "object" && typeof plugin.default === "function") {
        plugin = plugin.default;
      }
      if (!(plugin && (typeof plugin === "function" || typeof plugin.then === "function"))) {
        throw new Error("plugin must be a function or a promise");
      }
      return plugin;
    }
    Boot.prototype[kAvvio] = true;
    Boot.prototype.use = function(plugin, opts) {
      this._lastUsed = this._addPlugin(plugin, opts, false);
      return this;
    };
    Boot.prototype._loadRegistered = function() {
      const plugin = this._current[0];
      const weNeedToStart = !this.started && !this.booted;
      if (weNeedToStart) {
        process.nextTick(() => this._root.q.resume());
      }
      if (!plugin) {
        return Promise.resolve();
      }
      return plugin.loadedSoFar();
    };
    Object.defineProperty(Boot.prototype, "then", { get: thenify });
    Boot.prototype._addPlugin = function(plugin, opts, isAfter) {
      plugin = assertPlugin(plugin);
      opts = opts || {};
      if (this.booted) {
        throw new Error("root plugin has already booted");
      }
      const current = this._current[0];
      const obj = new Plugin(this, plugin, opts, isAfter);
      obj.once("start", (serverName, funcName, time) => {
        const nodeId = this.pluginTree.start(current.name, funcName, time);
        obj.once("loaded", (serverName2, funcName2, time2) => {
          this.pluginTree.stop(nodeId, time2);
        });
      });
      if (current.loaded) {
        throw new Error(`Impossible to load "${obj.name}" plugin because the parent "${current.name}" was already loaded`);
      }
      current.enqueue(obj, (err) => {
        if (err) {
          this._error = err;
        }
      });
      return obj;
    };
    Boot.prototype.after = function(func) {
      if (!func) {
        return this._loadRegistered();
      }
      this._addPlugin(_after.bind(this), {}, true);
      function _after(s2, opts, done) {
        callWithCbOrNextTick.call(this, func, done);
      }
      return this;
    };
    Boot.prototype.onClose = function(func) {
      if (typeof func !== "function") {
        throw new Error("not a function");
      }
      func[this._isOnCloseHandlerKey] = true;
      this._closeQ.unshift(func, callback.bind(this));
      function callback(err) {
        if (err)
          this._error = err;
      }
      return this;
    };
    Boot.prototype.close = function(func) {
      let promise;
      if (func) {
        if (typeof func !== "function") {
          throw new Error("not a function");
        }
      } else {
        promise = new Promise(function(resolve, reject2) {
          func = function(err) {
            if (err) {
              return reject2(err);
            }
            resolve();
          };
        });
      }
      this.ready(() => {
        this._error = null;
        this._closeQ.push(func);
        process.nextTick(this._closeQ.resume.bind(this._closeQ));
      });
      return promise;
    };
    Boot.prototype.ready = function(func) {
      if (func) {
        if (typeof func !== "function") {
          throw new Error("not a function");
        }
        this._readyQ.push(func);
        this.start();
        return;
      }
      return new Promise((resolve, reject2) => {
        this._readyQ.push(readyPromiseCB);
        this.start();
        const relativeContext = this._current[0].server;
        function readyPromiseCB(err, context, done) {
          if (err) {
            reject2(err);
          } else {
            resolve(relativeContext);
          }
          process.nextTick(done);
        }
      });
    };
    Boot.prototype.prettyPrint = function() {
      return this.pluginTree.prittyPrint();
    };
    Boot.prototype.toJSON = function() {
      return this.pluginTree.toJSON();
    };
    function noop() {
    }
    function thenify() {
      if (this.booted) {
        debug("thenify returning null because we are already booted");
        return;
      }
      if (this[kThenifyDoNotWrap]) {
        this[kThenifyDoNotWrap] = false;
        return;
      }
      debug("thenify");
      return (resolve, reject2) => {
        const p = this._loadRegistered();
        return p.then(() => {
          this[kThenifyDoNotWrap] = true;
          return resolve(this._server);
        }, reject2);
      };
    }
    function callWithCbOrNextTick(func, cb, context) {
      context = this._server;
      const err = this._error;
      let res;
      this._error = null;
      if (func.length === 0) {
        this._error = err;
        res = func();
        if (res && !res[kAvvio] && typeof res.then === "function") {
          res.then(() => process.nextTick(cb), (e) => process.nextTick(cb, e));
        } else {
          process.nextTick(cb);
        }
      } else if (func.length === 1) {
        res = func(err);
        if (res && !res[kAvvio] && typeof res.then === "function") {
          res.then(() => process.nextTick(cb), (e) => process.nextTick(cb, e));
        } else {
          process.nextTick(cb);
        }
      } else {
        if (this._timeout === 0) {
          if (func.length === 2) {
            func(err, cb);
          } else {
            func(err, context, cb);
          }
        } else {
          timeoutCall.call(this, func, err, context, cb);
        }
      }
    }
    function timeoutCall(func, rootErr, context, cb) {
      const name = func.name;
      debug("setting up ready timeout", name, this._timeout);
      let timer = setTimeout(() => {
        debug("timed out", name);
        timer = null;
        const toutErr = new Error(`ERR_AVVIO_READY_TIMEOUT: plugin did not start in time: ${name}. You may have forgotten to call 'done' function or to resolve a Promise`);
        toutErr.code = "ERR_AVVIO_READY_TIMEOUT";
        toutErr.fn = func;
        this._error = toutErr;
        cb(toutErr);
      }, this._timeout);
      if (func.length === 2) {
        func(rootErr, timeoutCb.bind(this));
      } else {
        func(rootErr, context, timeoutCb.bind(this));
      }
      function timeoutCb(err) {
        if (timer) {
          clearTimeout(timer);
          this._error = err;
          cb(this._error);
        } else {
        }
      }
    }
    function closeWithCbOrNextTick(func, cb, context) {
      context = this._server;
      const isOnCloseHandler = func[this._isOnCloseHandlerKey];
      if (func.length === 0 || func.length === 1) {
        let promise;
        if (isOnCloseHandler) {
          promise = func(context);
        } else {
          promise = func(this._error);
        }
        if (promise && typeof promise.then === "function") {
          debug("resolving close/onClose promise");
          promise.then(() => process.nextTick(cb), (e) => process.nextTick(cb, e));
        } else {
          process.nextTick(cb);
        }
      } else if (func.length === 2) {
        if (isOnCloseHandler) {
          func(context, cb);
        } else {
          func(this._error, cb);
        }
      } else {
        if (isOnCloseHandler) {
          func(context, cb);
        } else {
          func(this._error, context, cb);
        }
      }
    }
    function encapsulateTwoParam(func, that) {
      return _encapsulateTwoParam.bind(that);
      function _encapsulateTwoParam(context, cb) {
        let res;
        if (func.length === 0) {
          res = func();
          if (res && res.then) {
            res.then(function() {
              process.nextTick(cb);
            }, cb);
          } else {
            process.nextTick(cb);
          }
        } else if (func.length === 1) {
          res = func(this);
          if (res && res.then) {
            res.then(function() {
              process.nextTick(cb);
            }, cb);
          } else {
            process.nextTick(cb);
          }
        } else {
          func(this, cb);
        }
      }
    }
    function encapsulateThreeParam(func, that) {
      return _encapsulateThreeParam.bind(that);
      function _encapsulateThreeParam(err, cb) {
        let res;
        if (!func) {
          process.nextTick(cb);
        } else if (func.length === 0) {
          res = func();
          if (res && res.then) {
            res.then(function() {
              process.nextTick(cb, err);
            }, cb);
          } else {
            process.nextTick(cb, err);
          }
        } else if (func.length === 1) {
          res = func(err);
          if (res && res.then) {
            res.then(function() {
              process.nextTick(cb);
            }, cb);
          } else {
            process.nextTick(cb);
          }
        } else if (func.length === 2) {
          func(err, cb);
        } else {
          func(err, this, cb);
        }
      }
    }
    module2.exports = Boot;
    module2.exports.express = function(app) {
      return Boot(app, {
        expose: {
          use: "load"
        }
      });
    };
  }
});

// packages/platform-fastify/node_modules/fastify/lib/symbols.js
var require_symbols = __commonJS({
  "packages/platform-fastify/node_modules/fastify/lib/symbols.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var keys = {
      kAvvioBoot: Symbol("fastify.avvioBoot"),
      kChildren: Symbol("fastify.children"),
      kBodyLimit: Symbol("fastify.bodyLimit"),
      kRoutePrefix: Symbol("fastify.routePrefix"),
      kLogLevel: Symbol("fastify.logLevel"),
      kLogSerializers: Symbol("fastify.logSerializers"),
      kHooks: Symbol("fastify.hooks"),
      kHooksDeprecatedPreParsing: Symbol("fastify.hooks.DeprecatedPreParsing"),
      kSchemaController: Symbol("fastify.schemaController"),
      kSchemaHeaders: Symbol("headers-schema"),
      kSchemaParams: Symbol("params-schema"),
      kSchemaQuerystring: Symbol("querystring-schema"),
      kSchemaBody: Symbol("body-schema"),
      kSchemaResponse: Symbol("response-schema"),
      kSchemaErrorFormatter: Symbol("fastify.schemaErrorFormatter"),
      kReplySerializerDefault: Symbol("fastify.replySerializerDefault"),
      kContentTypeParser: Symbol("fastify.contentTypeParser"),
      kReply: Symbol("fastify.Reply"),
      kRequest: Symbol("fastify.Request"),
      kRequestPayloadStream: Symbol("fastify.RequestPayloadStream"),
      kRequestAcceptVersion: Symbol("fastify.RequestAcceptVersion"),
      kCanSetNotFoundHandler: Symbol("fastify.canSetNotFoundHandler"),
      kFourOhFour: Symbol("fastify.404"),
      kFourOhFourLevelInstance: Symbol("fastify.404LogLevelInstance"),
      kFourOhFourContext: Symbol("fastify.404ContextKey"),
      kDefaultJsonParse: Symbol("fastify.defaultJSONParse"),
      kReplySerializer: Symbol("fastify.reply.serializer"),
      kReplyIsError: Symbol("fastify.reply.isError"),
      kReplyHeaders: Symbol("fastify.reply.headers"),
      kReplyHasStatusCode: Symbol("fastify.reply.hasStatusCode"),
      kReplySent: Symbol("fastify.reply.sent"),
      kReplySentOverwritten: Symbol("fastify.reply.sentOverwritten"),
      kReplyStartTime: Symbol("fastify.reply.startTime"),
      kReplyEndTime: Symbol("fastify.reply.endTime"),
      kReplyErrorHandlerCalled: Symbol("fastify.reply.errorHandlerCalled"),
      kReplyIsRunningOnErrorHook: Symbol("fastify.reply.isRunningOnErrorHook"),
      kSchemaVisited: Symbol("fastify.schemas.visited"),
      kState: Symbol("fastify.state"),
      kOptions: Symbol("fastify.options"),
      kDisableRequestLogging: Symbol("fastify.disableRequestLogging"),
      kPluginNameChain: Symbol("fastify.pluginNameChain"),
      kTestInternals: Symbol("fastify.testInternals"),
      kErrorHandler: Symbol("fastify.errorHandler"),
      kKeepAliveConnections: Symbol("fastify.keepAliveConnections")
    };
    module2.exports = keys;
  }
});

// packages/platform-fastify/node_modules/fastify-error/index.js
var require_fastify_error = __commonJS({
  "packages/platform-fastify/node_modules/fastify-error/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var { inherits, format } = __require("util");
    function createError(code, message2, statusCode = 500, Base = Error) {
      if (!code)
        throw new Error("Fastify error code must not be empty");
      if (!message2)
        throw new Error("Fastify error message must not be empty");
      code = code.toUpperCase();
      function FastifyError(a, b, c) {
        if (!(this instanceof FastifyError)) {
          return new FastifyError(a, b, c);
        }
        Error.captureStackTrace(this, FastifyError);
        this.name = "FastifyError";
        this.code = code;
        if (a && b && c) {
          this.message = format(message2, a, b, c);
        } else if (a && b) {
          this.message = format(message2, a, b);
        } else if (a) {
          this.message = format(message2, a);
        } else {
          this.message = message2;
        }
        this.statusCode = statusCode || void 0;
      }
      FastifyError.prototype[Symbol.toStringTag] = "Error";
      FastifyError.prototype.toString = function() {
        return `${this.name} [${this.code}]: ${this.message}`;
      };
      inherits(FastifyError, Base);
      return FastifyError;
    }
    module2.exports = createError;
  }
});

// packages/platform-fastify/node_modules/fastify/lib/errors.js
var require_errors = __commonJS({
  "packages/platform-fastify/node_modules/fastify/lib/errors.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var createError = require_fastify_error();
    var codes = {
      FST_ERR_NOT_FOUND: createError("FST_ERR_NOT_FOUND", "Not Found", 404),
      FST_ERR_CTP_ALREADY_PRESENT: createError("FST_ERR_CTP_ALREADY_PRESENT", "Content type parser '%s' already present."),
      FST_ERR_CTP_INVALID_TYPE: createError("FST_ERR_CTP_INVALID_TYPE", "The content type should be a string or a RegExp", 500, TypeError),
      FST_ERR_CTP_EMPTY_TYPE: createError("FST_ERR_CTP_EMPTY_TYPE", "The content type cannot be an empty string", 500, TypeError),
      FST_ERR_CTP_INVALID_HANDLER: createError("FST_ERR_CTP_INVALID_HANDLER", "The content type handler should be a function", 500, TypeError),
      FST_ERR_CTP_INVALID_PARSE_TYPE: createError("FST_ERR_CTP_INVALID_PARSE_TYPE", "The body parser can only parse your data as 'string' or 'buffer', you asked '%s' which is not supported.", 500, TypeError),
      FST_ERR_CTP_BODY_TOO_LARGE: createError("FST_ERR_CTP_BODY_TOO_LARGE", "Request body is too large", 413, RangeError),
      FST_ERR_CTP_INVALID_MEDIA_TYPE: createError("FST_ERR_CTP_INVALID_MEDIA_TYPE", "Unsupported Media Type: %s", 415),
      FST_ERR_CTP_INVALID_CONTENT_LENGTH: createError("FST_ERR_CTP_INVALID_CONTENT_LENGTH", "Request body size did not match Content-Length", 400, RangeError),
      FST_ERR_CTP_EMPTY_JSON_BODY: createError("FST_ERR_CTP_EMPTY_JSON_BODY", "Body cannot be empty when content-type is set to 'application/json'", 400),
      FST_ERR_DEC_ALREADY_PRESENT: createError("FST_ERR_DEC_ALREADY_PRESENT", "The decorator '%s' has already been added!"),
      FST_ERR_DEC_DEPENDENCY_INVALID_TYPE: createError("FST_ERR_DEC_DEPENDENCY_INVALID_TYPE", "The dependencies of decorator '%s' must be of type Array."),
      FST_ERR_DEC_MISSING_DEPENDENCY: createError("FST_ERR_DEC_MISSING_DEPENDENCY", "The decorator is missing dependency '%s'."),
      FST_ERR_DEC_AFTER_START: createError("FST_ERR_DEC_AFTER_START", "The decorator '%s' has been added after start!"),
      FST_ERR_HOOK_INVALID_TYPE: createError("FST_ERR_HOOK_INVALID_TYPE", "The hook name must be a string", 500, TypeError),
      FST_ERR_HOOK_INVALID_HANDLER: createError("FST_ERR_HOOK_INVALID_HANDLER", "The hook callback must be a function", 500, TypeError),
      FST_ERR_MISSING_MIDDLEWARE: createError("FST_ERR_MISSING_MIDDLEWARE", "You must register a plugin for handling middlewares, visit fastify.io/docs/latest/Reference/Middleware/ for more info.", 500),
      FST_ERR_LOG_INVALID_DESTINATION: createError("FST_ERR_LOG_INVALID_DESTINATION", "Cannot specify both logger.stream and logger.file options"),
      FST_ERR_REP_INVALID_PAYLOAD_TYPE: createError("FST_ERR_REP_INVALID_PAYLOAD_TYPE", "Attempted to send payload of invalid type '%s'. Expected a string or Buffer.", 500, TypeError),
      FST_ERR_REP_ALREADY_SENT: createError("FST_ERR_REP_ALREADY_SENT", "Reply was already sent."),
      FST_ERR_REP_SENT_VALUE: createError("FST_ERR_REP_SENT_VALUE", "The only possible value for reply.sent is true."),
      FST_ERR_SEND_INSIDE_ONERR: createError("FST_ERR_SEND_INSIDE_ONERR", "You cannot use `send` inside the `onError` hook"),
      FST_ERR_SEND_UNDEFINED_ERR: createError("FST_ERR_SEND_UNDEFINED_ERR", "Undefined error has occurred"),
      FST_ERR_BAD_STATUS_CODE: createError("FST_ERR_BAD_STATUS_CODE", "Called reply with an invalid status code: %s"),
      FST_ERR_SCH_MISSING_ID: createError("FST_ERR_SCH_MISSING_ID", "Missing schema $id property"),
      FST_ERR_SCH_ALREADY_PRESENT: createError("FST_ERR_SCH_ALREADY_PRESENT", "Schema with id '%s' already declared!"),
      FST_ERR_SCH_DUPLICATE: createError("FST_ERR_SCH_DUPLICATE", "Schema with '%s' already present!"),
      FST_ERR_SCH_VALIDATION_BUILD: createError("FST_ERR_SCH_VALIDATION_BUILD", "Failed building the validation schema for %s: %s, due to error %s"),
      FST_ERR_SCH_SERIALIZATION_BUILD: createError("FST_ERR_SCH_SERIALIZATION_BUILD", "Failed building the serialization schema for %s: %s, due to error %s"),
      FST_ERR_PROMISE_NOT_FULFILLED: createError("FST_ERR_PROMISE_NOT_FULFILLED", "Promise may not be fulfilled with 'undefined' when statusCode is not 204"),
      FST_ERR_HTTP2_INVALID_VERSION: createError("FST_ERR_HTTP2_INVALID_VERSION", "HTTP2 is available only from node >= 8.8.1"),
      FST_ERR_INIT_OPTS_INVALID: createError("FST_ERR_INIT_OPTS_INVALID", "Invalid initialization options: '%s'"),
      FST_ERR_BAD_URL: createError("FST_ERR_BAD_URL", "'%s' is not a valid url component", 400),
      FST_ERR_DEFAULT_ROUTE_INVALID_TYPE: createError("FST_ERR_DEFAULT_ROUTE_INVALID_TYPE", "The defaultRoute type should be a function", 500, TypeError),
      FST_ERR_INVALID_URL: createError("FST_ERR_INVALID_URL", "URL must be a string. Received '%s'", 400),
      FST_ERR_REOPENED_CLOSE_SERVER: createError("FST_ERR_REOPENED_CLOSE_SERVER", "Fastify has already been closed and cannot be reopened"),
      FST_ERR_REOPENED_SERVER: createError("FST_ERR_REOPENED_SERVER", "Fastify is already listening"),
      FST_ERR_PLUGIN_VERSION_MISMATCH: createError("FST_ERR_PLUGIN_VERSION_MISMATCH", "fastify-plugin: %s - expected '%s' fastify version, '%s' is installed")
    };
    module2.exports = codes;
  }
});

// packages/platform-fastify/node_modules/fastify/lib/server.js
var require_server = __commonJS({
  "packages/platform-fastify/node_modules/fastify/lib/server.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var assert = __require("assert");
    var http = __require("http");
    var https = __require("https");
    var { kState, kOptions } = require_symbols();
    var { FST_ERR_HTTP2_INVALID_VERSION, FST_ERR_REOPENED_CLOSE_SERVER, FST_ERR_REOPENED_SERVER } = require_errors();
    function createServer(options, httpHandler) {
      assert(options, "Missing options");
      assert(httpHandler, "Missing http handler");
      let server = null;
      if (options.serverFactory) {
        server = options.serverFactory(httpHandler, options);
      } else if (options.http2) {
        if (options.https) {
          server = http2().createSecureServer(options.https, httpHandler);
        } else {
          server = http2().createServer(httpHandler);
        }
        server.on("session", sessionTimeout(options.http2SessionTimeout));
      } else {
        if (options.https) {
          server = https.createServer(options.https, httpHandler);
        } else {
          server = http.createServer(httpHandler);
        }
        server.keepAliveTimeout = options.keepAliveTimeout;
        server.requestTimeout = options.requestTimeout;
        if (options.maxRequestsPerSocket > 0) {
          server.maxRequestsPerSocket = options.maxRequestsPerSocket;
        }
      }
      if (!options.serverFactory) {
        server.setTimeout(options.connectionTimeout);
      }
      return { server, listen };
      function listen() {
        const normalizeListenArgs = (args2) => {
          if (args2.length === 0) {
            return { port: 0, host: "localhost" };
          }
          const cb2 = typeof args2[args2.length - 1] === "function" ? args2.pop() : void 0;
          const options2 = { cb: cb2 };
          const firstArg = args2[0];
          const argsLength = args2.length;
          const lastArg = args2[argsLength - 1];
          if (typeof firstArg === "object" && firstArg !== null) {
            options2.backlog = argsLength > 1 ? lastArg : void 0;
            Object.assign(options2, firstArg);
          } else if (typeof firstArg === "string" && isNaN(firstArg)) {
            options2.path = firstArg;
            options2.backlog = argsLength > 1 ? lastArg : void 0;
          } else {
            options2.port = argsLength >= 1 && firstArg ? firstArg : 0;
            options2.host = argsLength >= 2 && args2[1] ? args2[1] : "localhost";
            options2.backlog = argsLength >= 3 ? args2[2] : void 0;
          }
          return options2;
        };
        const listenOptions = normalizeListenArgs(Array.from(arguments));
        const cb = listenOptions.cb;
        const wrap2 = (err) => {
          server.removeListener("error", wrap2);
          if (!err) {
            const address = logServerAddress();
            cb(null, address);
          } else {
            this[kState].listening = false;
            cb(err, null);
          }
        };
        const listenPromise = (listenOptions2) => {
          if (this[kState].listening && this[kState].closing) {
            return Promise.reject(new FST_ERR_REOPENED_CLOSE_SERVER());
          } else if (this[kState].listening) {
            return Promise.reject(new FST_ERR_REOPENED_SERVER());
          }
          return this.ready().then(() => {
            let errEventHandler;
            const errEvent = new Promise((resolve, reject2) => {
              errEventHandler = (err) => {
                this[kState].listening = false;
                reject2(err);
              };
              server.once("error", errEventHandler);
            });
            const listen2 = new Promise((resolve, reject2) => {
              server.listen(listenOptions2, () => {
                server.removeListener("error", errEventHandler);
                resolve(logServerAddress());
              });
              this[kState].listening = true;
            });
            return Promise.race([
              errEvent,
              listen2
            ]);
          });
        };
        const logServerAddress = () => {
          let address = server.address();
          const isUnixSocket = typeof address === "string";
          if (!isUnixSocket) {
            if (address.address.indexOf(":") === -1) {
              address = address.address + ":" + address.port;
            } else {
              address = "[" + address.address + "]:" + address.port;
            }
          }
          address = (isUnixSocket ? "" : "http" + (this[kOptions].https ? "s" : "") + "://") + address;
          this.log.info("Server listening at " + address);
          return address;
        };
        if (cb === void 0)
          return listenPromise(listenOptions);
        this.ready((err) => {
          if (err != null)
            return cb(err);
          if (this[kState].listening && this[kState].closing) {
            return cb(new FST_ERR_REOPENED_CLOSE_SERVER(), null);
          } else if (this[kState].listening) {
            return cb(new FST_ERR_REOPENED_SERVER(), null);
          }
          server.once("error", wrap2);
          server.listen(listenOptions, wrap2);
          this[kState].listening = true;
        });
      }
    }
    function http2() {
      try {
        return __require("http2");
      } catch (err) {
        throw new FST_ERR_HTTP2_INVALID_VERSION();
      }
    }
    function sessionTimeout(timeout2) {
      return function(session) {
        session.setTimeout(timeout2, close);
      };
    }
    function close() {
      this.close();
    }
    module2.exports = { createServer };
  }
});

// packages/platform-fastify/node_modules/flatstr/index.js
var require_flatstr = __commonJS({
  "packages/platform-fastify/node_modules/flatstr/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    function flatstr(s2) {
      s2 | 0;
      return s2;
    }
    module2.exports = flatstr;
  }
});

// packages/platform-fastify/node_modules/fastify/lib/hooks.js
var require_hooks = __commonJS({
  "packages/platform-fastify/node_modules/fastify/lib/hooks.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var applicationHooks = [
      "onRoute",
      "onRegister",
      "onReady",
      "onClose"
    ];
    var lifecycleHooks = [
      "onTimeout",
      "onRequest",
      "preParsing",
      "preValidation",
      "preSerialization",
      "preHandler",
      "onSend",
      "onResponse",
      "onError"
    ];
    var supportedHooks = lifecycleHooks.concat(applicationHooks);
    var {
      FST_ERR_HOOK_INVALID_TYPE,
      FST_ERR_HOOK_INVALID_HANDLER,
      FST_ERR_SEND_UNDEFINED_ERR
    } = require_errors();
    var {
      kReplyIsError,
      kChildren,
      kHooks
    } = require_symbols();
    function Hooks() {
      this.onRequest = [];
      this.preParsing = [];
      this.preValidation = [];
      this.preSerialization = [];
      this.preHandler = [];
      this.onResponse = [];
      this.onSend = [];
      this.onError = [];
      this.onRoute = [];
      this.onRegister = [];
      this.onReady = [];
      this.onTimeout = [];
    }
    Hooks.prototype.validate = function(hook, fn2) {
      if (typeof hook !== "string")
        throw new FST_ERR_HOOK_INVALID_TYPE();
      if (typeof fn2 !== "function")
        throw new FST_ERR_HOOK_INVALID_HANDLER();
      if (supportedHooks.indexOf(hook) === -1) {
        throw new Error(`${hook} hook not supported!`);
      }
    };
    Hooks.prototype.add = function(hook, fn2) {
      this.validate(hook, fn2);
      this[hook].push(fn2);
    };
    function buildHooks(h) {
      const hooks = new Hooks();
      hooks.onRequest = h.onRequest.slice();
      hooks.preParsing = h.preParsing.slice();
      hooks.preValidation = h.preValidation.slice();
      hooks.preSerialization = h.preSerialization.slice();
      hooks.preHandler = h.preHandler.slice();
      hooks.onSend = h.onSend.slice();
      hooks.onResponse = h.onResponse.slice();
      hooks.onError = h.onError.slice();
      hooks.onRoute = h.onRoute.slice();
      hooks.onRegister = h.onRegister.slice();
      hooks.onTimeout = h.onTimeout.slice();
      hooks.onReady = [];
      return hooks;
    }
    function hookRunnerApplication(hookName, boot, server, cb) {
      const hooks = server[kHooks][hookName];
      let i = 0;
      let c = 0;
      next();
      function exit(err) {
        if (err) {
          cb(err);
          return;
        }
        cb();
      }
      function next(err) {
        if (err) {
          exit(err);
          return;
        }
        if (i === hooks.length && c === server[kChildren].length) {
          if (i === 0 && c === 0) {
            exit();
          } else {
            boot(function manageTimeout(err2, done) {
              exit(err2);
              done(err2);
            });
          }
          return;
        }
        if (i === hooks.length && c < server[kChildren].length) {
          const child = server[kChildren][c++];
          hookRunnerApplication(hookName, boot, child, next);
          return;
        }
        boot(wrap2(hooks[i++], server));
        next();
      }
      function wrap2(fn2, server2) {
        return function(err, done) {
          if (err) {
            done(err);
            return;
          }
          if (fn2.length === 1) {
            try {
              fn2.call(server2, done);
            } catch (error) {
              done(error);
            }
            return;
          }
          const ret = fn2.call(server2);
          if (ret && typeof ret.then === "function") {
            ret.then(done, done);
            return;
          }
          done(err);
        };
      }
    }
    function hookRunner(functions, runner, request, reply, cb) {
      let i = 0;
      function next(err) {
        if (err || i === functions.length) {
          cb(err, request, reply);
          return;
        }
        let result;
        try {
          result = runner(functions[i++], request, reply, next);
        } catch (error) {
          next(error);
          return;
        }
        if (result && typeof result.then === "function") {
          result.then(handleResolve, handleReject);
        }
      }
      function handleResolve() {
        next();
      }
      function handleReject(err) {
        if (!err) {
          err = new FST_ERR_SEND_UNDEFINED_ERR();
        } else if (!(err instanceof Error)) {
          reply[kReplyIsError] = true;
        }
        cb(err, request, reply);
      }
      next();
    }
    function onSendHookRunner(functions, request, reply, payload, cb) {
      let i = 0;
      function next(err, newPayload) {
        if (err) {
          cb(err, request, reply, payload);
          return;
        }
        if (newPayload !== void 0) {
          payload = newPayload;
        }
        if (i === functions.length) {
          try {
            cb(null, request, reply, payload);
          } catch (err2) {
            handleReject(err2);
          }
          return;
        }
        let result;
        try {
          result = functions[i++](request, reply, payload, next);
        } catch (error) {
          next(error);
          return;
        }
        if (result && typeof result.then === "function") {
          result.then(handleResolve, handleReject);
        }
      }
      function handleResolve(newPayload) {
        next(null, newPayload);
      }
      function handleReject(err) {
        cb(err, request, reply, payload);
      }
      next();
    }
    function hookIterator(fn2, request, reply, next) {
      if (reply.sent === true)
        return void 0;
      return fn2(request, reply, next);
    }
    module2.exports = {
      Hooks,
      buildHooks,
      hookRunner,
      onSendHookRunner,
      hookIterator,
      hookRunnerApplication,
      lifecycleHooks,
      supportedHooks
    };
  }
});

// packages/platform-fastify/node_modules/fastify/lib/validation.js
var require_validation = __commonJS({
  "packages/platform-fastify/node_modules/fastify/lib/validation.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var {
      kSchemaHeaders: headersSchema,
      kSchemaParams: paramsSchema,
      kSchemaQuerystring: querystringSchema,
      kSchemaBody: bodySchema,
      kSchemaResponse: responseSchema
    } = require_symbols();
    function compileSchemasForSerialization(context, compile) {
      if (!context.schema || !context.schema.response) {
        return;
      }
      const { method, url } = context.config || {};
      context[responseSchema] = Object.keys(context.schema.response).reduce(function(acc, statusCode) {
        acc[statusCode] = compile({
          schema: context.schema.response[statusCode],
          url,
          method,
          httpStatus: statusCode
        });
        return acc;
      }, {});
    }
    function compileSchemasForValidation(context, compile) {
      if (!context.schema) {
        return;
      }
      const { method, url } = context.config || {};
      const headers = context.schema.headers;
      if (headers && Object.getPrototypeOf(headers) !== Object.prototype) {
        context[headersSchema] = compile({ schema: headers, method, url, httpPart: "headers" });
      } else if (headers) {
        const headersSchemaLowerCase = {};
        Object.keys(headers).forEach((k) => {
          headersSchemaLowerCase[k] = headers[k];
        });
        if (headersSchemaLowerCase.required instanceof Array) {
          headersSchemaLowerCase.required = headersSchemaLowerCase.required.map((h) => h.toLowerCase());
        }
        if (headers.properties) {
          headersSchemaLowerCase.properties = {};
          Object.keys(headers.properties).forEach((k) => {
            headersSchemaLowerCase.properties[k.toLowerCase()] = headers.properties[k];
          });
        }
        context[headersSchema] = compile({ schema: headersSchemaLowerCase, method, url, httpPart: "headers" });
      }
      if (context.schema.body) {
        context[bodySchema] = compile({ schema: context.schema.body, method, url, httpPart: "body" });
      }
      if (context.schema.querystring) {
        context[querystringSchema] = compile({ schema: context.schema.querystring, method, url, httpPart: "querystring" });
      }
      if (context.schema.params) {
        context[paramsSchema] = compile({ schema: context.schema.params, method, url, httpPart: "params" });
      }
    }
    function validateParam(validatorFunction, request, paramName) {
      const ret = validatorFunction && validatorFunction(request[paramName]);
      if (ret === false)
        return validatorFunction.errors;
      if (ret && ret.error)
        return ret.error;
      if (ret && ret.value)
        request[paramName] = ret.value;
      return false;
    }
    function validate(context, request) {
      const params = validateParam(context[paramsSchema], request, "params");
      if (params) {
        return wrapValidationError(params, "params", context.schemaErrorFormatter);
      }
      const body = validateParam(context[bodySchema], request, "body");
      if (body) {
        return wrapValidationError(body, "body", context.schemaErrorFormatter);
      }
      const query = validateParam(context[querystringSchema], request, "query");
      if (query) {
        return wrapValidationError(query, "querystring", context.schemaErrorFormatter);
      }
      const headers = validateParam(context[headersSchema], request, "headers");
      if (headers) {
        return wrapValidationError(headers, "headers", context.schemaErrorFormatter);
      }
      return null;
    }
    function wrapValidationError(result, dataVar, schemaErrorFormatter) {
      if (result instanceof Error) {
        result.validationContext = result.validationContext || dataVar;
        return result;
      }
      const error = schemaErrorFormatter(result, dataVar);
      error.validation = result;
      error.validationContext = dataVar;
      return error;
    }
    module2.exports = {
      symbols: { bodySchema, querystringSchema, responseSchema, paramsSchema, headersSchema },
      compileSchemasForValidation,
      compileSchemasForSerialization,
      validate
    };
  }
});

// packages/platform-fastify/node_modules/fastify/lib/wrapThenable.js
var require_wrapThenable = __commonJS({
  "packages/platform-fastify/node_modules/fastify/lib/wrapThenable.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var {
      kReplyIsError,
      kReplySent,
      kReplySentOverwritten
    } = require_symbols();
    var { FST_ERR_PROMISE_NOT_FULFILLED } = require_errors();
    function wrapThenable(thenable, reply) {
      thenable.then(function(payload) {
        if (reply[kReplySentOverwritten] === true) {
          return;
        }
        if (payload !== void 0 || reply.raw.statusCode === 204 && reply[kReplySent] === false) {
          try {
            reply.send(payload);
          } catch (err) {
            reply[kReplySent] = false;
            reply[kReplyIsError] = true;
            reply.send(err);
          }
        } else if (reply[kReplySent] === false) {
          reply.log.error({ err: new FST_ERR_PROMISE_NOT_FULFILLED() }, "Promise may not be fulfilled with 'undefined' when statusCode is not 204");
        }
      }, function(err) {
        if (reply[kReplySentOverwritten] === true || reply.sent === true) {
          reply.log.error({ err }, "Promise errored, but reply.sent = true was set");
          return;
        }
        reply[kReplySent] = false;
        reply[kReplyIsError] = true;
        reply.send(err);
      });
    }
    module2.exports = wrapThenable;
  }
});

// packages/platform-fastify/node_modules/fastify/lib/handleRequest.js
var require_handleRequest = __commonJS({
  "packages/platform-fastify/node_modules/fastify/lib/handleRequest.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var { validate: validateSchema } = require_validation();
    var { hookRunner, hookIterator } = require_hooks();
    var wrapThenable = require_wrapThenable();
    var { kReplyIsError } = require_symbols();
    function handleRequest(err, request, reply) {
      if (reply.sent === true)
        return;
      if (err != null) {
        reply.send(err);
        return;
      }
      const method = request.raw.method;
      const headers = request.headers;
      if (method === "GET" || method === "HEAD") {
        handler(request, reply);
        return;
      }
      const contentType = headers["content-type"];
      if (method === "POST" || method === "PUT" || method === "PATCH") {
        if (contentType === void 0) {
          if (headers["transfer-encoding"] === void 0 && (headers["content-length"] === "0" || headers["content-length"] === void 0)) {
            handler(request, reply);
          } else {
            reply.context.contentTypeParser.run("", handler, request, reply);
          }
        } else {
          reply.context.contentTypeParser.run(contentType, handler, request, reply);
        }
        return;
      }
      if (method === "OPTIONS" || method === "DELETE") {
        if (contentType !== void 0 && (headers["transfer-encoding"] !== void 0 || headers["content-length"] !== void 0)) {
          reply.context.contentTypeParser.run(contentType, handler, request, reply);
        } else {
          handler(request, reply);
        }
        return;
      }
      reply.code(404).send(new Error("Not Found"));
    }
    function handler(request, reply) {
      try {
        if (reply.context.preValidation !== null) {
          hookRunner(reply.context.preValidation, hookIterator, request, reply, preValidationCallback);
        } else {
          preValidationCallback(null, request, reply);
        }
      } catch (err) {
        preValidationCallback(err, request, reply);
      }
    }
    function preValidationCallback(err, request, reply) {
      if (reply.sent === true || reply.raw.writableEnded === true || reply.raw.writable === false)
        return;
      if (err != null) {
        reply.send(err);
        return;
      }
      const result = validateSchema(reply.context, request);
      if (result) {
        if (reply.context.attachValidation === false) {
          reply.code(400).send(result);
          return;
        }
        reply.request.validationError = result;
      }
      if (reply.context.preHandler !== null) {
        hookRunner(reply.context.preHandler, hookIterator, request, reply, preHandlerCallback);
      } else {
        preHandlerCallback(null, request, reply);
      }
    }
    function preHandlerCallback(err, request, reply) {
      if (reply.sent || reply.raw.writableEnded === true || reply.raw.writable === false)
        return;
      if (err != null) {
        reply.send(err);
        return;
      }
      let result;
      try {
        result = reply.context.handler(request, reply);
      } catch (err2) {
        if (!(err2 instanceof Error)) {
          reply[kReplyIsError] = true;
        }
        reply.send(err2);
        return;
      }
      if (result !== void 0) {
        if (result !== null && typeof result.then === "function") {
          wrapThenable(result, reply);
        } else {
          reply.send(result);
        }
      }
    }
    module2.exports = handleRequest;
    module2.exports[Symbol.for("internals")] = { handler, preHandlerCallback };
  }
});

// packages/platform-fastify/node_modules/abstract-logging/index.js
var require_abstract_logging = __commonJS({
  "packages/platform-fastify/node_modules/abstract-logging/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    function noop() {
    }
    var proto = {
      fatal: noop,
      error: noop,
      warn: noop,
      info: noop,
      debug: noop,
      trace: noop
    };
    Object.defineProperty(module2, "exports", {
      get() {
        return Object.create(proto);
      }
    });
  }
});

// packages/platform-fastify/node_modules/pino-std-serializers/lib/err.js
var require_err = __commonJS({
  "packages/platform-fastify/node_modules/pino-std-serializers/lib/err.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = errSerializer;
    var { toString } = Object.prototype;
    var seen = Symbol("circular-ref-tag");
    var rawSymbol = Symbol("pino-raw-err-ref");
    var pinoErrProto = Object.create({}, {
      type: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      message: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      stack: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoErrProto, rawSymbol, {
      writable: true,
      value: {}
    });
    function errSerializer(err) {
      if (!(err instanceof Error)) {
        return err;
      }
      err[seen] = void 0;
      const _err = Object.create(pinoErrProto);
      _err.type = toString.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
      _err.message = err.message;
      _err.stack = err.stack;
      for (const key in err) {
        if (_err[key] === void 0) {
          const val = err[key];
          if (val instanceof Error) {
            if (!val.hasOwnProperty(seen)) {
              _err[key] = errSerializer(val);
            }
          } else {
            _err[key] = val;
          }
        }
      }
      delete err[seen];
      _err.raw = err;
      return _err;
    }
  }
});

// packages/platform-fastify/node_modules/pino-std-serializers/lib/req.js
var require_req = __commonJS({
  "packages/platform-fastify/node_modules/pino-std-serializers/lib/req.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = {
      mapHttpRequest,
      reqSerializer
    };
    var rawSymbol = Symbol("pino-raw-req-ref");
    var pinoReqProto = Object.create({}, {
      id: {
        enumerable: true,
        writable: true,
        value: ""
      },
      method: {
        enumerable: true,
        writable: true,
        value: ""
      },
      url: {
        enumerable: true,
        writable: true,
        value: ""
      },
      query: {
        enumerable: true,
        writable: true,
        value: ""
      },
      params: {
        enumerable: true,
        writable: true,
        value: ""
      },
      headers: {
        enumerable: true,
        writable: true,
        value: {}
      },
      remoteAddress: {
        enumerable: true,
        writable: true,
        value: ""
      },
      remotePort: {
        enumerable: true,
        writable: true,
        value: ""
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoReqProto, rawSymbol, {
      writable: true,
      value: {}
    });
    function reqSerializer(req) {
      const connection = req.info || req.socket;
      const _req = Object.create(pinoReqProto);
      _req.id = typeof req.id === "function" ? req.id() : req.id || (req.info ? req.info.id : void 0);
      _req.method = req.method;
      if (req.originalUrl) {
        _req.url = req.originalUrl;
        _req.query = req.query;
        _req.params = req.params;
      } else {
        _req.url = req.path || (req.url ? req.url.path || req.url : void 0);
      }
      _req.headers = req.headers;
      _req.remoteAddress = connection && connection.remoteAddress;
      _req.remotePort = connection && connection.remotePort;
      _req.raw = req.raw || req;
      return _req;
    }
    function mapHttpRequest(req) {
      return {
        req: reqSerializer(req)
      };
    }
  }
});

// packages/platform-fastify/node_modules/pino-std-serializers/lib/res.js
var require_res = __commonJS({
  "packages/platform-fastify/node_modules/pino-std-serializers/lib/res.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = {
      mapHttpResponse,
      resSerializer
    };
    var rawSymbol = Symbol("pino-raw-res-ref");
    var pinoResProto = Object.create({}, {
      statusCode: {
        enumerable: true,
        writable: true,
        value: 0
      },
      headers: {
        enumerable: true,
        writable: true,
        value: ""
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoResProto, rawSymbol, {
      writable: true,
      value: {}
    });
    function resSerializer(res) {
      const _res = Object.create(pinoResProto);
      _res.statusCode = res.statusCode;
      _res.headers = res.getHeaders ? res.getHeaders() : res._headers;
      _res.raw = res;
      return _res;
    }
    function mapHttpResponse(res) {
      return {
        res: resSerializer(res)
      };
    }
  }
});

// packages/platform-fastify/node_modules/pino-std-serializers/index.js
var require_pino_std_serializers = __commonJS({
  "packages/platform-fastify/node_modules/pino-std-serializers/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var errSerializer = require_err();
    var reqSerializers = require_req();
    var resSerializers = require_res();
    module2.exports = {
      err: errSerializer,
      mapHttpRequest: reqSerializers.mapHttpRequest,
      mapHttpResponse: resSerializers.mapHttpResponse,
      req: reqSerializers.reqSerializer,
      res: resSerializers.resSerializer,
      wrapErrorSerializer: function wrapErrorSerializer(customSerializer) {
        if (customSerializer === errSerializer)
          return customSerializer;
        return function wrapErrSerializer(err) {
          return customSerializer(errSerializer(err));
        };
      },
      wrapRequestSerializer: function wrapRequestSerializer(customSerializer) {
        if (customSerializer === reqSerializers.reqSerializer)
          return customSerializer;
        return function wrappedReqSerializer(req) {
          return customSerializer(reqSerializers.reqSerializer(req));
        };
      },
      wrapResponseSerializer: function wrapResponseSerializer(customSerializer) {
        if (customSerializer === resSerializers.resSerializer)
          return customSerializer;
        return function wrappedResSerializer(res) {
          return customSerializer(resSerializers.resSerializer(res));
        };
      }
    };
  }
});

// packages/platform-fastify/node_modules/fast-redact/lib/validator.js
var require_validator = __commonJS({
  "packages/platform-fastify/node_modules/fast-redact/lib/validator.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var { createContext, runInContext } = __require("vm");
    module2.exports = validator;
    function validator(opts = {}) {
      const {
        ERR_PATHS_MUST_BE_STRINGS = () => "fast-redact - Paths must be (non-empty) strings",
        ERR_INVALID_PATH = (s2) => `fast-redact \u2013 Invalid path (${s2})`
      } = opts;
      return function validate({ paths }) {
        paths.forEach((s2) => {
          if (typeof s2 !== "string") {
            throw Error(ERR_PATHS_MUST_BE_STRINGS());
          }
          try {
            if (/〇/.test(s2))
              throw Error();
            const proxy = new Proxy({}, { get: () => proxy, set: () => {
              throw Error();
            } });
            const expr = (s2[0] === "[" ? "" : ".") + s2.replace(/^\*/, "\u3007").replace(/\.\*/g, ".\u3007").replace(/\[\*\]/g, "[\u3007]");
            if (/\n|\r|;/.test(expr))
              throw Error();
            if (/\/\*/.test(expr))
              throw Error();
            runInContext(`
          (function () {
            'use strict'
            o${expr}
            if ([o${expr}].length !== 1) throw Error()
          })()
        `, createContext({ o: proxy, "\u3007": null }), {
              codeGeneration: { strings: false, wasm: false }
            });
          } catch (e) {
            throw Error(ERR_INVALID_PATH(s2));
          }
        });
      };
    }
  }
});

// packages/platform-fastify/node_modules/fast-redact/lib/rx.js
var require_rx = __commonJS({
  "packages/platform-fastify/node_modules/fast-redact/lib/rx.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = /[^.[\]]+|\[((?:.)*?)\]/g;
  }
});

// packages/platform-fastify/node_modules/fast-redact/lib/parse.js
var require_parse = __commonJS({
  "packages/platform-fastify/node_modules/fast-redact/lib/parse.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var rx = require_rx();
    module2.exports = parse;
    function parse({ paths }) {
      const wildcards = [];
      var wcLen = 0;
      const secret = paths.reduce(function(o, strPath, ix) {
        var path2 = strPath.match(rx).map((p) => p.replace(/'|"|`/g, ""));
        const leadingBracket = strPath[0] === "[";
        path2 = path2.map((p) => {
          if (p[0] === "[")
            return p.substr(1, p.length - 2);
          else
            return p;
        });
        const star = path2.indexOf("*");
        if (star > -1) {
          const before = path2.slice(0, star);
          const beforeStr = before.join(".");
          const after = path2.slice(star + 1, path2.length);
          const nested = after.length > 0;
          wcLen++;
          wildcards.push({
            before,
            beforeStr,
            after,
            nested
          });
        } else {
          o[strPath] = {
            path: path2,
            val: void 0,
            precensored: false,
            circle: "",
            escPath: JSON.stringify(strPath),
            leadingBracket
          };
        }
        return o;
      }, {});
      return { wildcards, wcLen, secret };
    }
  }
});

// packages/platform-fastify/node_modules/fast-redact/lib/redactor.js
var require_redactor = __commonJS({
  "packages/platform-fastify/node_modules/fast-redact/lib/redactor.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var rx = require_rx();
    module2.exports = redactor;
    function redactor({ secret, serialize, wcLen, strict, isCensorFct, censorFctTakesPath }, state) {
      const redact = Function("o", `
    if (typeof o !== 'object' || o == null) {
      ${strictImpl(strict, serialize)}
    }
    const { censor, secret } = this
    ${redactTmpl(secret, isCensorFct, censorFctTakesPath)}
    this.compileRestore()
    ${dynamicRedactTmpl(wcLen > 0, isCensorFct, censorFctTakesPath)}
    ${resultTmpl(serialize)}
  `).bind(state);
      if (serialize === false) {
        redact.restore = (o) => state.restore(o);
      }
      return redact;
    }
    function redactTmpl(secret, isCensorFct, censorFctTakesPath) {
      return Object.keys(secret).map((path2) => {
        const { escPath, leadingBracket, path: arrPath } = secret[path2];
        const skip = leadingBracket ? 1 : 0;
        const delim = leadingBracket ? "" : ".";
        const hops = [];
        var match;
        while ((match = rx.exec(path2)) !== null) {
          const [, ix] = match;
          const { index: index2, input } = match;
          if (index2 > skip)
            hops.push(input.substring(0, index2 - (ix ? 0 : 1)));
        }
        var existence = hops.map((p) => `o${delim}${p}`).join(" && ");
        if (existence.length === 0)
          existence += `o${delim}${path2} != null`;
        else
          existence += ` && o${delim}${path2} != null`;
        const circularDetection = `
      switch (true) {
        ${hops.reverse().map((p) => `
          case o${delim}${p} === censor:
            secret[${escPath}].circle = ${JSON.stringify(p)}
            break
        `).join("\n")}
      }
    `;
        const censorArgs = censorFctTakesPath ? `val, ${JSON.stringify(arrPath)}` : `val`;
        return `
      if (${existence}) {
        const val = o${delim}${path2}
        if (val === censor) {
          secret[${escPath}].precensored = true
        } else {
          secret[${escPath}].val = val
          o${delim}${path2} = ${isCensorFct ? `censor(${censorArgs})` : "censor"}
          ${circularDetection}
        }
      }
    `;
      }).join("\n");
    }
    function dynamicRedactTmpl(hasWildcards, isCensorFct, censorFctTakesPath) {
      return hasWildcards === true ? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${isCensorFct}, ${censorFctTakesPath})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${isCensorFct}, ${censorFctTakesPath})
      }
    }
  ` : "";
    }
    function resultTmpl(serialize) {
      return serialize === false ? `return o` : `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `;
    }
    function strictImpl(strict, serialize) {
      return strict === true ? `throw Error('fast-redact: primitives cannot be redacted')` : serialize === false ? `return o` : `return this.serialize(o)`;
    }
  }
});

// packages/platform-fastify/node_modules/fast-redact/lib/modifiers.js
var require_modifiers = __commonJS({
  "packages/platform-fastify/node_modules/fast-redact/lib/modifiers.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = {
      groupRedact,
      groupRestore,
      nestedRedact,
      nestedRestore
    };
    function groupRestore({ keys, values, target }) {
      if (target == null)
        return;
      const length = keys.length;
      for (var i = 0; i < length; i++) {
        const k = keys[i];
        target[k] = values[i];
      }
    }
    function groupRedact(o, path2, censor, isCensorFct, censorFctTakesPath) {
      const target = get(o, path2);
      if (target == null)
        return { keys: null, values: null, target: null, flat: true };
      const keys = Object.keys(target);
      const keysLength = keys.length;
      const pathLength = path2.length;
      const pathWithKey = censorFctTakesPath ? [...path2] : void 0;
      const values = new Array(keysLength);
      for (var i = 0; i < keysLength; i++) {
        const key = keys[i];
        values[i] = target[key];
        if (censorFctTakesPath) {
          pathWithKey[pathLength] = key;
          target[key] = censor(target[key], pathWithKey);
        } else if (isCensorFct) {
          target[key] = censor(target[key]);
        } else {
          target[key] = censor;
        }
      }
      return { keys, values, target, flat: true };
    }
    function nestedRestore(arr) {
      const length = arr.length;
      for (var i = 0; i < length; i++) {
        const { key, target, value } = arr[i];
        if (has(target, key)) {
          target[key] = value;
        }
        if (typeof target === "object") {
          const targetKeys = Object.keys(target);
          for (var j = 0; j < targetKeys.length; j++) {
            const tKey = targetKeys[j];
            const subTarget = target[tKey];
            if (has(subTarget, key)) {
              subTarget[key] = value;
            }
          }
        }
      }
    }
    function nestedRedact(store, o, path2, ns, censor, isCensorFct, censorFctTakesPath) {
      const target = get(o, path2);
      if (target == null)
        return;
      const keys = Object.keys(target);
      const keysLength = keys.length;
      for (var i = 0; i < keysLength; i++) {
        const key = keys[i];
        const { value, parent: parent2, exists } = specialSet(target, key, path2, ns, censor, isCensorFct, censorFctTakesPath);
        if (exists === true && parent2 !== null) {
          store.push({ key: ns[ns.length - 1], target: parent2, value });
        }
      }
      return store;
    }
    function has(obj, prop) {
      return obj !== void 0 && obj !== null ? "hasOwn" in Object ? Object.hasOwn(obj, prop) : Object.prototype.hasOwnProperty.call(obj, prop) : false;
    }
    function specialSet(o, k, path2, afterPath, censor, isCensorFct, censorFctTakesPath) {
      const afterPathLen = afterPath.length;
      const lastPathIndex = afterPathLen - 1;
      const originalKey = k;
      var i = -1;
      var n;
      var nv;
      var ov;
      var oov = null;
      var exists = true;
      var wc = null;
      ov = n = o[k];
      if (typeof n !== "object")
        return { value: null, parent: null, exists };
      while (n != null && ++i < afterPathLen) {
        k = afterPath[i];
        oov = ov;
        if (k !== "*" && !wc && !(typeof n === "object" && k in n)) {
          exists = false;
          break;
        }
        if (k === "*") {
          wc = k;
          if (i !== lastPathIndex) {
            continue;
          }
        }
        if (wc) {
          const wcKeys = Object.keys(n);
          for (var j = 0; j < wcKeys.length; j++) {
            const wck = wcKeys[j];
            const wcov = n[wck];
            const kIsWc = k === "*";
            if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
              if (kIsWc) {
                ov = wcov;
              } else {
                ov = wcov[k];
              }
              nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path2, originalKey, ...afterPath]) : censor(ov) : censor;
              if (kIsWc) {
                n[wck] = nv;
              } else {
                wcov[k] = nv === void 0 && censor !== void 0 || has(wcov, k) && nv === ov ? wcov[k] : nv;
              }
            }
          }
          wc = null;
        } else {
          ov = n[k];
          nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path2, originalKey, ...afterPath]) : censor(ov) : censor;
          n[k] = has(n, k) && nv === ov || nv === void 0 && censor !== void 0 ? n[k] : nv;
          n = n[k];
        }
        if (typeof n !== "object")
          break;
      }
      return { value: ov, parent: oov, exists };
    }
    function get(o, p) {
      var i = -1;
      var l = p.length;
      var n = o;
      while (n != null && ++i < l) {
        n = n[p[i]];
      }
      return n;
    }
  }
});

// packages/platform-fastify/node_modules/fast-redact/lib/restorer.js
var require_restorer = __commonJS({
  "packages/platform-fastify/node_modules/fast-redact/lib/restorer.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var { groupRestore, nestedRestore } = require_modifiers();
    module2.exports = restorer;
    function restorer({ secret, wcLen }) {
      return function compileRestore() {
        if (this.restore)
          return;
        const paths = Object.keys(secret);
        const resetters = resetTmpl(secret, paths);
        const hasWildcards = wcLen > 0;
        const state = hasWildcards ? { secret, groupRestore, nestedRestore } : { secret };
        this.restore = Function("o", restoreTmpl(resetters, paths, hasWildcards)).bind(state);
      };
    }
    function resetTmpl(secret, paths) {
      return paths.map((path2) => {
        const { circle, escPath, leadingBracket } = secret[path2];
        const delim = leadingBracket ? "" : ".";
        const reset = circle ? `o.${circle} = secret[${escPath}].val` : `o${delim}${path2} = secret[${escPath}].val`;
        const clear = `secret[${escPath}].val = undefined`;
        return `
      if (secret[${escPath}].val !== undefined) {
        try { ${reset} } catch (e) {}
        ${clear}
      }
    `;
      }).join("");
    }
    function restoreTmpl(resetters, paths, hasWildcards) {
      const dynamicReset = hasWildcards === true ? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = len - 1; i >= ${paths.length}; i--) {
      const k = keys[i]
      const o = secret[k]
      if (o.flat === true) this.groupRestore(o)
      else this.nestedRestore(o)
      secret[k] = null
    }
  ` : "";
      return `
    const secret = this.secret
    ${dynamicReset}
    ${resetters}
    return o
  `;
    }
  }
});

// packages/platform-fastify/node_modules/fast-redact/lib/state.js
var require_state = __commonJS({
  "packages/platform-fastify/node_modules/fast-redact/lib/state.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = state;
    function state(o) {
      const {
        secret,
        censor,
        compileRestore,
        serialize,
        groupRedact,
        nestedRedact,
        wildcards,
        wcLen
      } = o;
      const builder = [{ secret, censor, compileRestore }];
      if (serialize !== false)
        builder.push({ serialize });
      if (wcLen > 0)
        builder.push({ groupRedact, nestedRedact, wildcards, wcLen });
      return Object.assign(...builder);
    }
  }
});

// packages/platform-fastify/node_modules/fast-redact/index.js
var require_fast_redact = __commonJS({
  "packages/platform-fastify/node_modules/fast-redact/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var validator = require_validator();
    var parse = require_parse();
    var redactor = require_redactor();
    var restorer = require_restorer();
    var { groupRedact, nestedRedact } = require_modifiers();
    var state = require_state();
    var rx = require_rx();
    var validate = validator();
    var noop = (o) => o;
    noop.restore = noop;
    var DEFAULT_CENSOR = "[REDACTED]";
    fastRedact.rx = rx;
    fastRedact.validator = validator;
    module2.exports = fastRedact;
    function fastRedact(opts = {}) {
      const paths = Array.from(new Set(opts.paths || []));
      const serialize = "serialize" in opts ? opts.serialize === false ? opts.serialize : typeof opts.serialize === "function" ? opts.serialize : JSON.stringify : JSON.stringify;
      const remove = opts.remove;
      if (remove === true && serialize !== JSON.stringify) {
        throw Error("fast-redact \u2013 remove option may only be set when serializer is JSON.stringify");
      }
      const censor = remove === true ? void 0 : "censor" in opts ? opts.censor : DEFAULT_CENSOR;
      const isCensorFct = typeof censor === "function";
      const censorFctTakesPath = isCensorFct && censor.length > 1;
      if (paths.length === 0)
        return serialize || noop;
      validate({ paths, serialize, censor });
      const { wildcards, wcLen, secret } = parse({ paths, censor });
      const compileRestore = restorer({ secret, wcLen });
      const strict = "strict" in opts ? opts.strict : true;
      return redactor({ secret, wcLen, serialize, strict, isCensorFct, censorFctTakesPath }, state({
        secret,
        censor,
        compileRestore,
        serialize,
        groupRedact,
        nestedRedact,
        wildcards,
        wcLen
      }));
    }
  }
});

// packages/platform-fastify/node_modules/pino/lib/symbols.js
var require_symbols2 = __commonJS({
  "packages/platform-fastify/node_modules/pino/lib/symbols.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var setLevelSym = Symbol("pino.setLevel");
    var getLevelSym = Symbol("pino.getLevel");
    var levelValSym = Symbol("pino.levelVal");
    var useLevelLabelsSym = Symbol("pino.useLevelLabels");
    var useOnlyCustomLevelsSym = Symbol("pino.useOnlyCustomLevels");
    var mixinSym = Symbol("pino.mixin");
    var lsCacheSym = Symbol("pino.lsCache");
    var chindingsSym = Symbol("pino.chindings");
    var parsedChindingsSym = Symbol("pino.parsedChindings");
    var asJsonSym = Symbol("pino.asJson");
    var writeSym = Symbol("pino.write");
    var redactFmtSym = Symbol("pino.redactFmt");
    var timeSym = Symbol("pino.time");
    var timeSliceIndexSym = Symbol("pino.timeSliceIndex");
    var streamSym = Symbol("pino.stream");
    var stringifySym = Symbol("pino.stringify");
    var stringifiersSym = Symbol("pino.stringifiers");
    var endSym = Symbol("pino.end");
    var formatOptsSym = Symbol("pino.formatOpts");
    var messageKeySym = Symbol("pino.messageKey");
    var nestedKeySym = Symbol("pino.nestedKey");
    var mixinMergeStrategySym = Symbol("pino.mixinMergeStrategy");
    var wildcardFirstSym = Symbol("pino.wildcardFirst");
    var serializersSym = Symbol.for("pino.serializers");
    var formattersSym = Symbol.for("pino.formatters");
    var hooksSym = Symbol.for("pino.hooks");
    var needsMetadataGsym = Symbol.for("pino.metadata");
    module2.exports = {
      setLevelSym,
      getLevelSym,
      levelValSym,
      useLevelLabelsSym,
      mixinSym,
      lsCacheSym,
      chindingsSym,
      parsedChindingsSym,
      asJsonSym,
      writeSym,
      serializersSym,
      redactFmtSym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      stringifySym,
      stringifiersSym,
      endSym,
      formatOptsSym,
      messageKeySym,
      nestedKeySym,
      wildcardFirstSym,
      needsMetadataGsym,
      useOnlyCustomLevelsSym,
      formattersSym,
      hooksSym,
      mixinMergeStrategySym
    };
  }
});

// packages/platform-fastify/node_modules/pino/lib/redaction.js
var require_redaction = __commonJS({
  "packages/platform-fastify/node_modules/pino/lib/redaction.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var fastRedact = require_fast_redact();
    var { redactFmtSym, wildcardFirstSym } = require_symbols2();
    var { rx, validator } = fastRedact;
    var validate = validator({
      ERR_PATHS_MUST_BE_STRINGS: () => "pino \u2013 redacted paths must be strings",
      ERR_INVALID_PATH: (s2) => `pino \u2013 redact paths array contains an invalid path (${s2})`
    });
    var CENSOR = "[Redacted]";
    var strict = false;
    function redaction(opts, serialize) {
      const { paths, censor } = handle(opts);
      const shape = paths.reduce((o, str) => {
        rx.lastIndex = 0;
        const first = rx.exec(str);
        const next = rx.exec(str);
        let ns = first[1] !== void 0 ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : first[0];
        if (ns === "*") {
          ns = wildcardFirstSym;
        }
        if (next === null) {
          o[ns] = null;
          return o;
        }
        if (o[ns] === null) {
          return o;
        }
        const { index: index2 } = next;
        const nextPath = `${str.substr(index2, str.length - 1)}`;
        o[ns] = o[ns] || [];
        if (ns !== wildcardFirstSym && o[ns].length === 0) {
          o[ns].push(...o[wildcardFirstSym] || []);
        }
        if (ns === wildcardFirstSym) {
          Object.keys(o).forEach(function(k) {
            if (o[k]) {
              o[k].push(nextPath);
            }
          });
        }
        o[ns].push(nextPath);
        return o;
      }, {});
      const result = {
        [redactFmtSym]: fastRedact({ paths, censor, serialize, strict })
      };
      const topCensor = (...args2) => {
        return typeof censor === "function" ? serialize(censor(...args2)) : serialize(censor);
      };
      return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o, k) => {
        if (shape[k] === null) {
          o[k] = (value) => topCensor(value, [k]);
        } else {
          const wrappedCensor = typeof censor === "function" ? (value, path2) => {
            return censor(value, [k, ...path2]);
          } : censor;
          o[k] = fastRedact({
            paths: shape[k],
            censor: wrappedCensor,
            serialize,
            strict
          });
        }
        return o;
      }, result);
    }
    function handle(opts) {
      if (Array.isArray(opts)) {
        opts = { paths: opts, censor: CENSOR };
        validate(opts);
        return opts;
      }
      let { paths, censor = CENSOR, remove } = opts;
      if (Array.isArray(paths) === false) {
        throw Error("pino \u2013 redact must contain an array of strings");
      }
      if (remove === true)
        censor = void 0;
      validate({ paths, censor });
      return { paths, censor };
    }
    module2.exports = redaction;
  }
});

// packages/platform-fastify/node_modules/pino/lib/time.js
var require_time = __commonJS({
  "packages/platform-fastify/node_modules/pino/lib/time.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var nullTime = () => "";
    var epochTime = () => `,"time":${Date.now()}`;
    var unixTime = () => `,"time":${Math.round(Date.now() / 1e3)}`;
    var isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`;
    module2.exports = { nullTime, epochTime, unixTime, isoTime };
  }
});

// packages/platform-fastify/node_modules/atomic-sleep/index.js
var require_atomic_sleep = __commonJS({
  "packages/platform-fastify/node_modules/atomic-sleep/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    if (typeof SharedArrayBuffer !== "undefined" && typeof Atomics !== "undefined") {
      let sleep = function(ms) {
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
          if (typeof ms !== "number" && typeof ms !== "bigint") {
            throw TypeError("sleep: ms must be a number");
          }
          throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
        }
        Atomics.wait(nil, 0, 0, Number(ms));
      };
      const nil = new Int32Array(new SharedArrayBuffer(4));
      module2.exports = sleep;
    } else {
      let sleep = function(ms) {
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
          if (typeof ms !== "number" && typeof ms !== "bigint") {
            throw TypeError("sleep: ms must be a number");
          }
          throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
        }
        const target = Date.now() + Number(ms);
        while (target > Date.now()) {
        }
      };
      module2.exports = sleep;
    }
  }
});

// packages/platform-fastify/node_modules/sonic-boom/index.js
var require_sonic_boom = __commonJS({
  "packages/platform-fastify/node_modules/sonic-boom/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var fs = __require("fs");
    var EventEmitter = __require("events");
    var flatstr = require_flatstr();
    var inherits = __require("util").inherits;
    var BUSY_WRITE_TIMEOUT = 100;
    var sleep = require_atomic_sleep();
    var MAX_WRITE = 16 * 1024 * 1024;
    function openFile(file, sonic) {
      sonic._opening = true;
      sonic._writing = true;
      sonic._asyncDrainScheduled = false;
      function fileOpened(err, fd) {
        if (err) {
          sonic._reopening = false;
          sonic._writing = false;
          sonic._opening = false;
          if (sonic.sync) {
            process.nextTick(() => {
              if (sonic.listenerCount("error") > 0) {
                sonic.emit("error", err);
              }
            });
          } else {
            sonic.emit("error", err);
          }
          return;
        }
        sonic.fd = fd;
        sonic.file = file;
        sonic._reopening = false;
        sonic._opening = false;
        sonic._writing = false;
        if (sonic.sync) {
          process.nextTick(() => sonic.emit("ready"));
        } else {
          sonic.emit("ready");
        }
        if (sonic._reopening) {
          return;
        }
        const len = sonic._buf.length;
        if (len > 0 && len > sonic.minLength && !sonic.destroyed) {
          actualWrite(sonic);
        }
      }
      if (sonic.sync) {
        try {
          const fd = fs.openSync(file, "a");
          fileOpened(null, fd);
        } catch (err) {
          fileOpened(err);
          throw err;
        }
      } else {
        fs.open(file, "a", fileOpened);
      }
    }
    function SonicBoom(opts) {
      if (!(this instanceof SonicBoom)) {
        return new SonicBoom(opts);
      }
      let { fd, dest, minLength, sync } = opts || {};
      fd = fd || dest;
      this._buf = "";
      this.fd = -1;
      this._writing = false;
      this._writingBuf = "";
      this._ending = false;
      this._reopening = false;
      this._asyncDrainScheduled = false;
      this.file = null;
      this.destroyed = false;
      this.sync = sync || false;
      this.minLength = minLength || 0;
      if (typeof fd === "number") {
        this.fd = fd;
        process.nextTick(() => this.emit("ready"));
      } else if (typeof fd === "string") {
        openFile(fd, this);
      } else {
        throw new Error("SonicBoom supports only file descriptors and files");
      }
      this.release = (err, n) => {
        if (err) {
          if (err.code === "EAGAIN") {
            if (this.sync) {
              try {
                sleep(BUSY_WRITE_TIMEOUT);
                this.release(void 0, 0);
              } catch (err2) {
                this.release(err2);
              }
            } else {
              setTimeout(() => {
                fs.write(this.fd, this._writingBuf, "utf8", this.release);
              }, BUSY_WRITE_TIMEOUT);
            }
          } else {
            this._buf = this._writingBuf + this._buf;
            this._writingBuf = "";
            this._writing = false;
            this.emit("error", err);
          }
          return;
        }
        if (this._writingBuf.length !== n) {
          this._writingBuf = this._writingBuf.slice(n);
          if (this.sync) {
            try {
              do {
                n = fs.writeSync(this.fd, this._writingBuf, "utf8");
                this._writingBuf = this._writingBuf.slice(n);
              } while (this._writingBuf.length !== 0);
            } catch (err2) {
              this.release(err2);
              return;
            }
          } else {
            fs.write(this.fd, this._writingBuf, "utf8", this.release);
            return;
          }
        }
        this._writingBuf = "";
        if (this.destroyed) {
          return;
        }
        const len = this._buf.length;
        if (this._reopening) {
          this._writing = false;
          this._reopening = false;
          this.reopen();
        } else if (len > 0 && len > this.minLength) {
          actualWrite(this);
        } else if (this._ending) {
          if (len > 0) {
            actualWrite(this);
          } else {
            this._writing = false;
            actualClose(this);
          }
        } else {
          this._writing = false;
          if (this.sync) {
            if (!this._asyncDrainScheduled) {
              this._asyncDrainScheduled = true;
              process.nextTick(emitDrain, this);
            }
          } else {
            this.emit("drain");
          }
        }
      };
      this.on("newListener", function(name) {
        if (name === "drain") {
          this._asyncDrainScheduled = false;
        }
      });
    }
    function emitDrain(sonic) {
      const hasListeners = sonic.listenerCount("drain") > 0;
      if (!hasListeners)
        return;
      sonic._asyncDrainScheduled = false;
      sonic.emit("drain");
    }
    inherits(SonicBoom, EventEmitter);
    SonicBoom.prototype.write = function(data) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      this._buf += data;
      const len = this._buf.length;
      if (!this._writing && len > this.minLength) {
        actualWrite(this);
      }
      return len < 16384;
    };
    SonicBoom.prototype.flush = function() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._writing || this.minLength <= 0) {
        return;
      }
      actualWrite(this);
    };
    SonicBoom.prototype.reopen = function(file) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._opening) {
        this.once("ready", () => {
          this.reopen(file);
        });
        return;
      }
      if (this._ending) {
        return;
      }
      if (!this.file) {
        throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
      }
      this._reopening = true;
      if (this._writing) {
        return;
      }
      const fd = this.fd;
      this.once("ready", () => {
        if (fd !== this.fd) {
          fs.close(fd, (err) => {
            if (err) {
              return this.emit("error", err);
            }
          });
        }
      });
      openFile(file || this.file, this);
    };
    SonicBoom.prototype.end = function() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._opening) {
        this.once("ready", () => {
          this.end();
        });
        return;
      }
      if (this._ending) {
        return;
      }
      this._ending = true;
      if (!this._writing && this._buf.length > 0 && this.fd >= 0) {
        actualWrite(this);
        return;
      }
      if (this._writing) {
        return;
      }
      actualClose(this);
    };
    SonicBoom.prototype.flushSync = function() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this.fd < 0) {
        throw new Error("sonic boom is not ready yet");
      }
      while (this._buf.length > 0) {
        try {
          fs.writeSync(this.fd, this._buf, "utf8");
          this._buf = "";
        } catch (err) {
          if (err.code !== "EAGAIN") {
            throw err;
          }
          sleep(BUSY_WRITE_TIMEOUT);
        }
      }
    };
    SonicBoom.prototype.destroy = function() {
      if (this.destroyed) {
        return;
      }
      actualClose(this);
    };
    function actualWrite(sonic) {
      sonic._writing = true;
      let buf = sonic._buf;
      const release = sonic.release;
      if (buf.length > MAX_WRITE) {
        buf = buf.slice(0, MAX_WRITE);
        sonic._buf = sonic._buf.slice(MAX_WRITE);
      } else {
        sonic._buf = "";
      }
      flatstr(buf);
      sonic._writingBuf = buf;
      if (sonic.sync) {
        try {
          const written = fs.writeSync(sonic.fd, buf, "utf8");
          release(null, written);
        } catch (err) {
          release(err);
        }
      } else {
        fs.write(sonic.fd, buf, "utf8", release);
      }
    }
    function actualClose(sonic) {
      if (sonic.fd === -1) {
        sonic.once("ready", actualClose.bind(null, sonic));
        return;
      }
      fs.close(sonic.fd, (err) => {
        if (err) {
          sonic.emit("error", err);
          return;
        }
        if (sonic._ending && !sonic._writing) {
          sonic.emit("finish");
        }
        sonic.emit("close");
      });
      sonic.destroyed = true;
      sonic._buf = "";
    }
    module2.exports = SonicBoom;
  }
});

// packages/platform-fastify/node_modules/process-warning/index.js
var require_process_warning = __commonJS({
  "packages/platform-fastify/node_modules/process-warning/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var { format } = __require("util");
    function build() {
      const codes = {};
      const emitted = /* @__PURE__ */ new Map();
      function create(name, code, message2) {
        if (!name)
          throw new Error("Warning name must not be empty");
        if (!code)
          throw new Error("Warning code must not be empty");
        if (!message2)
          throw new Error("Warning message must not be empty");
        code = code.toUpperCase();
        if (codes[code] !== void 0) {
          throw new Error(`The code '${code}' already exist`);
        }
        function buildWarnOpts(a, b, c) {
          let formatted;
          if (a && b && c) {
            formatted = format(message2, a, b, c);
          } else if (a && b) {
            formatted = format(message2, a, b);
          } else if (a) {
            formatted = format(message2, a);
          } else {
            formatted = message2;
          }
          return {
            code,
            name,
            message: formatted
          };
        }
        emitted.set(code, false);
        codes[code] = buildWarnOpts;
        return codes[code];
      }
      function emit(code, a, b, c) {
        if (codes[code] === void 0)
          throw new Error(`The code '${code}' does not exist`);
        if (emitted.get(code) === true)
          return;
        emitted.set(code, true);
        const warning = codes[code](a, b, c);
        process.emitWarning(warning.message, warning.name, warning.code);
      }
      return {
        create,
        emit,
        emitted
      };
    }
    module2.exports = build;
  }
});

// packages/platform-fastify/node_modules/pino/lib/deprecations.js
var require_deprecations = __commonJS({
  "packages/platform-fastify/node_modules/pino/lib/deprecations.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var warning = require_process_warning()();
    module2.exports = warning;
    var warnName = "PinoWarning";
    warning.create(warnName, "PINODEP004", "bindings.serializers is deprecated, use options.serializers option instead");
    warning.create(warnName, "PINODEP005", "bindings.formatters is deprecated, use options.formatters option instead");
    warning.create(warnName, "PINODEP006", "bindings.customLevels is deprecated, use options.customLevels option instead");
    warning.create(warnName, "PINODEP007", "bindings.level is deprecated, use options.level option instead");
  }
});

// packages/platform-fastify/node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "packages/platform-fastify/node_modules/quick-format-unescaped/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    function tryStringify(o) {
      try {
        return JSON.stringify(o);
      } catch (e) {
        return '"[Circular]"';
      }
    }
    module2.exports = format;
    function format(f, args2, opts) {
      var ss = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f === "object" && f !== null) {
        var len = args2.length + offset;
        if (len === 1)
          return f;
        var objects = new Array(len);
        objects[0] = ss(f);
        for (var index2 = 1; index2 < len; index2++) {
          objects[index2] = ss(args2[index2]);
        }
        return objects.join(" ");
      }
      if (typeof f !== "string") {
        return f;
      }
      var argLen = args2.length;
      if (argLen === 0)
        return f;
      var str = "";
      var a = 1 - offset;
      var lastPos = -1;
      var flen = f && f.length || 0;
      for (var i = 0; i < flen; ) {
        if (f.charCodeAt(i) === 37 && i + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f.charCodeAt(i + 1)) {
            case 100:
            case 102:
              if (a >= argLen)
                break;
              if (args2[a] == null)
                break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += Number(args2[a]);
              lastPos = i + 2;
              i++;
              break;
            case 105:
              if (a >= argLen)
                break;
              if (args2[a] == null)
                break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += Math.floor(Number(args2[a]));
              lastPos = i + 2;
              i++;
              break;
            case 79:
            case 111:
            case 106:
              if (a >= argLen)
                break;
              if (args2[a] === void 0)
                break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              var type = typeof args2[a];
              if (type === "string") {
                str += "'" + args2[a] + "'";
                lastPos = i + 2;
                i++;
                break;
              }
              if (type === "function") {
                str += args2[a].name || "<anonymous>";
                lastPos = i + 2;
                i++;
                break;
              }
              str += ss(args2[a]);
              lastPos = i + 2;
              i++;
              break;
            case 115:
              if (a >= argLen)
                break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += String(args2[a]);
              lastPos = i + 2;
              i++;
              break;
            case 37:
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += "%";
              lastPos = i + 2;
              i++;
              a--;
              break;
          }
          ++a;
        }
        ++i;
      }
      if (lastPos === -1)
        return f;
      else if (lastPos < flen) {
        str += f.slice(lastPos);
      }
      return str;
    }
  }
});

// packages/platform-fastify/node_modules/pino/lib/tools.js
var require_tools = __commonJS({
  "packages/platform-fastify/node_modules/pino/lib/tools.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var format = require_quick_format_unescaped();
    var { mapHttpRequest, mapHttpResponse } = require_pino_std_serializers();
    var SonicBoom = require_sonic_boom();
    var stringifySafe = __require("fast-safe-stringify");
    var {
      lsCacheSym,
      chindingsSym,
      parsedChindingsSym,
      writeSym,
      serializersSym,
      formatOptsSym,
      endSym,
      stringifiersSym,
      stringifySym,
      wildcardFirstSym,
      needsMetadataGsym,
      redactFmtSym,
      streamSym,
      nestedKeySym,
      formattersSym,
      messageKeySym
    } = require_symbols2();
    function noop() {
    }
    function genLog(level, hook) {
      if (!hook)
        return LOG;
      return function hookWrappedLog(...args2) {
        hook.call(this, args2, LOG, level);
      };
      function LOG(o, ...n) {
        if (typeof o === "object") {
          let msg = o;
          if (o !== null) {
            if (o.method && o.headers && o.socket) {
              o = mapHttpRequest(o);
            } else if (typeof o.setHeader === "function") {
              o = mapHttpResponse(o);
            }
          }
          if (this[nestedKeySym])
            o = { [this[nestedKeySym]]: o };
          let formatParams;
          if (msg === null && n.length === 0) {
            formatParams = [null];
          } else {
            msg = n.shift();
            formatParams = n;
          }
          this[writeSym](o, format(msg, formatParams, this[formatOptsSym]), level);
        } else {
          this[writeSym](null, format(o, n, this[formatOptsSym]), level);
        }
      }
    }
    function asString(str) {
      let result = "";
      let last = 0;
      let found = false;
      let point = 255;
      const l = str.length;
      if (l > 100) {
        return JSON.stringify(str);
      }
      for (var i = 0; i < l && point >= 32; i++) {
        point = str.charCodeAt(i);
        if (point === 34 || point === 92) {
          result += str.slice(last, i) + "\\";
          last = i;
          found = true;
        }
      }
      if (!found) {
        result = str;
      } else {
        result += str.slice(last);
      }
      return point < 32 ? JSON.stringify(str) : '"' + result + '"';
    }
    function asJson(obj, msg, num, time) {
      const stringify2 = this[stringifySym];
      const stringifiers = this[stringifiersSym];
      const end = this[endSym];
      const chindings = this[chindingsSym];
      const serializers = this[serializersSym];
      const formatters = this[formattersSym];
      const messageKey = this[messageKeySym];
      let data = this[lsCacheSym][num] + time;
      data = data + chindings;
      let value;
      const notHasOwnProperty = obj.hasOwnProperty === void 0;
      if (formatters.log) {
        obj = formatters.log(obj);
      }
      if (msg !== void 0) {
        obj[messageKey] = msg;
      }
      const wildcardStringifier = stringifiers[wildcardFirstSym];
      for (const key in obj) {
        value = obj[key];
        if ((notHasOwnProperty || obj.hasOwnProperty(key)) && value !== void 0) {
          value = serializers[key] ? serializers[key](value) : value;
          const stringifier = stringifiers[key] || wildcardStringifier;
          switch (typeof value) {
            case "undefined":
            case "function":
              continue;
            case "number":
              if (Number.isFinite(value) === false) {
                value = null;
              }
            case "boolean":
              if (stringifier)
                value = stringifier(value);
              break;
            case "string":
              value = (stringifier || asString)(value);
              break;
            default:
              value = (stringifier || stringify2)(value);
          }
          if (value === void 0)
            continue;
          data += ',"' + key + '":' + value;
        }
      }
      return data + end;
    }
    function asChindings(instance, bindings) {
      let value;
      let data = instance[chindingsSym];
      const stringify2 = instance[stringifySym];
      const stringifiers = instance[stringifiersSym];
      const wildcardStringifier = stringifiers[wildcardFirstSym];
      const serializers = instance[serializersSym];
      const formatter = instance[formattersSym].bindings;
      bindings = formatter(bindings);
      for (const key in bindings) {
        value = bindings[key];
        const valid = key !== "level" && key !== "serializers" && key !== "formatters" && key !== "customLevels" && bindings.hasOwnProperty(key) && value !== void 0;
        if (valid === true) {
          value = serializers[key] ? serializers[key](value) : value;
          value = (stringifiers[key] || wildcardStringifier || stringify2)(value);
          if (value === void 0)
            continue;
          data += ',"' + key + '":' + value;
        }
      }
      return data;
    }
    function getPrettyStream(opts, prettifier, dest, instance) {
      if (prettifier && typeof prettifier === "function") {
        prettifier = prettifier.bind(instance);
        return prettifierMetaWrapper(prettifier(opts), dest, opts);
      }
      try {
        const prettyFactory = __require("pino-pretty").prettyFactory || __require("pino-pretty");
        prettyFactory.asMetaWrapper = prettifierMetaWrapper;
        return prettifierMetaWrapper(prettyFactory(opts), dest, opts);
      } catch (e) {
        if (e.message.startsWith("Cannot find module 'pino-pretty'")) {
          throw Error("Missing `pino-pretty` module: `pino-pretty` must be installed separately");
        }
        ;
        throw e;
      }
    }
    function prettifierMetaWrapper(pretty, dest, opts) {
      opts = Object.assign({ suppressFlushSyncWarning: false }, opts);
      let warned = false;
      return {
        [needsMetadataGsym]: true,
        lastLevel: 0,
        lastMsg: null,
        lastObj: null,
        lastLogger: null,
        flushSync() {
          if (opts.suppressFlushSyncWarning || warned) {
            return;
          }
          warned = true;
          setMetadataProps(dest, this);
          dest.write(pretty(Object.assign({
            level: 40,
            msg: "pino.final with prettyPrint does not support flushing",
            time: Date.now()
          }, this.chindings())));
        },
        chindings() {
          const lastLogger = this.lastLogger;
          let chindings = null;
          if (!lastLogger) {
            return null;
          }
          if (lastLogger.hasOwnProperty(parsedChindingsSym)) {
            chindings = lastLogger[parsedChindingsSym];
          } else {
            chindings = JSON.parse("{" + lastLogger[chindingsSym].substr(1) + "}");
            lastLogger[parsedChindingsSym] = chindings;
          }
          return chindings;
        },
        write(chunk) {
          const lastLogger = this.lastLogger;
          const chindings = this.chindings();
          let time = this.lastTime;
          if (time.match(/^\d+/)) {
            time = parseInt(time);
          } else {
            time = time.slice(1, -1);
          }
          const lastObj = this.lastObj;
          const lastMsg = this.lastMsg;
          const errorProps = null;
          const formatters = lastLogger[formattersSym];
          const formattedObj = formatters.log ? formatters.log(lastObj) : lastObj;
          const messageKey = lastLogger[messageKeySym];
          if (lastMsg && formattedObj && !formattedObj.hasOwnProperty(messageKey)) {
            formattedObj[messageKey] = lastMsg;
          }
          const obj = Object.assign({
            level: this.lastLevel,
            time
          }, formattedObj, errorProps);
          const serializers = lastLogger[serializersSym];
          const keys = Object.keys(serializers);
          for (var i = 0; i < keys.length; i++) {
            const key = keys[i];
            if (obj[key] !== void 0) {
              obj[key] = serializers[key](obj[key]);
            }
          }
          for (const key in chindings) {
            if (!obj.hasOwnProperty(key)) {
              obj[key] = chindings[key];
            }
          }
          const stringifiers = lastLogger[stringifiersSym];
          const redact = stringifiers[redactFmtSym];
          const formatted = pretty(typeof redact === "function" ? redact(obj) : obj);
          if (formatted === void 0)
            return;
          setMetadataProps(dest, this);
          dest.write(formatted);
        }
      };
    }
    function hasBeenTampered(stream) {
      return stream.write !== stream.constructor.prototype.write;
    }
    function buildSafeSonicBoom(opts) {
      const stream = new SonicBoom(opts);
      stream.on("error", filterBrokenPipe);
      return stream;
      function filterBrokenPipe(err) {
        if (err.code === "EPIPE") {
          stream.write = noop;
          stream.end = noop;
          stream.flushSync = noop;
          stream.destroy = noop;
          return;
        }
        stream.removeListener("error", filterBrokenPipe);
        stream.emit("error", err);
      }
    }
    function createArgsNormalizer(defaultOptions) {
      return function normalizeArgs(instance, opts = {}, stream) {
        if (typeof opts === "string") {
          stream = buildSafeSonicBoom({ dest: opts, sync: true });
          opts = {};
        } else if (typeof stream === "string") {
          stream = buildSafeSonicBoom({ dest: stream, sync: true });
        } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
          stream = opts;
          opts = null;
        }
        opts = Object.assign({}, defaultOptions, opts);
        if ("extreme" in opts) {
          throw Error("The extreme option has been removed, use pino.destination({ sync: false }) instead");
        }
        if ("onTerminated" in opts) {
          throw Error("The onTerminated option has been removed, use pino.final instead");
        }
        if ("changeLevelName" in opts) {
          process.emitWarning("The changeLevelName option is deprecated and will be removed in v7. Use levelKey instead.", { code: "changeLevelName_deprecation" });
          opts.levelKey = opts.changeLevelName;
          delete opts.changeLevelName;
        }
        const { enabled, prettyPrint, prettifier, messageKey } = opts;
        if (enabled === false)
          opts.level = "silent";
        stream = stream || process.stdout;
        if (stream === process.stdout && stream.fd >= 0 && !hasBeenTampered(stream)) {
          stream = buildSafeSonicBoom({ fd: stream.fd, sync: true });
        }
        if (prettyPrint) {
          const prettyOpts = Object.assign({ messageKey }, prettyPrint);
          stream = getPrettyStream(prettyOpts, prettifier, stream, instance);
        }
        return { opts, stream };
      };
    }
    function final(logger2, handler) {
      if (typeof logger2 === "undefined" || typeof logger2.child !== "function") {
        throw Error("expected a pino logger instance");
      }
      const hasHandler = typeof handler !== "undefined";
      if (hasHandler && typeof handler !== "function") {
        throw Error("if supplied, the handler parameter should be a function");
      }
      const stream = logger2[streamSym];
      if (typeof stream.flushSync !== "function") {
        throw Error("final requires a stream that has a flushSync method, such as pino.destination");
      }
      const finalLogger = new Proxy(logger2, {
        get: (logger3, key) => {
          if (key in logger3.levels.values) {
            return (...args2) => {
              logger3[key](...args2);
              stream.flushSync();
            };
          }
          return logger3[key];
        }
      });
      if (!hasHandler) {
        return finalLogger;
      }
      return (err = null, ...args2) => {
        try {
          stream.flushSync();
        } catch (e) {
        }
        return handler(err, finalLogger, ...args2);
      };
    }
    function stringify(obj) {
      try {
        return JSON.stringify(obj);
      } catch (_) {
        return stringifySafe(obj);
      }
    }
    function buildFormatters(level, bindings, log3) {
      return {
        level,
        bindings,
        log: log3
      };
    }
    function setMetadataProps(dest, that) {
      if (dest[needsMetadataGsym] === true) {
        dest.lastLevel = that.lastLevel;
        dest.lastMsg = that.lastMsg;
        dest.lastObj = that.lastObj;
        dest.lastTime = that.lastTime;
        dest.lastLogger = that.lastLogger;
      }
    }
    module2.exports = {
      noop,
      buildSafeSonicBoom,
      getPrettyStream,
      asChindings,
      asJson,
      genLog,
      createArgsNormalizer,
      final,
      stringify,
      buildFormatters
    };
  }
});

// packages/platform-fastify/node_modules/pino/lib/levels.js
var require_levels = __commonJS({
  "packages/platform-fastify/node_modules/pino/lib/levels.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var flatstr = require_flatstr();
    var {
      lsCacheSym,
      levelValSym,
      useOnlyCustomLevelsSym,
      streamSym,
      formattersSym,
      hooksSym
    } = require_symbols2();
    var { noop, genLog } = require_tools();
    var levels = {
      trace: 10,
      debug: 20,
      info: 30,
      warn: 40,
      error: 50,
      fatal: 60
    };
    var levelMethods = {
      fatal: (hook) => {
        const logFatal = genLog(levels.fatal, hook);
        return function(...args2) {
          const stream = this[streamSym];
          logFatal.call(this, ...args2);
          if (typeof stream.flushSync === "function") {
            try {
              stream.flushSync();
            } catch (e) {
            }
          }
        };
      },
      error: (hook) => genLog(levels.error, hook),
      warn: (hook) => genLog(levels.warn, hook),
      info: (hook) => genLog(levels.info, hook),
      debug: (hook) => genLog(levels.debug, hook),
      trace: (hook) => genLog(levels.trace, hook)
    };
    var nums = Object.keys(levels).reduce((o, k) => {
      o[levels[k]] = k;
      return o;
    }, {});
    var initialLsCache = Object.keys(nums).reduce((o, k) => {
      o[k] = flatstr('{"level":' + Number(k));
      return o;
    }, {});
    function genLsCache(instance) {
      const formatter = instance[formattersSym].level;
      const { labels } = instance.levels;
      const cache = {};
      for (const label in labels) {
        const level = formatter(labels[label], Number(label));
        cache[label] = JSON.stringify(level).slice(0, -1);
      }
      instance[lsCacheSym] = cache;
      return instance;
    }
    function isStandardLevel(level, useOnlyCustomLevels) {
      if (useOnlyCustomLevels) {
        return false;
      }
      switch (level) {
        case "fatal":
        case "error":
        case "warn":
        case "info":
        case "debug":
        case "trace":
          return true;
        default:
          return false;
      }
    }
    function setLevel(level) {
      const { labels, values } = this.levels;
      if (typeof level === "number") {
        if (labels[level] === void 0)
          throw Error("unknown level value" + level);
        level = labels[level];
      }
      if (values[level] === void 0)
        throw Error("unknown level " + level);
      const preLevelVal = this[levelValSym];
      const levelVal = this[levelValSym] = values[level];
      const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
      const hook = this[hooksSym].logMethod;
      for (const key in values) {
        if (levelVal > values[key]) {
          this[key] = noop;
          continue;
        }
        this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);
      }
      this.emit("level-change", level, levelVal, labels[preLevelVal], preLevelVal);
    }
    function getLevel(level) {
      const { levels: levels2, levelVal } = this;
      return levels2 && levels2.labels ? levels2.labels[levelVal] : "";
    }
    function isLevelEnabled(logLevel) {
      const { values } = this.levels;
      const logLevelVal = values[logLevel];
      return logLevelVal !== void 0 && logLevelVal >= this[levelValSym];
    }
    function mappings(customLevels = null, useOnlyCustomLevels = false) {
      const customNums = customLevels ? Object.keys(customLevels).reduce((o, k) => {
        o[customLevels[k]] = k;
        return o;
      }, {}) : null;
      const labels = Object.assign(Object.create(Object.prototype, { Infinity: { value: "silent" } }), useOnlyCustomLevels ? null : nums, customNums);
      const values = Object.assign(Object.create(Object.prototype, { silent: { value: Infinity } }), useOnlyCustomLevels ? null : levels, customLevels);
      return { labels, values };
    }
    function assertDefaultLevelFound(defaultLevel, customLevels, useOnlyCustomLevels) {
      if (typeof defaultLevel === "number") {
        const values = [].concat(Object.keys(customLevels || {}).map((key) => customLevels[key]), useOnlyCustomLevels ? [] : Object.keys(nums).map((level) => +level), Infinity);
        if (!values.includes(defaultLevel)) {
          throw Error(`default level:${defaultLevel} must be included in custom levels`);
        }
        return;
      }
      const labels = Object.assign(Object.create(Object.prototype, { silent: { value: Infinity } }), useOnlyCustomLevels ? null : levels, customLevels);
      if (!(defaultLevel in labels)) {
        throw Error(`default level:${defaultLevel} must be included in custom levels`);
      }
    }
    function assertNoLevelCollisions(levels2, customLevels) {
      const { labels, values } = levels2;
      for (const k in customLevels) {
        if (k in values) {
          throw Error("levels cannot be overridden");
        }
        if (customLevels[k] in labels) {
          throw Error("pre-existing level values cannot be used for new levels");
        }
      }
    }
    module2.exports = {
      initialLsCache,
      genLsCache,
      levelMethods,
      getLevel,
      setLevel,
      isLevelEnabled,
      mappings,
      assertNoLevelCollisions,
      assertDefaultLevelFound
    };
  }
});

// packages/platform-fastify/node_modules/pino/package.json
var require_package = __commonJS({
  "packages/platform-fastify/node_modules/pino/package.json"(exports2, module2) {
    module2.exports = {
      name: "pino",
      version: "6.14.0",
      description: "super fast, all natural json logger",
      main: "pino.js",
      browser: "./browser.js",
      files: [
        "pino.js",
        "bin.js",
        "browser.js",
        "pretty.js",
        "usage.txt",
        "test",
        "docs",
        "example.js",
        "lib"
      ],
      scripts: {
        docs: "docsify serve",
        "browser-test": "airtap --local 8080 test/browser*test.js",
        lint: "eslint .",
        test: "npm run lint && tap --100 test/*test.js test/*/*test.js",
        "test-ci": "npm run lint && tap test/*test.js test/*/*test.js --coverage-report=lcovonly",
        "cov-ui": "tap --coverage-report=html test/*test.js test/*/*test.js",
        bench: "node benchmarks/utils/runbench all",
        "bench-basic": "node benchmarks/utils/runbench basic",
        "bench-object": "node benchmarks/utils/runbench object",
        "bench-deep-object": "node benchmarks/utils/runbench deep-object",
        "bench-multi-arg": "node benchmarks/utils/runbench multi-arg",
        "bench-longs-tring": "node benchmarks/utils/runbench long-string",
        "bench-child": "node benchmarks/utils/runbench child",
        "bench-child-child": "node benchmarks/utils/runbench child-child",
        "bench-child-creation": "node benchmarks/utils/runbench child-creation",
        "bench-formatters": "node benchmarks/utils/runbench formatters",
        "update-bench-doc": "node benchmarks/utils/generate-benchmark-doc > docs/benchmarks.md"
      },
      bin: {
        pino: "./bin.js"
      },
      precommit: "test",
      repository: {
        type: "git",
        url: "git+https://github.com/pinojs/pino.git"
      },
      keywords: [
        "fast",
        "logger",
        "stream",
        "json"
      ],
      author: "Matteo Collina <hello@matteocollina.com>",
      contributors: [
        "David Mark Clements <huperekchuno@googlemail.com>",
        "James Sumners <james.sumners@gmail.com>",
        "Thomas Watson Steen <w@tson.dk> (https://twitter.com/wa7son)"
      ],
      license: "MIT",
      bugs: {
        url: "https://github.com/pinojs/pino/issues"
      },
      homepage: "http://getpino.io",
      devDependencies: {
        airtap: "4.0.3",
        benchmark: "^2.1.4",
        bole: "^4.0.0",
        bunyan: "^1.8.14",
        "docsify-cli": "^4.4.1",
        eslint: "^7.17.0",
        "eslint-config-standard": "^16.0.2",
        "eslint-plugin-import": "^2.22.1",
        "eslint-plugin-node": "^11.1.0",
        "eslint-plugin-promise": "^5.1.0",
        execa: "^5.0.0",
        fastbench: "^1.0.1",
        "flush-write-stream": "^2.0.0",
        "import-fresh": "^3.2.1",
        log: "^6.0.0",
        loglevel: "^1.6.7",
        "pino-pretty": "^5.0.0",
        "pre-commit": "^1.2.2",
        proxyquire: "^2.1.3",
        pump: "^3.0.0",
        semver: "^7.0.0",
        split2: "^3.1.1",
        steed: "^1.1.3",
        "strip-ansi": "^6.0.0",
        tap: "^15.0.1",
        tape: "^5.0.0",
        through2: "^4.0.0",
        winston: "^3.3.3"
      },
      dependencies: {
        "fast-redact": "^3.0.0",
        "fast-safe-stringify": "^2.0.8",
        "process-warning": "^1.0.0",
        flatstr: "^1.0.12",
        "pino-std-serializers": "^3.1.0",
        "quick-format-unescaped": "^4.0.3",
        "sonic-boom": "^1.0.2"
      }
    };
  }
});

// packages/platform-fastify/node_modules/pino/lib/meta.js
var require_meta = __commonJS({
  "packages/platform-fastify/node_modules/pino/lib/meta.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var { version } = require_package();
    module2.exports = { version };
  }
});

// packages/platform-fastify/node_modules/pino/lib/proto.js
var require_proto = __commonJS({
  "packages/platform-fastify/node_modules/pino/lib/proto.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var { EventEmitter } = __require("events");
    var SonicBoom = require_sonic_boom();
    var flatstr = require_flatstr();
    var warning = require_deprecations();
    var {
      lsCacheSym,
      levelValSym,
      setLevelSym,
      getLevelSym,
      chindingsSym,
      parsedChindingsSym,
      mixinSym,
      asJsonSym,
      writeSym,
      mixinMergeStrategySym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      serializersSym,
      formattersSym,
      useOnlyCustomLevelsSym,
      needsMetadataGsym,
      redactFmtSym,
      stringifySym,
      formatOptsSym,
      stringifiersSym
    } = require_symbols2();
    var {
      getLevel,
      setLevel,
      isLevelEnabled,
      mappings,
      initialLsCache,
      genLsCache,
      assertNoLevelCollisions
    } = require_levels();
    var {
      asChindings,
      asJson,
      buildFormatters,
      stringify
    } = require_tools();
    var {
      version
    } = require_meta();
    var redaction = require_redaction();
    var constructor = class Pino {
    };
    var prototype = {
      constructor,
      child,
      bindings,
      setBindings,
      flush,
      isLevelEnabled,
      version,
      get level() {
        return this[getLevelSym]();
      },
      set level(lvl) {
        this[setLevelSym](lvl);
      },
      get levelVal() {
        return this[levelValSym];
      },
      set levelVal(n) {
        throw Error("levelVal is read-only");
      },
      [lsCacheSym]: initialLsCache,
      [writeSym]: write,
      [asJsonSym]: asJson,
      [getLevelSym]: getLevel,
      [setLevelSym]: setLevel
    };
    Object.setPrototypeOf(prototype, EventEmitter.prototype);
    module2.exports = function() {
      return Object.create(prototype);
    };
    var resetChildingsFormatter = (bindings2) => bindings2;
    function child(bindings2, options) {
      if (!bindings2) {
        throw Error("missing bindings for child Pino");
      }
      options = options || {};
      const serializers = this[serializersSym];
      const formatters = this[formattersSym];
      const instance = Object.create(this);
      if (bindings2.hasOwnProperty("serializers") === true) {
        warning.emit("PINODEP004");
        options.serializers = bindings2.serializers;
      }
      if (bindings2.hasOwnProperty("formatters") === true) {
        warning.emit("PINODEP005");
        options.formatters = bindings2.formatters;
      }
      if (bindings2.hasOwnProperty("customLevels") === true) {
        warning.emit("PINODEP006");
        options.customLevels = bindings2.customLevels;
      }
      if (bindings2.hasOwnProperty("level") === true) {
        warning.emit("PINODEP007");
        options.level = bindings2.level;
      }
      if (options.hasOwnProperty("serializers") === true) {
        instance[serializersSym] = /* @__PURE__ */ Object.create(null);
        for (const k in serializers) {
          instance[serializersSym][k] = serializers[k];
        }
        const parentSymbols = Object.getOwnPropertySymbols(serializers);
        for (var i = 0; i < parentSymbols.length; i++) {
          const ks = parentSymbols[i];
          instance[serializersSym][ks] = serializers[ks];
        }
        for (const bk in options.serializers) {
          instance[serializersSym][bk] = options.serializers[bk];
        }
        const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers);
        for (var bi = 0; bi < bindingsSymbols.length; bi++) {
          const bks = bindingsSymbols[bi];
          instance[serializersSym][bks] = options.serializers[bks];
        }
      } else
        instance[serializersSym] = serializers;
      if (options.hasOwnProperty("formatters")) {
        const { level, bindings: chindings, log: log3 } = options.formatters;
        instance[formattersSym] = buildFormatters(level || formatters.level, chindings || resetChildingsFormatter, log3 || formatters.log);
      } else {
        instance[formattersSym] = buildFormatters(formatters.level, resetChildingsFormatter, formatters.log);
      }
      if (options.hasOwnProperty("customLevels") === true) {
        assertNoLevelCollisions(this.levels, options.customLevels);
        instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym]);
        genLsCache(instance);
      }
      if (typeof options.redact === "object" && options.redact !== null || Array.isArray(options.redact)) {
        instance.redact = options.redact;
        const stringifiers = redaction(instance.redact, stringify);
        const formatOpts = { stringify: stringifiers[redactFmtSym] };
        instance[stringifySym] = stringify;
        instance[stringifiersSym] = stringifiers;
        instance[formatOptsSym] = formatOpts;
      }
      instance[chindingsSym] = asChindings(instance, bindings2);
      const childLevel = options.level || this.level;
      instance[setLevelSym](childLevel);
      return instance;
    }
    function bindings() {
      const chindings = this[chindingsSym];
      const chindingsJson = `{${chindings.substr(1)}}`;
      const bindingsFromJson = JSON.parse(chindingsJson);
      delete bindingsFromJson.pid;
      delete bindingsFromJson.hostname;
      return bindingsFromJson;
    }
    function setBindings(newBindings) {
      const chindings = asChindings(this, newBindings);
      this[chindingsSym] = chindings;
      delete this[parsedChindingsSym];
    }
    function defaultMixinMergeStrategy(mergeObject, mixinObject) {
      return Object.assign(mixinObject, mergeObject);
    }
    function write(_obj, msg, num) {
      const t2 = this[timeSym]();
      const mixin = this[mixinSym];
      const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
      const objError = _obj instanceof Error;
      let obj;
      if (_obj === void 0 || _obj === null) {
        obj = mixin ? mixin({}) : {};
      } else {
        obj = mixinMergeStrategy(_obj, mixin ? mixin(_obj) : {});
        if (!msg && objError) {
          msg = _obj.message;
        }
        if (objError) {
          obj.stack = _obj.stack;
          if (!obj.type) {
            obj.type = "Error";
          }
        }
      }
      const s2 = this[asJsonSym](obj, msg, num, t2);
      const stream = this[streamSym];
      if (stream[needsMetadataGsym] === true) {
        stream.lastLevel = num;
        stream.lastObj = obj;
        stream.lastMsg = msg;
        stream.lastTime = t2.slice(this[timeSliceIndexSym]);
        stream.lastLogger = this;
      }
      if (stream instanceof SonicBoom)
        stream.write(s2);
      else
        stream.write(flatstr(s2));
    }
    function flush() {
      const stream = this[streamSym];
      if ("flush" in stream)
        stream.flush();
    }
  }
});

// packages/platform-fastify/node_modules/pino/pino.js
var require_pino = __commonJS({
  "packages/platform-fastify/node_modules/pino/pino.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var os = __require("os");
    var stdSerializers = require_pino_std_serializers();
    var redaction = require_redaction();
    var time = require_time();
    var proto = require_proto();
    var symbols = require_symbols2();
    var { assertDefaultLevelFound, mappings, genLsCache } = require_levels();
    var {
      createArgsNormalizer,
      asChindings,
      final,
      stringify,
      buildSafeSonicBoom,
      buildFormatters,
      noop
    } = require_tools();
    var { version } = require_meta();
    var { mixinMergeStrategySym } = require_symbols2();
    var {
      chindingsSym,
      redactFmtSym,
      serializersSym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      stringifySym,
      stringifiersSym,
      setLevelSym,
      endSym,
      formatOptsSym,
      messageKeySym,
      nestedKeySym,
      mixinSym,
      useOnlyCustomLevelsSym,
      formattersSym,
      hooksSym
    } = symbols;
    var { epochTime, nullTime } = time;
    var { pid } = process;
    var hostname = os.hostname();
    var defaultErrorSerializer = stdSerializers.err;
    var defaultOptions = {
      level: "info",
      messageKey: "msg",
      nestedKey: null,
      enabled: true,
      prettyPrint: false,
      base: { pid, hostname },
      serializers: Object.assign(/* @__PURE__ */ Object.create(null), {
        err: defaultErrorSerializer
      }),
      formatters: Object.assign(/* @__PURE__ */ Object.create(null), {
        bindings(bindings) {
          return bindings;
        },
        level(label, number) {
          return { level: number };
        }
      }),
      hooks: {
        logMethod: void 0
      },
      timestamp: epochTime,
      name: void 0,
      redact: null,
      customLevels: null,
      levelKey: void 0,
      useOnlyCustomLevels: false
    };
    var normalize = createArgsNormalizer(defaultOptions);
    var serializers = Object.assign(/* @__PURE__ */ Object.create(null), stdSerializers);
    function pino(...args2) {
      const instance = {};
      const { opts, stream } = normalize(instance, ...args2);
      const {
        redact,
        crlf,
        serializers: serializers2,
        timestamp,
        messageKey,
        nestedKey,
        base,
        name,
        level,
        customLevels,
        useLevelLabels,
        changeLevelName,
        levelKey,
        mixin,
        mixinMergeStrategy,
        useOnlyCustomLevels,
        formatters,
        hooks
      } = opts;
      const allFormatters = buildFormatters(formatters.level, formatters.bindings, formatters.log);
      if (useLevelLabels && !(changeLevelName || levelKey)) {
        process.emitWarning("useLevelLabels is deprecated, use the formatters.level option instead", "Warning", "PINODEP001");
        allFormatters.level = labelsFormatter;
      } else if ((changeLevelName || levelKey) && !useLevelLabels) {
        process.emitWarning("changeLevelName and levelKey are deprecated, use the formatters.level option instead", "Warning", "PINODEP002");
        allFormatters.level = levelNameFormatter(changeLevelName || levelKey);
      } else if ((changeLevelName || levelKey) && useLevelLabels) {
        process.emitWarning("useLevelLabels is deprecated, use the formatters.level option instead", "Warning", "PINODEP001");
        process.emitWarning("changeLevelName and levelKey are deprecated, use the formatters.level option instead", "Warning", "PINODEP002");
        allFormatters.level = levelNameLabelFormatter(changeLevelName || levelKey);
      }
      if (serializers2[Symbol.for("pino.*")]) {
        process.emitWarning("The pino.* serializer is deprecated, use the formatters.log options instead", "Warning", "PINODEP003");
        allFormatters.log = serializers2[Symbol.for("pino.*")];
      }
      if (!allFormatters.bindings) {
        allFormatters.bindings = defaultOptions.formatters.bindings;
      }
      if (!allFormatters.level) {
        allFormatters.level = defaultOptions.formatters.level;
      }
      const stringifiers = redact ? redaction(redact, stringify) : {};
      const formatOpts = redact ? { stringify: stringifiers[redactFmtSym] } : { stringify };
      const end = "}" + (crlf ? "\r\n" : "\n");
      const coreChindings = asChindings.bind(null, {
        [chindingsSym]: "",
        [serializersSym]: serializers2,
        [stringifiersSym]: stringifiers,
        [stringifySym]: stringify,
        [formattersSym]: allFormatters
      });
      let chindings = "";
      if (base !== null) {
        if (name === void 0) {
          chindings = coreChindings(base);
        } else {
          chindings = coreChindings(Object.assign({}, base, { name }));
        }
      }
      const time2 = timestamp instanceof Function ? timestamp : timestamp ? epochTime : nullTime;
      const timeSliceIndex = time2().indexOf(":") + 1;
      if (useOnlyCustomLevels && !customLevels)
        throw Error("customLevels is required if useOnlyCustomLevels is set true");
      if (mixin && typeof mixin !== "function")
        throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`);
      assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);
      const levels = mappings(customLevels, useOnlyCustomLevels);
      Object.assign(instance, {
        levels,
        [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
        [streamSym]: stream,
        [timeSym]: time2,
        [timeSliceIndexSym]: timeSliceIndex,
        [stringifySym]: stringify,
        [stringifiersSym]: stringifiers,
        [endSym]: end,
        [formatOptsSym]: formatOpts,
        [messageKeySym]: messageKey,
        [nestedKeySym]: nestedKey,
        [serializersSym]: serializers2,
        [mixinSym]: mixin,
        [mixinMergeStrategySym]: mixinMergeStrategy,
        [chindingsSym]: chindings,
        [formattersSym]: allFormatters,
        [hooksSym]: hooks,
        silent: noop
      });
      Object.setPrototypeOf(instance, proto());
      genLsCache(instance);
      instance[setLevelSym](level);
      return instance;
    }
    function labelsFormatter(label, number) {
      return { level: label };
    }
    function levelNameFormatter(name) {
      return function(label, number) {
        return { [name]: number };
      };
    }
    function levelNameLabelFormatter(name) {
      return function(label, number) {
        return { [name]: label };
      };
    }
    module2.exports = pino;
    module2.exports.extreme = (dest = process.stdout.fd) => {
      process.emitWarning("The pino.extreme() option is deprecated and will be removed in v7. Use pino.destination({ sync: false }) instead.", { code: "extreme_deprecation" });
      return buildSafeSonicBoom({ dest, minLength: 4096, sync: false });
    };
    module2.exports.destination = (dest = process.stdout.fd) => {
      if (typeof dest === "object") {
        dest.dest = dest.dest || process.stdout.fd;
        return buildSafeSonicBoom(dest);
      } else {
        return buildSafeSonicBoom({ dest, minLength: 0, sync: true });
      }
    };
    module2.exports.final = final;
    module2.exports.levels = mappings();
    module2.exports.stdSerializers = serializers;
    module2.exports.stdTimeFunctions = Object.assign({}, time);
    module2.exports.symbols = symbols;
    module2.exports.version = version;
    module2.exports.default = pino;
    module2.exports.pino = pino;
  }
});

// packages/platform-fastify/node_modules/fastify/lib/logger.js
var require_logger = __commonJS({
  "packages/platform-fastify/node_modules/fastify/lib/logger.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var nullLogger = require_abstract_logging();
    var pino = require_pino();
    var { serializersSym } = pino.symbols;
    var { FST_ERR_LOG_INVALID_DESTINATION } = require_errors();
    function createPinoLogger(opts, stream) {
      stream = stream || opts.stream;
      delete opts.stream;
      if (stream && opts.file) {
        throw new FST_ERR_LOG_INVALID_DESTINATION();
      } else if (opts.file) {
        stream = pino.destination(opts.file);
        delete opts.file;
      }
      const prevLogger = opts.logger;
      const prevGenReqId = opts.genReqId;
      let logger2 = null;
      if (prevLogger) {
        opts.logger = void 0;
        opts.genReqId = void 0;
        if (prevLogger[serializersSym]) {
          opts.serializers = Object.assign({}, opts.serializers, prevLogger[serializersSym]);
        }
        logger2 = prevLogger.child({}, opts);
        opts.logger = prevLogger;
        opts.genReqId = prevGenReqId;
      } else {
        logger2 = pino(opts, stream);
      }
      return logger2;
    }
    var serializers = {
      req: function asReqValue(req) {
        return {
          method: req.method,
          url: req.url,
          version: req.headers && req.headers["accept-version"],
          hostname: req.hostname,
          remoteAddress: req.ip,
          remotePort: req.socket ? req.socket.remotePort : void 0
        };
      },
      err: pino.stdSerializers.err,
      res: function asResValue(reply) {
        return {
          statusCode: reply.statusCode
        };
      }
    };
    function now() {
      const ts = process.hrtime();
      return ts[0] * 1e3 + ts[1] / 1e6;
    }
    function createLogger(options) {
      if (isValidLogger(options.logger)) {
        const logger2 = createPinoLogger({
          logger: options.logger,
          serializers: Object.assign({}, serializers, options.logger.serializers)
        });
        return { logger: logger2, hasLogger: true };
      } else if (!options.logger) {
        const logger2 = nullLogger;
        logger2.child = () => logger2;
        return { logger: logger2, hasLogger: false };
      } else {
        const localLoggerOptions = {};
        if (Object.prototype.toString.call(options.logger) === "[object Object]") {
          Reflect.ownKeys(options.logger).forEach((prop) => {
            Object.defineProperty(localLoggerOptions, prop, {
              value: options.logger[prop],
              writable: true,
              enumerable: true,
              configurable: true
            });
          });
        }
        localLoggerOptions.level = localLoggerOptions.level || "info";
        localLoggerOptions.serializers = Object.assign({}, serializers, localLoggerOptions.serializers);
        options.logger = localLoggerOptions;
        const logger2 = createPinoLogger(options.logger);
        return { logger: logger2, hasLogger: true };
      }
    }
    function isValidLogger(logger2) {
      if (!logger2) {
        return false;
      }
      let result = true;
      const methods = ["info", "error", "debug", "fatal", "warn", "trace", "child"];
      for (let i = 0; i < methods.length; i += 1) {
        if (!logger2[methods[i]] || typeof logger2[methods[i]] !== "function") {
          result = false;
          break;
        }
      }
      return result;
    }
    module2.exports = {
      createLogger,
      serializers,
      now
    };
  }
});

// packages/platform-fastify/node_modules/fastify/lib/warnings.js
var require_warnings = __commonJS({
  "packages/platform-fastify/node_modules/fastify/lib/warnings.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var warning = require_process_warning()();
    warning.create("FastifyDeprecation", "FSTDEP001", 'You are accessing the Node.js core request object via "request.req", Use "request.raw" instead.');
    warning.create("FastifyDeprecation", "FSTDEP002", 'You are accessing the Node.js core response object via "reply.res", Use "reply.raw" instead.');
    warning.create("FastifyDeprecation", "FSTDEP003", "You are using the legacy Content Type Parser function signature. Use the one suggested in the documentation instead.");
    warning.create("FastifyDeprecation", "FSTDEP004", "You are using the legacy preParsing hook signature. Use the one suggested in the documentation instead.");
    warning.create("FastifyDeprecation", "FSTDEP005", 'You are accessing the deprecated "request.connection" property. Use "request.socket" instead.');
    warning.create("FastifyDeprecation", "FSTDEP006", "You are decorating Request/Reply with a reference type. This reference is shared amongst all requests. Use onRequest hook instead. Property: %s");
    warning.create("FastifyDeprecation", "FSTDEP007", 'You are trying to set a HEAD route using "exposeHeadRoute" route flag when a sibling route is already set. See documentation for more info.');
    warning.create("FastifyDeprecation", "FSTDEP008", 'You are using route constraints via the route { version: "..." } option, use { constraints: { version: "..." } } option instead.');
    warning.create("FastifyDeprecation", "FSTDEP009", 'You are using a custom route versioning strategy via the server { versioning: "..." } option, use { constraints: { version: "..." } } option instead.');
    module2.exports = warning;
  }
});

// packages/platform-fastify/node_modules/fastify/lib/reply.js
var require_reply = __commonJS({
  "packages/platform-fastify/node_modules/fastify/lib/reply.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var eos = __require("stream").finished;
    var statusCodes = __require("http").STATUS_CODES;
    var flatstr = require_flatstr();
    var FJS = __require("fast-json-stringify");
    var {
      kSchemaResponse,
      kFourOhFourContext,
      kReplyErrorHandlerCalled,
      kReplySent,
      kReplySentOverwritten,
      kReplyStartTime,
      kReplyEndTime,
      kReplySerializer,
      kReplySerializerDefault,
      kReplyIsError,
      kReplyHeaders,
      kReplyHasStatusCode,
      kReplyIsRunningOnErrorHook,
      kDisableRequestLogging
    } = require_symbols();
    var { hookRunner, hookIterator, onSendHookRunner } = require_hooks();
    var internals = require_handleRequest()[Symbol.for("internals")];
    var loggerUtils = require_logger();
    var now = loggerUtils.now;
    var wrapThenable = require_wrapThenable();
    var serializeError = FJS({
      type: "object",
      properties: {
        statusCode: { type: "number" },
        code: { type: "string" },
        error: { type: "string" },
        message: { type: "string" }
      }
    });
    var CONTENT_TYPE = {
      JSON: "application/json; charset=utf-8",
      PLAIN: "text/plain; charset=utf-8",
      OCTET: "application/octet-stream"
    };
    var {
      FST_ERR_REP_INVALID_PAYLOAD_TYPE,
      FST_ERR_REP_ALREADY_SENT,
      FST_ERR_REP_SENT_VALUE,
      FST_ERR_SEND_INSIDE_ONERR,
      FST_ERR_BAD_STATUS_CODE
    } = require_errors();
    var warning = require_warnings();
    function Reply2(res, request, log3) {
      this.raw = res;
      this[kReplySent] = false;
      this[kReplySerializer] = null;
      this[kReplyErrorHandlerCalled] = false;
      this[kReplyIsError] = false;
      this[kReplyIsRunningOnErrorHook] = false;
      this.request = request;
      this[kReplyHeaders] = {};
      this[kReplyHasStatusCode] = false;
      this[kReplyStartTime] = void 0;
      this.log = log3;
    }
    Reply2.props = [];
    Object.defineProperties(Reply2.prototype, {
      context: {
        get() {
          return this.request.context;
        }
      },
      res: {
        get() {
          warning.emit("FSTDEP002");
          return this.raw;
        }
      },
      sent: {
        enumerable: true,
        get() {
          return this[kReplySent];
        },
        set(value) {
          if (value !== true) {
            throw new FST_ERR_REP_SENT_VALUE();
          }
          if (this[kReplySent]) {
            throw new FST_ERR_REP_ALREADY_SENT();
          }
          this[kReplySentOverwritten] = true;
          this[kReplySent] = true;
        }
      },
      statusCode: {
        get() {
          return this.raw.statusCode;
        },
        set(value) {
          this.code(value);
        }
      },
      server: {
        value: null,
        writable: true
      }
    });
    Reply2.prototype.hijack = function() {
      this[kReplySent] = true;
      return this;
    };
    Reply2.prototype.send = function(payload) {
      if (this[kReplyIsRunningOnErrorHook] === true) {
        throw new FST_ERR_SEND_INSIDE_ONERR();
      }
      if (this[kReplySent]) {
        this.log.warn({ err: new FST_ERR_REP_ALREADY_SENT() }, "Reply already sent");
        return this;
      }
      if (payload instanceof Error || this[kReplyIsError] === true) {
        onErrorHook(this, payload, onSendHook);
        return this;
      }
      if (payload === void 0) {
        onSendHook(this, payload);
        return this;
      }
      const contentType = this.getHeader("content-type");
      const hasContentType = contentType !== void 0;
      if (payload !== null) {
        if (Buffer.isBuffer(payload) || typeof payload.pipe === "function") {
          if (hasContentType === false) {
            this[kReplyHeaders]["content-type"] = CONTENT_TYPE.OCTET;
          }
          onSendHook(this, payload);
          return this;
        }
        if (hasContentType === false && typeof payload === "string") {
          this[kReplyHeaders]["content-type"] = CONTENT_TYPE.PLAIN;
          onSendHook(this, payload);
          return this;
        }
      }
      if (this[kReplySerializer] !== null) {
        if (typeof payload !== "string") {
          preserializeHook(this, payload);
          return this;
        } else {
          payload = this[kReplySerializer](payload);
        }
      } else if (hasContentType === false || contentType.indexOf("json") > -1) {
        if (hasContentType === false) {
          this[kReplyHeaders]["content-type"] = CONTENT_TYPE.JSON;
        } else {
          if (contentType.indexOf("charset") === -1) {
            if (contentType.indexOf("/json") > -1) {
              this[kReplyHeaders]["content-type"] = CONTENT_TYPE.JSON;
            } else {
              const currContentType = this[kReplyHeaders]["content-type"];
              const customJsonType = currContentType.substring(currContentType.indexOf("/"), currContentType.indexOf("json") + 4);
              this[kReplyHeaders]["content-type"] = CONTENT_TYPE.JSON.replace("/json", customJsonType);
            }
          }
        }
        if (typeof payload !== "string") {
          preserializeHook(this, payload);
          return this;
        }
      }
      onSendHook(this, payload);
      return this;
    };
    Reply2.prototype.getHeader = function(key) {
      key = key.toLowerCase();
      const res = this.raw;
      let value = this[kReplyHeaders][key];
      if (value === void 0 && res.hasHeader(key)) {
        value = res.getHeader(key);
      }
      return value;
    };
    Reply2.prototype.getHeaders = function() {
      return __spreadValues(__spreadValues({}, this.raw.getHeaders()), this[kReplyHeaders]);
    };
    Reply2.prototype.hasHeader = function(key) {
      key = key.toLowerCase();
      if (this[kReplyHeaders][key] !== void 0) {
        return true;
      }
      return this.raw.hasHeader(key);
    };
    Reply2.prototype.removeHeader = function(key) {
      delete this[kReplyHeaders][key.toLowerCase()];
      return this;
    };
    Reply2.prototype.header = function(key, value) {
      const _key = key.toLowerCase();
      value = value === void 0 ? "" : value;
      if (this[kReplyHeaders][_key] && _key === "set-cookie") {
        if (typeof this[kReplyHeaders][_key] === "string") {
          this[kReplyHeaders][_key] = [this[kReplyHeaders][_key]];
        }
        if (Array.isArray(value)) {
          Array.prototype.push.apply(this[kReplyHeaders][_key], value);
        } else {
          this[kReplyHeaders][_key].push(value);
        }
      } else {
        this[kReplyHeaders][_key] = value;
      }
      return this;
    };
    Reply2.prototype.headers = function(headers) {
      const keys = Object.keys(headers);
      for (var i = 0; i !== keys.length; ++i) {
        const key = keys[i];
        this.header(key, headers[key]);
      }
      return this;
    };
    Reply2.prototype.code = function(code) {
      const intValue = parseInt(code);
      if (isNaN(intValue) || intValue < 100 || intValue > 600) {
        throw new FST_ERR_BAD_STATUS_CODE(code || String(code));
      }
      this.raw.statusCode = intValue;
      this[kReplyHasStatusCode] = true;
      return this;
    };
    Reply2.prototype.status = Reply2.prototype.code;
    Reply2.prototype.serialize = function(payload) {
      if (this[kReplySerializer] !== null) {
        return this[kReplySerializer](payload);
      } else {
        if (this.context && this.context[kReplySerializerDefault]) {
          return this.context[kReplySerializerDefault](payload, this.raw.statusCode);
        } else {
          return serialize(this.context, payload, this.raw.statusCode);
        }
      }
    };
    Reply2.prototype.serializer = function(fn2) {
      this[kReplySerializer] = fn2;
      return this;
    };
    Reply2.prototype.type = function(type) {
      this[kReplyHeaders]["content-type"] = type;
      return this;
    };
    Reply2.prototype.redirect = function(code, url) {
      if (typeof code === "string") {
        url = code;
        code = this[kReplyHasStatusCode] ? this.raw.statusCode : 302;
      }
      this.header("location", url).code(code).send();
    };
    Reply2.prototype.callNotFound = function() {
      notFound(this);
    };
    Reply2.prototype.getResponseTime = function() {
      let responseTime = 0;
      if (this[kReplyStartTime] !== void 0) {
        responseTime = (this[kReplyEndTime] || now()) - this[kReplyStartTime];
      }
      return responseTime;
    };
    Reply2.prototype.then = function(fulfilled, rejected) {
      if (this.sent) {
        fulfilled();
        return;
      }
      eos(this.raw, (err) => {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          if (rejected) {
            rejected(err);
          } else {
            this.log && this.log.warn("unhandled rejection on reply.then");
          }
        } else {
          fulfilled();
        }
      });
    };
    function preserializeHook(reply, payload) {
      if (reply.context.preSerialization !== null) {
        onSendHookRunner(reply.context.preSerialization, reply.request, reply, payload, preserializeHookEnd);
      } else {
        preserializeHookEnd(null, reply.request, reply, payload);
      }
    }
    function preserializeHookEnd(err, request, reply, payload) {
      if (err != null) {
        onErrorHook(reply, err);
        return;
      }
      try {
        if (reply[kReplySerializer] !== null) {
          payload = reply[kReplySerializer](payload);
        } else if (reply.context && reply.context[kReplySerializerDefault]) {
          payload = reply.context[kReplySerializerDefault](payload, reply.raw.statusCode);
        } else {
          payload = serialize(reply.context, payload, reply.raw.statusCode);
        }
      } catch (e) {
        wrapSeralizationError(e, reply);
        onErrorHook(reply, e);
        return;
      }
      flatstr(payload);
      onSendHook(reply, payload);
    }
    function wrapSeralizationError(error, reply) {
      error.serialization = reply.context.config;
    }
    function onSendHook(reply, payload) {
      if (reply.context.onSend !== null) {
        reply[kReplySent] = true;
        onSendHookRunner(reply.context.onSend, reply.request, reply, payload, wrapOnSendEnd);
      } else {
        onSendEnd(reply, payload);
      }
    }
    function wrapOnSendEnd(err, request, reply, payload) {
      if (err != null) {
        onErrorHook(reply, err);
      } else {
        onSendEnd(reply, payload);
      }
    }
    function onSendEnd(reply, payload) {
      const res = reply.raw;
      const req = reply.request;
      const statusCode = res.statusCode;
      if (payload === void 0 || payload === null) {
        reply[kReplySent] = true;
        if (statusCode >= 200 && statusCode !== 204 && statusCode !== 304 && req.method !== "HEAD") {
          reply[kReplyHeaders]["content-length"] = "0";
        }
        res.writeHead(statusCode, reply[kReplyHeaders]);
        res.end(null, null, null);
        return;
      }
      if (typeof payload.pipe === "function") {
        reply[kReplySent] = true;
        sendStream(payload, res, reply);
        return;
      }
      if (typeof payload !== "string" && !Buffer.isBuffer(payload)) {
        throw new FST_ERR_REP_INVALID_PAYLOAD_TYPE(typeof payload);
      }
      if (!reply[kReplyHeaders]["content-length"]) {
        reply[kReplyHeaders]["content-length"] = "" + Buffer.byteLength(payload);
      } else if (req.raw.method !== "HEAD" && reply[kReplyHeaders]["content-length"] !== Buffer.byteLength(payload)) {
        reply[kReplyHeaders]["content-length"] = "" + Buffer.byteLength(payload);
      }
      reply[kReplySent] = true;
      res.writeHead(statusCode, reply[kReplyHeaders]);
      res.end(payload, null, null);
    }
    function logStreamError(logger2, err, res) {
      if (err.code === "ERR_STREAM_PREMATURE_CLOSE") {
        if (!logger2[kDisableRequestLogging]) {
          logger2.info({ res }, "stream closed prematurely");
        }
      } else {
        logger2.warn({ err }, "response terminated with an error with headers already sent");
      }
    }
    function sendStream(payload, res, reply) {
      let sourceOpen = true;
      let errorLogged = false;
      eos(payload, { readable: true, writable: false }, function(err) {
        sourceOpen = false;
        if (err != null) {
          if (res.headersSent) {
            if (!errorLogged) {
              errorLogged = true;
              logStreamError(reply.log, err, res);
            }
            res.destroy();
          } else {
            onErrorHook(reply, err);
          }
        }
      });
      eos(res, function(err) {
        if (sourceOpen) {
          if (err != null && res.headersSent && !errorLogged) {
            errorLogged = true;
            logStreamError(reply.log, err, res);
          }
          if (typeof payload.destroy === "function") {
            payload.destroy();
          } else if (typeof payload.close === "function") {
            payload.close(noop);
          } else if (typeof payload.abort === "function") {
            payload.abort();
          } else {
            reply.log.warn("stream payload does not end properly");
          }
        }
      });
      if (!res.headersSent) {
        for (const key in reply[kReplyHeaders]) {
          res.setHeader(key, reply[kReplyHeaders][key]);
        }
      } else {
        reply.log.warn("response will send, but you shouldn't use res.writeHead in stream mode");
      }
      payload.pipe(res);
    }
    function onErrorHook(reply, error, cb) {
      reply[kReplySent] = true;
      if (reply.context.onError !== null && reply[kReplyErrorHandlerCalled] === true) {
        reply[kReplyIsRunningOnErrorHook] = true;
        onSendHookRunner(reply.context.onError, reply.request, reply, error, () => handleError(reply, error, cb));
      } else {
        handleError(reply, error, cb);
      }
    }
    function handleError(reply, error, cb) {
      reply[kReplyIsRunningOnErrorHook] = false;
      const res = reply.raw;
      let statusCode = res.statusCode;
      statusCode = statusCode >= 400 ? statusCode : 500;
      if (error != null) {
        if (error.headers !== void 0) {
          reply.headers(error.headers);
        }
        if (error.status >= 400) {
          statusCode = error.status;
        } else if (error.statusCode >= 400) {
          statusCode = error.statusCode;
        }
      }
      res.statusCode = statusCode;
      const errorHandler = reply.context.errorHandler;
      if (errorHandler && reply[kReplyErrorHandlerCalled] === false) {
        reply[kReplySent] = false;
        reply[kReplyIsError] = false;
        reply[kReplyErrorHandlerCalled] = true;
        reply.removeHeader("content-length");
        const result = errorHandler(error, reply.request, reply);
        if (result !== void 0) {
          if (result !== null && typeof result.then === "function") {
            wrapThenable(result, reply);
          } else {
            reply.send(result);
          }
        }
        return;
      }
      let payload;
      try {
        const serializerFn = getSchemaSerializer(reply.context, statusCode);
        payload = serializerFn === false ? serializeError({
          error: statusCodes[statusCode + ""],
          code: error.code,
          message: error.message || "",
          statusCode
        }) : serializerFn(Object.create(error, {
          error: { value: statusCodes[statusCode + ""] },
          message: { value: error.message || "" },
          statusCode: { value: statusCode }
        }));
        if (serializerFn !== false && typeof payload !== "string") {
          throw new FST_ERR_REP_INVALID_PAYLOAD_TYPE(typeof payload);
        }
      } catch (err) {
        reply.log.error({ err, statusCode: res.statusCode }, "The serializer for the given status code failed");
        res.statusCode = 500;
        payload = serializeError({
          error: statusCodes["500"],
          code: err.code,
          message: err.message,
          statusCode: 500
        });
      }
      flatstr(payload);
      reply[kReplyHeaders]["content-type"] = CONTENT_TYPE.JSON;
      reply[kReplyHeaders]["content-length"] = "" + Buffer.byteLength(payload);
      if (cb) {
        cb(reply, payload);
        return;
      }
      reply[kReplySent] = true;
      res.writeHead(res.statusCode, reply[kReplyHeaders]);
      res.end(payload);
    }
    function setupResponseListeners(reply) {
      reply[kReplyStartTime] = now();
      const onResFinished = (err) => {
        reply[kReplyEndTime] = now();
        reply.raw.removeListener("finish", onResFinished);
        reply.raw.removeListener("error", onResFinished);
        const ctx = reply.context;
        if (ctx && ctx.onResponse !== null) {
          hookRunner(ctx.onResponse, onResponseIterator, reply.request, reply, onResponseCallback);
        } else {
          onResponseCallback(err, reply.request, reply);
        }
      };
      reply.raw.on("finish", onResFinished);
      reply.raw.on("error", onResFinished);
    }
    function onResponseIterator(fn2, request, reply, next) {
      return fn2(request, reply, next);
    }
    function onResponseCallback(err, request, reply) {
      if (reply.log[kDisableRequestLogging]) {
        return;
      }
      const responseTime = reply.getResponseTime();
      if (err != null) {
        reply.log.error({
          res: reply,
          err,
          responseTime
        }, "request errored");
        return;
      }
      reply.log.info({
        res: reply,
        responseTime
      }, "request completed");
    }
    function buildReply(R) {
      const props = [...R.props];
      function _Reply(res, request, log3) {
        this.raw = res;
        this[kReplyIsError] = false;
        this[kReplyErrorHandlerCalled] = false;
        this[kReplySent] = false;
        this[kReplySentOverwritten] = false;
        this[kReplySerializer] = null;
        this.request = request;
        this[kReplyHeaders] = {};
        this[kReplyStartTime] = void 0;
        this[kReplyEndTime] = void 0;
        this.log = log3;
        var prop;
        for (var i = 0; i < props.length; i++) {
          prop = props[i];
          this[prop.key] = prop.value;
        }
      }
      _Reply.prototype = new R();
      _Reply.props = props;
      return _Reply;
    }
    function notFound(reply) {
      reply[kReplySent] = false;
      reply[kReplyIsError] = false;
      if (reply.context[kFourOhFourContext] === null) {
        reply.log.warn("Trying to send a NotFound error inside a 404 handler. Sending basic 404 response.");
        reply.code(404).send("404 Not Found");
        return;
      }
      reply.request.context = reply.context[kFourOhFourContext];
      if (reply.context.preHandler !== null) {
        hookRunner(reply.context.preHandler, hookIterator, reply.request, reply, internals.preHandlerCallback);
      } else {
        internals.preHandlerCallback(null, reply.request, reply);
      }
    }
    function serialize(context, data, statusCode) {
      const fnSerialize = getSchemaSerializer(context, statusCode);
      if (fnSerialize) {
        return fnSerialize(data);
      }
      return JSON.stringify(data);
    }
    function getSchemaSerializer(context, statusCode) {
      const responseSchemaDef = context[kSchemaResponse];
      if (!responseSchemaDef) {
        return false;
      }
      if (responseSchemaDef[statusCode]) {
        return responseSchemaDef[statusCode];
      }
      const fallbackStatusCode = (statusCode + "")[0] + "xx";
      if (responseSchemaDef[fallbackStatusCode]) {
        return responseSchemaDef[fallbackStatusCode];
      }
      return false;
    }
    function noop() {
    }
    module2.exports = Reply2;
    module2.exports.buildReply = buildReply;
    module2.exports.setupResponseListeners = setupResponseListeners;
  }
});

// packages/platform-fastify/node_modules/forwarded/index.js
var require_forwarded = __commonJS({
  "packages/platform-fastify/node_modules/forwarded/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = forwarded;
    function forwarded(req) {
      if (!req) {
        throw new TypeError("argument req is required");
      }
      var proxyAddrs = parse(req.headers["x-forwarded-for"] || "");
      var socketAddr = getSocketAddr(req);
      var addrs = [socketAddr].concat(proxyAddrs);
      return addrs;
    }
    function getSocketAddr(req) {
      return req.socket ? req.socket.remoteAddress : req.connection.remoteAddress;
    }
    function parse(header) {
      var end = header.length;
      var list = [];
      var start = header.length;
      for (var i = header.length - 1; i >= 0; i--) {
        switch (header.charCodeAt(i)) {
          case 32:
            if (start === end) {
              start = end = i;
            }
            break;
          case 44:
            if (start !== end) {
              list.push(header.substring(start, end));
            }
            start = end = i;
            break;
          default:
            start = i;
            break;
        }
      }
      if (start !== end) {
        list.push(header.substring(start, end));
      }
      return list;
    }
  }
});

// packages/platform-fastify/node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = __commonJS({
  "packages/platform-fastify/node_modules/ipaddr.js/lib/ipaddr.js"(exports2, module2) {
    init_esm_shims();
    (function() {
      var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;
      ipaddr = {};
      root = this;
      if (typeof module2 !== "undefined" && module2 !== null && module2.exports) {
        module2.exports = ipaddr;
      } else {
        root["ipaddr"] = ipaddr;
      }
      matchCIDR = function(first, second, partSize, cidrBits) {
        var part, shift;
        if (first.length !== second.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        part = 0;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first[part] >> shift !== second[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      };
      ipaddr.subnetMatch = function(address, rangeList, defaultName) {
        var k, len, rangeName, rangeSubnets, subnet;
        if (defaultName == null) {
          defaultName = "unicast";
        }
        for (rangeName in rangeList) {
          rangeSubnets = rangeList[rangeName];
          if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
            rangeSubnets = [rangeSubnets];
          }
          for (k = 0, len = rangeSubnets.length; k < len; k++) {
            subnet = rangeSubnets[k];
            if (address.kind() === subnet[0].kind()) {
              if (address.match.apply(address, subnet)) {
                return rangeName;
              }
            }
          }
        }
        return defaultName;
      };
      ipaddr.IPv4 = function() {
        function IPv4(octets) {
          var k, len, octet;
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          for (k = 0, len = octets.length; k < len; k++) {
            octet = octets[k];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
            }
          }
          this.octets = octets;
        }
        IPv4.prototype.kind = function() {
          return "ipv4";
        };
        IPv4.prototype.toString = function() {
          return this.octets.join(".");
        };
        IPv4.prototype.toNormalizedString = function() {
          return this.toString();
        };
        IPv4.prototype.toByteArray = function() {
          return this.octets.slice(0);
        };
        IPv4.prototype.match = function(other, cidrRange) {
          var ref;
          if (cidrRange === void 0) {
            ref = other, other = ref[0], cidrRange = ref[1];
          }
          if (other.kind() !== "ipv4") {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
          "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
          reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
        };
        IPv4.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toIPv4MappedAddress = function() {
          return ipaddr.IPv6.parse("::ffff:" + this.toString());
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function() {
          var cidr, i, k, octet, stop, zeros, zerotable;
          zerotable = {
            0: 8,
            128: 7,
            192: 6,
            224: 5,
            240: 4,
            248: 3,
            252: 2,
            254: 1,
            255: 0
          };
          cidr = 0;
          stop = false;
          for (i = k = 3; k >= 0; i = k += -1) {
            octet = this.octets[i];
            if (octet in zerotable) {
              zeros = zerotable[octet];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 8) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 32 - cidr;
        };
        return IPv4;
      }();
      ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      ipv4Regexes = {
        fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", "i"),
        longValue: new RegExp("^" + ipv4Part + "$", "i")
      };
      ipaddr.IPv4.parser = function(string) {
        var match, parseIntAuto, part, shift, value;
        parseIntAuto = function(string2) {
          if (string2[0] === "0" && string2[1] !== "x") {
            return parseInt(string2, 8);
          } else {
            return parseInt(string2);
          }
        };
        if (match = string.match(ipv4Regexes.fourOctet)) {
          return function() {
            var k, len, ref, results;
            ref = match.slice(1, 6);
            results = [];
            for (k = 0, len = ref.length; k < len; k++) {
              part = ref[k];
              results.push(parseIntAuto(part));
            }
            return results;
          }();
        } else if (match = string.match(ipv4Regexes.longValue)) {
          value = parseIntAuto(match[1]);
          if (value > 4294967295 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return function() {
            var k, results;
            results = [];
            for (shift = k = 0; k <= 24; shift = k += 8) {
              results.push(value >> shift & 255);
            }
            return results;
          }().reverse();
        } else {
          return null;
        }
      };
      ipaddr.IPv6 = function() {
        function IPv6(parts, zoneId) {
          var i, k, l, len, part, ref;
          if (parts.length === 16) {
            this.parts = [];
            for (i = k = 0; k <= 14; i = k += 2) {
              this.parts.push(parts[i] << 8 | parts[i + 1]);
            }
          } else if (parts.length === 8) {
            this.parts = parts;
          } else {
            throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          }
          ref = this.parts;
          for (l = 0, len = ref.length; l < len; l++) {
            part = ref[l];
            if (!(0 <= part && part <= 65535)) {
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
            }
          }
          if (zoneId) {
            this.zoneId = zoneId;
          }
        }
        IPv6.prototype.kind = function() {
          return "ipv6";
        };
        IPv6.prototype.toString = function() {
          return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
        };
        IPv6.prototype.toRFC5952String = function() {
          var bestMatchIndex, bestMatchLength, match, regex, string;
          regex = /((^|:)(0(:|$)){2,})/g;
          string = this.toNormalizedString();
          bestMatchIndex = 0;
          bestMatchLength = -1;
          while (match = regex.exec(string)) {
            if (match[0].length > bestMatchLength) {
              bestMatchIndex = match.index;
              bestMatchLength = match[0].length;
            }
          }
          if (bestMatchLength < 0) {
            return string;
          }
          return string.substring(0, bestMatchIndex) + "::" + string.substring(bestMatchIndex + bestMatchLength);
        };
        IPv6.prototype.toByteArray = function() {
          var bytes, k, len, part, ref;
          bytes = [];
          ref = this.parts;
          for (k = 0, len = ref.length; k < len; k++) {
            part = ref[k];
            bytes.push(part >> 8);
            bytes.push(part & 255);
          }
          return bytes;
        };
        IPv6.prototype.toNormalizedString = function() {
          var addr, part, suffix;
          addr = function() {
            var k, len, ref, results;
            ref = this.parts;
            results = [];
            for (k = 0, len = ref.length; k < len; k++) {
              part = ref[k];
              results.push(part.toString(16));
            }
            return results;
          }.call(this).join(":");
          suffix = "";
          if (this.zoneId) {
            suffix = "%" + this.zoneId;
          }
          return addr + suffix;
        };
        IPv6.prototype.toFixedLengthString = function() {
          var addr, part, suffix;
          addr = function() {
            var k, len, ref, results;
            ref = this.parts;
            results = [];
            for (k = 0, len = ref.length; k < len; k++) {
              part = ref[k];
              results.push(part.toString(16).padStart(4, "0"));
            }
            return results;
          }.call(this).join(":");
          suffix = "";
          if (this.zoneId) {
            suffix = "%" + this.zoneId;
          }
          return addr + suffix;
        };
        IPv6.prototype.match = function(other, cidrRange) {
          var ref;
          if (cidrRange === void 0) {
            ref = other, other = ref[0], cidrRange = ref[1];
          }
          if (other.kind() !== "ipv6") {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.SpecialRanges = {
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
          rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
          rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
          "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
          teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
          reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
        };
        IPv6.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.isIPv4MappedAddress = function() {
          return this.range() === "ipv4Mapped";
        };
        IPv6.prototype.toIPv4Address = function() {
          var high, low, ref;
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          ref = this.parts.slice(-2), high = ref[0], low = ref[1];
          return new ipaddr.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function() {
          var cidr, i, k, part, stop, zeros, zerotable;
          zerotable = {
            0: 16,
            32768: 15,
            49152: 14,
            57344: 13,
            61440: 12,
            63488: 11,
            64512: 10,
            65024: 9,
            65280: 8,
            65408: 7,
            65472: 6,
            65504: 5,
            65520: 4,
            65528: 3,
            65532: 2,
            65534: 1,
            65535: 0
          };
          cidr = 0;
          stop = false;
          for (i = k = 7; k >= 0; i = k += -1) {
            part = this.parts[i];
            if (part in zerotable) {
              zeros = zerotable[part];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 16) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 128 - cidr;
        };
        return IPv6;
      }();
      ipv6Part = "(?:[0-9a-f]+::?)+";
      zoneIndex = "%[0-9a-z]{1,}";
      ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, "i"),
        "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", "i"),
        transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), "i")
      };
      expandIPv6 = function(string, parts) {
        var colonCount, lastColon, part, replacement, replacementCount, zoneId;
        if (string.indexOf("::") !== string.lastIndexOf("::")) {
          return null;
        }
        zoneId = (string.match(ipv6Regexes["zoneIndex"]) || [])[0];
        if (zoneId) {
          zoneId = zoneId.substring(1);
          string = string.replace(/%.+$/, "");
        }
        colonCount = 0;
        lastColon = -1;
        while ((lastColon = string.indexOf(":", lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string.substr(0, 2) === "::") {
          colonCount--;
        }
        if (string.substr(-2, 2) === "::") {
          colonCount--;
        }
        if (colonCount > parts) {
          return null;
        }
        replacementCount = parts - colonCount;
        replacement = ":";
        while (replacementCount--) {
          replacement += "0:";
        }
        string = string.replace("::", replacement);
        if (string[0] === ":") {
          string = string.slice(1);
        }
        if (string[string.length - 1] === ":") {
          string = string.slice(0, -1);
        }
        parts = function() {
          var k, len, ref, results;
          ref = string.split(":");
          results = [];
          for (k = 0, len = ref.length; k < len; k++) {
            part = ref[k];
            results.push(parseInt(part, 16));
          }
          return results;
        }();
        return {
          parts,
          zoneId
        };
      };
      ipaddr.IPv6.parser = function(string) {
        var addr, k, len, match, octet, octets, zoneId;
        if (ipv6Regexes["native"].test(string)) {
          return expandIPv6(string, 8);
        } else if (match = string.match(ipv6Regexes["transitional"])) {
          zoneId = match[6] || "";
          addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
          if (addr.parts) {
            octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
            for (k = 0, len = octets.length; k < len; k++) {
              octet = octets[k];
              if (!(0 <= octet && octet <= 255)) {
                return null;
              }
            }
            addr.parts.push(octets[0] << 8 | octets[1]);
            addr.parts.push(octets[2] << 8 | octets[3]);
            return {
              parts: addr.parts,
              zoneId: addr.zoneId
            };
          }
        }
        return null;
      };
      ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
        return this.parser(string) !== null;
      };
      ipaddr.IPv4.isValid = function(string) {
        var e;
        try {
          new this(this.parser(string));
          return true;
        } catch (error1) {
          e = error1;
          return false;
        }
      };
      ipaddr.IPv4.isValidFourPartDecimal = function(string) {
        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
          return true;
        } else {
          return false;
        }
      };
      ipaddr.IPv6.isValid = function(string) {
        var addr, e;
        if (typeof string === "string" && string.indexOf(":") === -1) {
          return false;
        }
        try {
          addr = this.parser(string);
          new this(addr.parts, addr.zoneId);
          return true;
        } catch (error1) {
          e = error1;
          return false;
        }
      };
      ipaddr.IPv4.parse = function(string) {
        var parts;
        parts = this.parser(string);
        if (parts === null) {
          throw new Error("ipaddr: string is not formatted like ip address");
        }
        return new this(parts);
      };
      ipaddr.IPv6.parse = function(string) {
        var addr;
        addr = this.parser(string);
        if (addr.parts === null) {
          throw new Error("ipaddr: string is not formatted like ip address");
        }
        return new this(addr.parts, addr.zoneId);
      };
      ipaddr.IPv4.parseCIDR = function(string) {
        var maskLength, match, parsed;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 32) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      };
      ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
        var filledOctetCount, j, octets;
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
          throw new Error("ipaddr: invalid IPv4 prefix length");
        }
        octets = [0, 0, 0, 0];
        j = 0;
        filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 4) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
        var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (error1) {
          error = error1;
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv4.networkAddressFromCIDR = function(string) {
        var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (error1) {
          error = error1;
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv6.parseCIDR = function(string) {
        var maskLength, match, parsed;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 128) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      };
      ipaddr.isValid = function(string) {
        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
      };
      ipaddr.parse = function(string) {
        if (ipaddr.IPv6.isValid(string)) {
          return ipaddr.IPv6.parse(string);
        } else if (ipaddr.IPv4.isValid(string)) {
          return ipaddr.IPv4.parse(string);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr.parseCIDR = function(string) {
        var e;
        try {
          return ipaddr.IPv6.parseCIDR(string);
        } catch (error1) {
          e = error1;
          try {
            return ipaddr.IPv4.parseCIDR(string);
          } catch (error12) {
            e = error12;
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
      ipaddr.fromByteArray = function(bytes) {
        var length;
        length = bytes.length;
        if (length === 4) {
          return new ipaddr.IPv4(bytes);
        } else if (length === 16) {
          return new ipaddr.IPv6(bytes);
        } else {
          throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
      };
      ipaddr.process = function(string) {
        var addr;
        addr = this.parse(string);
        if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
    }).call(exports2);
  }
});

// packages/platform-fastify/node_modules/proxy-addr/index.js
var require_proxy_addr = __commonJS({
  "packages/platform-fastify/node_modules/proxy-addr/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = proxyaddr;
    module2.exports.all = alladdrs;
    module2.exports.compile = compile;
    var forwarded = require_forwarded();
    var ipaddr = require_ipaddr();
    var DIGIT_REGEXP = /^[0-9]+$/;
    var isip = ipaddr.isValid;
    var parseip = ipaddr.parse;
    var IP_RANGES = {
      linklocal: ["169.254.0.0/16", "fe80::/10"],
      loopback: ["127.0.0.1/8", "::1/128"],
      uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"]
    };
    function alladdrs(req, trust) {
      var addrs = forwarded(req);
      if (!trust) {
        return addrs;
      }
      if (typeof trust !== "function") {
        trust = compile(trust);
      }
      for (var i = 0; i < addrs.length - 1; i++) {
        if (trust(addrs[i], i))
          continue;
        addrs.length = i + 1;
      }
      return addrs;
    }
    function compile(val) {
      if (!val) {
        throw new TypeError("argument is required");
      }
      var trust;
      if (typeof val === "string") {
        trust = [val];
      } else if (Array.isArray(val)) {
        trust = val.slice();
      } else {
        throw new TypeError("unsupported trust argument");
      }
      for (var i = 0; i < trust.length; i++) {
        val = trust[i];
        if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
          continue;
        }
        val = IP_RANGES[val];
        trust.splice.apply(trust, [i, 1].concat(val));
        i += val.length - 1;
      }
      return compileTrust(compileRangeSubnets(trust));
    }
    function compileRangeSubnets(arr) {
      var rangeSubnets = new Array(arr.length);
      for (var i = 0; i < arr.length; i++) {
        rangeSubnets[i] = parseipNotation(arr[i]);
      }
      return rangeSubnets;
    }
    function compileTrust(rangeSubnets) {
      var len = rangeSubnets.length;
      return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
    }
    function parseipNotation(note) {
      var pos = note.lastIndexOf("/");
      var str = pos !== -1 ? note.substring(0, pos) : note;
      if (!isip(str)) {
        throw new TypeError("invalid IP address: " + str);
      }
      var ip = parseip(str);
      if (pos === -1 && ip.kind() === "ipv6" && ip.isIPv4MappedAddress()) {
        ip = ip.toIPv4Address();
      }
      var max = ip.kind() === "ipv6" ? 128 : 32;
      var range2 = pos !== -1 ? note.substring(pos + 1, note.length) : null;
      if (range2 === null) {
        range2 = max;
      } else if (DIGIT_REGEXP.test(range2)) {
        range2 = parseInt(range2, 10);
      } else if (ip.kind() === "ipv4" && isip(range2)) {
        range2 = parseNetmask(range2);
      } else {
        range2 = null;
      }
      if (range2 <= 0 || range2 > max) {
        throw new TypeError("invalid range on address: " + note);
      }
      return [ip, range2];
    }
    function parseNetmask(netmask) {
      var ip = parseip(netmask);
      var kind = ip.kind();
      return kind === "ipv4" ? ip.prefixLengthFromSubnetMask() : null;
    }
    function proxyaddr(req, trust) {
      if (!req) {
        throw new TypeError("req argument is required");
      }
      if (!trust) {
        throw new TypeError("trust argument is required");
      }
      var addrs = alladdrs(req, trust);
      var addr = addrs[addrs.length - 1];
      return addr;
    }
    function trustNone() {
      return false;
    }
    function trustMulti(subnets) {
      return function trust(addr) {
        if (!isip(addr))
          return false;
        var ip = parseip(addr);
        var ipconv;
        var kind = ip.kind();
        for (var i = 0; i < subnets.length; i++) {
          var subnet = subnets[i];
          var subnetip = subnet[0];
          var subnetkind = subnetip.kind();
          var subnetrange = subnet[1];
          var trusted = ip;
          if (kind !== subnetkind) {
            if (subnetkind === "ipv4" && !ip.isIPv4MappedAddress()) {
              continue;
            }
            if (!ipconv) {
              ipconv = subnetkind === "ipv4" ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
            }
            trusted = ipconv;
          }
          if (trusted.match(subnetip, subnetrange)) {
            return true;
          }
        }
        return false;
      };
    }
    function trustSingle(subnet) {
      var subnetip = subnet[0];
      var subnetkind = subnetip.kind();
      var subnetisipv4 = subnetkind === "ipv4";
      var subnetrange = subnet[1];
      return function trust(addr) {
        if (!isip(addr))
          return false;
        var ip = parseip(addr);
        var kind = ip.kind();
        if (kind !== subnetkind) {
          if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
            return false;
          }
          ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
        }
        return ip.match(subnetip, subnetrange);
      };
    }
  }
});

// packages/platform-fastify/node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "packages/platform-fastify/node_modules/semver/internal/constants.js"(exports2, module2) {
    init_esm_shims();
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    module2.exports = {
      SEMVER_SPEC_VERSION,
      MAX_LENGTH,
      MAX_SAFE_INTEGER,
      MAX_SAFE_COMPONENT_LENGTH
    };
  }
});

// packages/platform-fastify/node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "packages/platform-fastify/node_modules/semver/internal/debug.js"(exports2, module2) {
    init_esm_shims();
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args2) => console.error("SEMVER", ...args2) : () => {
    };
    module2.exports = debug;
  }
});

// packages/platform-fastify/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "packages/platform-fastify/node_modules/semver/internal/re.js"(exports2, module2) {
    init_esm_shims();
    var { MAX_SAFE_COMPONENT_LENGTH } = require_constants();
    var debug = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var src = exports2.src = [];
    var t2 = exports2.t = {};
    var R = 0;
    var createToken = (name, value, isGlobal) => {
      const index2 = R++;
      debug(index2, value);
      t2[name] = index2;
      src[index2] = value;
      re[index2] = new RegExp(value, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
    createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
    createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NUMERICIDENTIFIER]}|${src[t2.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NUMERICIDENTIFIERLOOSE]}|${src[t2.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
    createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`);
    createToken("FULL", `^${src[t2.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`);
    createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t2.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
  }
});

// packages/platform-fastify/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "packages/platform-fastify/node_modules/semver/internal/parse-options.js"(exports2, module2) {
    init_esm_shims();
    var opts = ["includePrerelease", "loose", "rtl"];
    var parseOptions = (options) => !options ? {} : typeof options !== "object" ? { loose: true } : opts.filter((k) => options[k]).reduce((options2, k) => {
      options2[k] = true;
      return options2;
    }, {});
    module2.exports = parseOptions;
  }
});

// packages/platform-fastify/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "packages/platform-fastify/node_modules/semver/internal/identifiers.js"(exports2, module2) {
    init_esm_shims();
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// packages/platform-fastify/node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "packages/platform-fastify/node_modules/semver/classes/semver.js"(exports2, module2) {
    init_esm_shims();
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { re, t: t2 } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t2.LOOSE] : re[t2.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      inc(release, identifier) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier);
            this.inc("pre", identifier);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier);
            }
            this.inc("pre", identifier);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0) {
              this.prerelease = [0];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                this.prerelease.push(0);
              }
            }
            if (identifier) {
              if (this.prerelease[0] === identifier) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = [identifier, 0];
                }
              } else {
                this.prerelease = [identifier, 0];
              }
            }
            break;
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.format();
        this.raw = this.version;
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// packages/platform-fastify/node_modules/semver/functions/parse.js
var require_parse2 = __commonJS({
  "packages/platform-fastify/node_modules/semver/functions/parse.js"(exports2, module2) {
    init_esm_shims();
    var { MAX_LENGTH } = require_constants();
    var { re, t: t2 } = require_re();
    var SemVer = require_semver();
    var parseOptions = require_parse_options();
    var parse = (version, options) => {
      options = parseOptions(options);
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      const r = options.loose ? re[t2.LOOSE] : re[t2.FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    };
    module2.exports = parse;
  }
});

// packages/platform-fastify/node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "packages/platform-fastify/node_modules/semver/functions/valid.js"(exports2, module2) {
    init_esm_shims();
    var parse = require_parse2();
    var valid = (version, options) => {
      const v = parse(version, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// packages/platform-fastify/node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "packages/platform-fastify/node_modules/semver/functions/clean.js"(exports2, module2) {
    init_esm_shims();
    var parse = require_parse2();
    var clean = (version, options) => {
      const s2 = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s2 ? s2.version : null;
    };
    module2.exports = clean;
  }
});

// packages/platform-fastify/node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "packages/platform-fastify/node_modules/semver/functions/inc.js"(exports2, module2) {
    init_esm_shims();
    var SemVer = require_semver();
    var inc = (version, release, options, identifier) => {
      if (typeof options === "string") {
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(version, options).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// packages/platform-fastify/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "packages/platform-fastify/node_modules/semver/functions/compare.js"(exports2, module2) {
    init_esm_shims();
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// packages/platform-fastify/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "packages/platform-fastify/node_modules/semver/functions/eq.js"(exports2, module2) {
    init_esm_shims();
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// packages/platform-fastify/node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "packages/platform-fastify/node_modules/semver/functions/diff.js"(exports2, module2) {
    init_esm_shims();
    var parse = require_parse2();
    var eq = require_eq();
    var diff = (version1, version2) => {
      if (eq(version1, version2)) {
        return null;
      } else {
        const v1 = parse(version1);
        const v2 = parse(version2);
        const hasPre = v1.prerelease.length || v2.prerelease.length;
        const prefix = hasPre ? "pre" : "";
        const defaultResult = hasPre ? "prerelease" : "";
        for (const key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    };
    module2.exports = diff;
  }
});

// packages/platform-fastify/node_modules/semver/functions/major.js
var require_major = __commonJS({
  "packages/platform-fastify/node_modules/semver/functions/major.js"(exports2, module2) {
    init_esm_shims();
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// packages/platform-fastify/node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "packages/platform-fastify/node_modules/semver/functions/minor.js"(exports2, module2) {
    init_esm_shims();
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// packages/platform-fastify/node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "packages/platform-fastify/node_modules/semver/functions/patch.js"(exports2, module2) {
    init_esm_shims();
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// packages/platform-fastify/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "packages/platform-fastify/node_modules/semver/functions/prerelease.js"(exports2, module2) {
    init_esm_shims();
    var parse = require_parse2();
    var prerelease = (version, options) => {
      const parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// packages/platform-fastify/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "packages/platform-fastify/node_modules/semver/functions/rcompare.js"(exports2, module2) {
    init_esm_shims();
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// packages/platform-fastify/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "packages/platform-fastify/node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    init_esm_shims();
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// packages/platform-fastify/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "packages/platform-fastify/node_modules/semver/functions/compare-build.js"(exports2, module2) {
    init_esm_shims();
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// packages/platform-fastify/node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "packages/platform-fastify/node_modules/semver/functions/sort.js"(exports2, module2) {
    init_esm_shims();
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// packages/platform-fastify/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "packages/platform-fastify/node_modules/semver/functions/rsort.js"(exports2, module2) {
    init_esm_shims();
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// packages/platform-fastify/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "packages/platform-fastify/node_modules/semver/functions/gt.js"(exports2, module2) {
    init_esm_shims();
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// packages/platform-fastify/node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "packages/platform-fastify/node_modules/semver/functions/lt.js"(exports2, module2) {
    init_esm_shims();
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// packages/platform-fastify/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "packages/platform-fastify/node_modules/semver/functions/neq.js"(exports2, module2) {
    init_esm_shims();
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// packages/platform-fastify/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "packages/platform-fastify/node_modules/semver/functions/gte.js"(exports2, module2) {
    init_esm_shims();
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// packages/platform-fastify/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "packages/platform-fastify/node_modules/semver/functions/lte.js"(exports2, module2) {
    init_esm_shims();
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// packages/platform-fastify/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "packages/platform-fastify/node_modules/semver/functions/cmp.js"(exports2, module2) {
    init_esm_shims();
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// packages/platform-fastify/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "packages/platform-fastify/node_modules/semver/functions/coerce.js"(exports2, module2) {
    init_esm_shims();
    var SemVer = require_semver();
    var parse = require_parse2();
    var { re, t: t2 } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(re[t2.COERCE]);
      } else {
        let next;
        while ((next = re[t2.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t2.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t2.COERCERTL].lastIndex = -1;
      }
      if (match === null)
        return null;
      return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
    };
    module2.exports = coerce;
  }
});

// packages/platform-fastify/node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "packages/platform-fastify/node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// packages/platform-fastify/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "packages/platform-fastify/node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self = this;
      if (!(self instanceof Yallist)) {
        self = new Yallist();
      }
      self.tail = null;
      self.head = null;
      self.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self.push(arguments[i]);
        }
      }
      return self;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn2, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn2.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn2, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn2.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn2, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn2.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn2, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn2.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn2, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn2(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn2, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn2(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self, node, value) {
      var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);
      if (inserted.next === null) {
        self.tail = inserted;
      }
      if (inserted.prev === null) {
        self.head = inserted;
      }
      self.length++;
      return inserted;
    }
    function push(self, item) {
      self.tail = new Node(item, self.tail, null, self);
      if (!self.head) {
        self.head = self.tail;
      }
      self.length++;
    }
    function unshift(self, item) {
      self.head = new Node(item, null, self.head, self);
      if (!self.tail) {
        self.tail = self.head;
      }
      self.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// packages/platform-fastify/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "packages/platform-fastify/node_modules/lru-cache/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn2, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn2, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn2, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn2, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self, key, doUse) => {
      const node = self[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self, hit)) {
          del(self, node);
          if (!self[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self, hit) => {
      if (!hit || !hit.maxAge && !self[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
    };
    var trim = (self) => {
      if (self[LENGTH] > self[MAX]) {
        for (let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self, walker);
          walker = prev;
        }
      }
    };
    var del = (self, node) => {
      if (node) {
        const hit = node.value;
        if (self[DISPOSE])
          self[DISPOSE](hit.key, hit.value);
        self[LENGTH] -= hit.length;
        self[CACHE].delete(hit.key);
        self[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self, fn2, node, thisp) => {
      let hit = node.value;
      if (isStale(self, hit)) {
        del(self, node);
        if (!self[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn2.call(thisp, hit.value, hit.key, self);
    };
    module2.exports = LRUCache;
  }
});

// packages/platform-fastify/node_modules/semver/classes/range.js
var require_range = __commonJS({
  "packages/platform-fastify/node_modules/semver/classes/range.js"(exports2, module2) {
    init_esm_shims();
    var Range = class {
      constructor(range2, options) {
        options = parseOptions(options);
        if (range2 instanceof Range) {
          if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
            return range2;
          } else {
            return new Range(range2.raw, options);
          }
        }
        if (range2 instanceof Comparator) {
          this.raw = range2.value;
          this.set = [[range2]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range2;
        this.set = range2.split(/\s*\|\|\s*/).map((range3) => this.parseRange(range3.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${range2}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0)
            this.set = [first];
          else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => {
          return comps.join(" ").trim();
        }).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range2) {
        range2 = range2.trim();
        const memoOpts = Object.keys(this.options).join(",");
        const memoKey = `parseRange:${memoOpts}:${range2}`;
        const cached = cache.get(memoKey);
        if (cached)
          return cached;
        const loose = this.options.loose;
        const hr = loose ? re[t2.HYPHENRANGELOOSE] : re[t2.HYPHENRANGE];
        range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range2);
        range2 = range2.replace(re[t2.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range2, re[t2.COMPARATORTRIM]);
        range2 = range2.replace(re[t2.TILDETRIM], tildeTrimReplace);
        range2 = range2.replace(re[t2.CARETTRIM], caretTrimReplace);
        range2 = range2.split(/\s+/).join(" ");
        const compRe = loose ? re[t2.COMPARATORLOOSE] : re[t2.COMPARATOR];
        const rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator(comp, this.options));
        const l = rangeList.length;
        const rangeMap = /* @__PURE__ */ new Map();
        for (const comp of rangeList) {
          if (isNullSet(comp))
            return [comp];
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has(""))
          rangeMap.delete("");
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range2, options) {
        if (!(range2 instanceof Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lru_cache();
    var cache = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      re,
      t: t2,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
      return replaceTilde(comp2, options);
    }).join(" ");
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t2.TILDELOOSE] : re[t2.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
      return replaceCaret(comp2, options);
    }).join(" ");
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t2.CARETLOOSE] : re[t2.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((comp2) => {
        return replaceXRange(comp2, options);
      }).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t2.XRANGELOOSE] : re[t2.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<")
            pr = "-0";
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t2.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t2.GTE0PRE : t2.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// packages/platform-fastify/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "packages/platform-fastify/node_modules/semver/classes/comparator.js"(exports2, module2) {
    init_esm_shims();
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t2.COMPARATORLOOSE] : re[t2.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (!options || typeof options !== "object") {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
        const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
        const sameSemVer = this.semver.version === comp.semver.version;
        const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
        const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
        const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
        return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { re, t: t2 } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// packages/platform-fastify/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "packages/platform-fastify/node_modules/semver/functions/satisfies.js"(exports2, module2) {
    init_esm_shims();
    var Range = require_range();
    var satisfies = (version, range2, options) => {
      try {
        range2 = new Range(range2, options);
      } catch (er) {
        return false;
      }
      return range2.test(version);
    };
    module2.exports = satisfies;
  }
});

// packages/platform-fastify/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "packages/platform-fastify/node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    init_esm_shims();
    var Range = require_range();
    var toComparators = (range2, options) => new Range(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// packages/platform-fastify/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "packages/platform-fastify/node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    init_esm_shims();
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range2, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range2, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// packages/platform-fastify/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "packages/platform-fastify/node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    init_esm_shims();
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range2, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range2, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// packages/platform-fastify/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "packages/platform-fastify/node_modules/semver/ranges/min-version.js"(exports2, module2) {
    init_esm_shims();
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range2, loose) => {
      range2 = new Range(range2, loose);
      let minver = new SemVer("0.0.0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range2.set.length; ++i) {
        const comparators = range2.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin)))
          minver = setMin;
      }
      if (minver && range2.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// packages/platform-fastify/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "packages/platform-fastify/node_modules/semver/ranges/valid.js"(exports2, module2) {
    init_esm_shims();
    var Range = require_range();
    var validRange = (range2, options) => {
      try {
        return new Range(range2, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// packages/platform-fastify/node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "packages/platform-fastify/node_modules/semver/ranges/outside.js"(exports2, module2) {
    init_esm_shims();
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range2, hilo, options) => {
      version = new SemVer(version, options);
      range2 = new Range(range2, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range2, options)) {
        return false;
      }
      for (let i = 0; i < range2.set.length; ++i) {
        const comparators = range2.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// packages/platform-fastify/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "packages/platform-fastify/node_modules/semver/ranges/gtr.js"(exports2, module2) {
    init_esm_shims();
    var outside = require_outside();
    var gtr = (version, range2, options) => outside(version, range2, ">", options);
    module2.exports = gtr;
  }
});

// packages/platform-fastify/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "packages/platform-fastify/node_modules/semver/ranges/ltr.js"(exports2, module2) {
    init_esm_shims();
    var outside = require_outside();
    var ltr = (version, range2, options) => outside(version, range2, "<", options);
    module2.exports = ltr;
  }
});

// packages/platform-fastify/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "packages/platform-fastify/node_modules/semver/ranges/intersects.js"(exports2, module2) {
    init_esm_shims();
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    };
    module2.exports = intersects;
  }
});

// packages/platform-fastify/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "packages/platform-fastify/node_modules/semver/ranges/simplify.js"(exports2, module2) {
    init_esm_shims();
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range2, options) => {
      const set = [];
      let min = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version of v) {
        const included = satisfies(version, range2, options);
        if (included) {
          prev = version;
          if (!min)
            min = version;
        } else {
          if (prev) {
            set.push([min, prev]);
          }
          prev = null;
          min = null;
        }
      }
      if (min)
        set.push([min, null]);
      const ranges = [];
      for (const [min2, max] of set) {
        if (min2 === max)
          ranges.push(min2);
        else if (!max && min2 === v[0])
          ranges.push("*");
        else if (!max)
          ranges.push(`>=${min2}`);
        else if (min2 === v[0])
          ranges.push(`<=${max}`);
        else
          ranges.push(`${min2} - ${max}`);
      }
      const simplified = ranges.join(" || ");
      const original = typeof range2.raw === "string" ? range2.raw : String(range2);
      return simplified.length < original.length ? simplified : range2;
    };
  }
});

// packages/platform-fastify/node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "packages/platform-fastify/node_modules/semver/ranges/subset.js"(exports2, module2) {
    init_esm_shims();
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom)
        return true;
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub)
              continue OUTER;
          }
          if (sawNonNull)
            return false;
        }
      return true;
    };
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom)
        return true;
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY)
          return true;
        else if (options.includePrerelease)
          sub = [new Comparator(">=0.0.0-0")];
        else
          sub = [new Comparator(">=0.0.0")];
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease)
          return true;
        else
          dom = [new Comparator(">=0.0.0")];
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=")
          gt = higherGT(gt, c, options);
        else if (c.operator === "<" || c.operator === "<=")
          lt = lowerLT(lt, c, options);
        else
          eqSet.add(c.semver);
      }
      if (eqSet.size > 1)
        return null;
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0)
          return null;
        else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<="))
          return null;
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options))
          return null;
        if (lt && !satisfies(eq, String(lt), options))
          return null;
        for (const c of dom) {
          if (!satisfies(eq, String(c), options))
            return false;
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt)
              return false;
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options))
            return false;
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt)
              return false;
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options))
            return false;
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0)
          return false;
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0)
        return false;
      if (lt && hasDomGT && !gt && gtltComp !== 0)
        return false;
      if (needDomGTPre || needDomLTPre)
        return false;
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a)
        return b;
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a)
        return b;
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// packages/platform-fastify/node_modules/semver/index.js
var require_semver2 = __commonJS({
  "packages/platform-fastify/node_modules/semver/index.js"(exports2, module2) {
    init_esm_shims();
    var internalRe = require_re();
    module2.exports = {
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: require_constants().SEMVER_SPEC_VERSION,
      SemVer: require_semver(),
      compareIdentifiers: require_identifiers().compareIdentifiers,
      rcompareIdentifiers: require_identifiers().rcompareIdentifiers,
      parse: require_parse2(),
      valid: require_valid(),
      clean: require_clean(),
      inc: require_inc(),
      diff: require_diff(),
      major: require_major(),
      minor: require_minor(),
      patch: require_patch(),
      prerelease: require_prerelease(),
      compare: require_compare(),
      rcompare: require_rcompare(),
      compareLoose: require_compare_loose(),
      compareBuild: require_compare_build(),
      sort: require_sort(),
      rsort: require_rsort(),
      gt: require_gt(),
      lt: require_lt(),
      eq: require_eq(),
      neq: require_neq(),
      gte: require_gte(),
      lte: require_lte(),
      cmp: require_cmp(),
      coerce: require_coerce(),
      Comparator: require_comparator(),
      Range: require_range(),
      satisfies: require_satisfies(),
      toComparators: require_to_comparators(),
      maxSatisfying: require_max_satisfying(),
      minSatisfying: require_min_satisfying(),
      minVersion: require_min_version(),
      validRange: require_valid2(),
      outside: require_outside(),
      gtr: require_gtr(),
      ltr: require_ltr(),
      intersects: require_intersects(),
      simplifyRange: require_simplify(),
      subset: require_subset()
    };
  }
});

// packages/platform-fastify/node_modules/fastify/lib/request.js
var require_request = __commonJS({
  "packages/platform-fastify/node_modules/fastify/lib/request.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var proxyAddr = require_proxy_addr();
    var semver = require_semver2();
    var warning = require_warnings();
    function Request2(id, params, req, query, log3, context) {
      this.id = id;
      this.context = context;
      this.params = params;
      this.raw = req;
      this.query = query;
      this.log = log3;
      this.body = null;
    }
    Request2.props = [];
    function getTrustProxyFn(tp) {
      if (typeof tp === "function") {
        return tp;
      }
      if (tp === true) {
        return function() {
          return true;
        };
      }
      if (typeof tp === "number") {
        return function(a, i) {
          return i < tp;
        };
      }
      if (typeof tp === "string") {
        const vals = tp.split(",").map((it) => it.trim());
        return proxyAddr.compile(vals);
      }
      return proxyAddr.compile(tp);
    }
    function buildRequest(R, trustProxy) {
      if (trustProxy) {
        return buildRequestWithTrustProxy(R, trustProxy);
      }
      return buildRegularRequest(R);
    }
    function buildRegularRequest(R) {
      const props = [...R.props];
      function _Request(id, params, req, query, log3, context) {
        this.id = id;
        this.context = context;
        this.params = params;
        this.raw = req;
        this.query = query;
        this.log = log3;
        this.body = null;
        var prop;
        for (var i = 0; i < props.length; i++) {
          prop = props[i];
          this[prop.key] = prop.value;
        }
      }
      _Request.prototype = new R();
      _Request.props = props;
      return _Request;
    }
    function getLastEntryInMultiHeaderValue(headerValue) {
      const lastIndex = headerValue.lastIndexOf(",");
      return lastIndex === -1 ? headerValue.trim() : headerValue.slice(lastIndex + 1).trim();
    }
    function buildRequestWithTrustProxy(R, trustProxy) {
      const _Request = buildRegularRequest(R);
      const proxyFn = getTrustProxyFn(trustProxy);
      Object.defineProperties(_Request.prototype, {
        ip: {
          get() {
            return proxyAddr(this.raw, proxyFn);
          }
        },
        ips: {
          get() {
            return proxyAddr.all(this.raw, proxyFn);
          }
        },
        hostname: {
          get() {
            if (this.ip !== void 0 && this.headers["x-forwarded-host"]) {
              return getLastEntryInMultiHeaderValue(this.headers["x-forwarded-host"]);
            }
            return this.headers.host || this.headers[":authority"];
          }
        },
        protocol: {
          get() {
            if (this.headers["x-forwarded-proto"]) {
              return getLastEntryInMultiHeaderValue(this.headers["x-forwarded-proto"]);
            }
            if (this.socket) {
              return this.socket.encrypted ? "https" : "http";
            }
          }
        }
      });
      return _Request;
    }
    Object.defineProperties(Request2.prototype, {
      req: {
        get() {
          warning.emit("FSTDEP001");
          return this.raw;
        }
      },
      url: {
        get() {
          return this.raw.url;
        }
      },
      method: {
        get() {
          return this.raw.method;
        }
      },
      routerPath: {
        get() {
          return this.context.config.url;
        }
      },
      routerMethod: {
        get() {
          return this.context.config.method;
        }
      },
      is404: {
        get() {
          return this.context.config.url === void 0;
        }
      },
      connection: {
        get() {
          if (semver.gte(process.versions.node, "13.0.0")) {
            warning.emit("FSTDEP005");
          }
          return this.raw.connection;
        }
      },
      socket: {
        get() {
          return this.raw.socket;
        }
      },
      ip: {
        get() {
          if (this.socket) {
            return this.socket.remoteAddress;
          }
        }
      },
      hostname: {
        get() {
          return this.raw.headers.host || this.raw.headers[":authority"];
        }
      },
      protocol: {
        get() {
          if (this.socket) {
            return this.socket.encrypted ? "https" : "http";
          }
        }
      },
      headers: {
        get() {
          if (this.additionalHeaders) {
            return Object.assign({}, this.raw.headers, this.additionalHeaders);
          }
          return this.raw.headers;
        },
        set(headers) {
          this.additionalHeaders = headers;
        }
      },
      server: {
        value: null,
        writable: true
      }
    });
    module2.exports = Request2;
    module2.exports.buildRequest = buildRequest;
  }
});

// packages/platform-fastify/node_modules/fastify/lib/decorate.js
var require_decorate = __commonJS({
  "packages/platform-fastify/node_modules/fastify/lib/decorate.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var {
      kReply,
      kRequest,
      kState
    } = require_symbols();
    var {
      FST_ERR_DEC_ALREADY_PRESENT,
      FST_ERR_DEC_MISSING_DEPENDENCY,
      FST_ERR_DEC_AFTER_START,
      FST_ERR_DEC_DEPENDENCY_INVALID_TYPE
    } = require_errors();
    var warning = require_warnings();
    function decorate(instance, name, fn2, dependencies) {
      if (instance.hasOwnProperty(name)) {
        throw new FST_ERR_DEC_ALREADY_PRESENT(name);
      }
      checkDependencies(instance, name, dependencies);
      if (fn2 && (typeof fn2.getter === "function" || typeof fn2.setter === "function")) {
        Object.defineProperty(instance, name, {
          get: fn2.getter,
          set: fn2.setter
        });
      } else {
        instance[name] = fn2;
      }
    }
    function decorateConstructor(konstructor, name, fn2, dependencies) {
      const instance = konstructor.prototype;
      if (instance.hasOwnProperty(name) || hasKey(konstructor, name)) {
        throw new FST_ERR_DEC_ALREADY_PRESENT(name);
      }
      checkDependencies(konstructor, name, dependencies);
      if (fn2 && (typeof fn2.getter === "function" || typeof fn2.setter === "function")) {
        Object.defineProperty(instance, name, {
          get: fn2.getter,
          set: fn2.setter
        });
      } else if (typeof fn2 === "function") {
        instance[name] = fn2;
      } else {
        konstructor.props.push({ key: name, value: fn2 });
      }
    }
    function checkReferenceType(name, fn2) {
      if (typeof fn2 === "object" && fn2 && !(typeof fn2.getter === "function" || typeof fn2.setter === "function")) {
        warning.emit("FSTDEP006", name);
      }
    }
    function decorateFastify(name, fn2, dependencies) {
      assertNotStarted(this, name);
      decorate(this, name, fn2, dependencies);
      return this;
    }
    function checkExistence(instance, name) {
      if (name) {
        return name in instance || instance.prototype && name in instance.prototype || hasKey(instance, name);
      }
      return instance in this;
    }
    function hasKey(fn2, name) {
      if (fn2.props) {
        return fn2.props.find(({ key }) => key === name);
      }
      return false;
    }
    function checkRequestExistence(name) {
      if (name && hasKey(this[kRequest], name))
        return true;
      return checkExistence(this[kRequest].prototype, name);
    }
    function checkReplyExistence(name) {
      if (name && hasKey(this[kReply], name))
        return true;
      return checkExistence(this[kReply].prototype, name);
    }
    function checkDependencies(instance, name, deps) {
      if (deps === void 0 || deps === null) {
        return;
      }
      if (!Array.isArray(deps)) {
        throw new FST_ERR_DEC_DEPENDENCY_INVALID_TYPE(name);
      }
      for (var i = 0; i !== deps.length; ++i) {
        if (!checkExistence(instance, deps[i])) {
          throw new FST_ERR_DEC_MISSING_DEPENDENCY(deps[i]);
        }
      }
    }
    function decorateReply(name, fn2, dependencies) {
      assertNotStarted(this, name);
      checkReferenceType(name, fn2);
      decorateConstructor(this[kReply], name, fn2, dependencies);
      return this;
    }
    function decorateRequest(name, fn2, dependencies) {
      assertNotStarted(this, name);
      checkReferenceType(name, fn2);
      decorateConstructor(this[kRequest], name, fn2, dependencies);
      return this;
    }
    function assertNotStarted(instance, name) {
      if (instance[kState].started) {
        throw new FST_ERR_DEC_AFTER_START(name);
      }
    }
    module2.exports = {
      add: decorateFastify,
      exist: checkExistence,
      existRequest: checkRequestExistence,
      existReply: checkReplyExistence,
      dependencies: checkDependencies,
      decorateReply,
      decorateRequest
    };
  }
});

// packages/platform-fastify/node_modules/tiny-lru/lib/tiny-lru.esm.js
var tiny_lru_esm_exports = {};
__export(tiny_lru_esm_exports, {
  default: () => s
});
function s(s2 = 1e3, i = 0) {
  if (isNaN(s2) || s2 < 0)
    throw new TypeError("Invalid max value");
  if (isNaN(i) || i < 0)
    throw new TypeError("Invalid ttl value");
  return new t(s2, i);
}
var t;
var init_tiny_lru_esm = __esm({
  "packages/platform-fastify/node_modules/tiny-lru/lib/tiny-lru.esm.js"() {
    init_esm_shims();
    t = class {
      constructor(t2 = 0, s2 = 0) {
        this.first = null, this.items = /* @__PURE__ */ Object.create(null), this.last = null, this.max = t2, this.size = 0, this.ttl = s2;
      }
      has(t2) {
        return t2 in this.items;
      }
      clear() {
        return this.first = null, this.items = /* @__PURE__ */ Object.create(null), this.last = null, this.size = 0, this;
      }
      delete(t2) {
        if (this.has(t2)) {
          const s2 = this.items[t2];
          delete this.items[t2], this.size--, s2.prev !== null && (s2.prev.next = s2.next), s2.next !== null && (s2.next.prev = s2.prev), this.first === s2 && (this.first = s2.next), this.last === s2 && (this.last = s2.prev);
        }
        return this;
      }
      evict(t2 = false) {
        if (t2 || this.size > 0) {
          const t3 = this.first;
          delete this.items[t3.key], this.size--, this.size === 0 ? (this.first = null, this.last = null) : (this.first = t3.next, this.first.prev = null);
        }
        return this;
      }
      get(t2) {
        let s2;
        if (this.has(t2)) {
          const i = this.items[t2];
          this.ttl > 0 && i.expiry <= new Date().getTime() ? this.delete(t2) : (s2 = i.value, this.set(t2, s2, true));
        }
        return s2;
      }
      keys() {
        return Object.keys(this.items);
      }
      set(t2, s2, i = false) {
        let e;
        if (i || this.has(t2)) {
          if (e = this.items[t2], e.value = s2, this.last !== e) {
            const t3 = this.last, s3 = e.next, i2 = e.prev;
            this.first === e && (this.first = e.next), e.next = null, e.prev = this.last, t3.next = e, i2 !== null && (i2.next = s3), s3 !== null && (s3.prev = i2);
          }
        } else
          this.max > 0 && this.size === this.max && this.evict(true), e = this.items[t2] = { expiry: this.ttl > 0 ? new Date().getTime() + this.ttl : this.ttl, key: t2, prev: this.last, next: null, value: s2 }, ++this.size == 1 ? this.first = e : this.last.next = e;
        return this.last = e, this;
      }
    };
  }
});

// packages/platform-fastify/node_modules/secure-json-parse/index.js
var require_secure_json_parse = __commonJS({
  "packages/platform-fastify/node_modules/secure-json-parse/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var hasBuffer = typeof Buffer !== "undefined";
    var suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
    var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
    function parse(text, reviver, options) {
      if (options == null) {
        if (reviver !== null && typeof reviver === "object") {
          options = reviver;
          reviver = void 0;
        } else {
          options = {};
        }
      }
      const protoAction = options.protoAction || "error";
      const constructorAction = options.constructorAction || "error";
      if (hasBuffer && Buffer.isBuffer(text)) {
        text = text.toString();
      }
      if (text && text.charCodeAt(0) === 65279) {
        text = text.slice(1);
      }
      const obj = JSON.parse(text, reviver);
      if (protoAction === "ignore" && constructorAction === "ignore") {
        return obj;
      }
      if (obj === null || typeof obj !== "object") {
        return obj;
      }
      if (protoAction !== "ignore" && constructorAction !== "ignore") {
        if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
          return obj;
        }
      } else if (protoAction !== "ignore" && constructorAction === "ignore") {
        if (suspectProtoRx.test(text) === false) {
          return obj;
        }
      } else {
        if (suspectConstructorRx.test(text) === false) {
          return obj;
        }
      }
      scan(obj, { protoAction, constructorAction });
      return obj;
    }
    function scan(obj, { protoAction = "error", constructorAction = "error" } = {}) {
      let next = [obj];
      while (next.length) {
        const nodes = next;
        next = [];
        for (const node of nodes) {
          if (protoAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "__proto__")) {
            if (protoAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.__proto__;
          }
          if (constructorAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
            if (constructorAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.constructor;
          }
          for (const key in node) {
            const value = node[key];
            if (value && typeof value === "object") {
              next.push(node[key]);
            }
          }
        }
      }
    }
    function safeParse(text, reviver) {
      try {
        return parse(text, reviver);
      } catch (ignoreError) {
        return null;
      }
    }
    module2.exports = {
      parse,
      scan,
      safeParse
    };
  }
});

// packages/platform-fastify/node_modules/fastify/lib/contentTypeParser.js
var require_contentTypeParser = __commonJS({
  "packages/platform-fastify/node_modules/fastify/lib/contentTypeParser.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var { AsyncResource } = __require("async_hooks");
    var lru = (init_tiny_lru_esm(), __toCommonJS(tiny_lru_esm_exports));
    lru = typeof lru === "function" ? lru : lru.default;
    var secureJson = require_secure_json_parse();
    var {
      kDefaultJsonParse,
      kContentTypeParser,
      kBodyLimit,
      kRequestPayloadStream,
      kState,
      kTestInternals
    } = require_symbols();
    var {
      FST_ERR_CTP_INVALID_TYPE,
      FST_ERR_CTP_EMPTY_TYPE,
      FST_ERR_CTP_ALREADY_PRESENT,
      FST_ERR_CTP_INVALID_HANDLER,
      FST_ERR_CTP_INVALID_PARSE_TYPE,
      FST_ERR_CTP_BODY_TOO_LARGE,
      FST_ERR_CTP_INVALID_MEDIA_TYPE,
      FST_ERR_CTP_INVALID_CONTENT_LENGTH,
      FST_ERR_CTP_EMPTY_JSON_BODY
    } = require_errors();
    var warning = require_warnings();
    function ContentTypeParser(bodyLimit, onProtoPoisoning, onConstructorPoisoning) {
      this[kDefaultJsonParse] = getDefaultJsonParser(onProtoPoisoning, onConstructorPoisoning);
      this.customParsers = {};
      this.customParsers["application/json"] = new Parser(true, false, bodyLimit, this[kDefaultJsonParse]);
      this.customParsers["text/plain"] = new Parser(true, false, bodyLimit, defaultPlainTextParser);
      this.parserList = ["application/json", "text/plain"];
      this.parserRegExpList = [];
      this.cache = lru(100);
    }
    ContentTypeParser.prototype.add = function(contentType, opts, parserFn) {
      const contentTypeIsString = typeof contentType === "string";
      if (!contentTypeIsString && !(contentType instanceof RegExp))
        throw new FST_ERR_CTP_INVALID_TYPE();
      if (contentTypeIsString && contentType.length === 0)
        throw new FST_ERR_CTP_EMPTY_TYPE();
      if (typeof parserFn !== "function")
        throw new FST_ERR_CTP_INVALID_HANDLER();
      if (this.existingParser(contentType)) {
        throw new FST_ERR_CTP_ALREADY_PRESENT(contentType);
      }
      if (opts.parseAs !== void 0) {
        if (opts.parseAs !== "string" && opts.parseAs !== "buffer") {
          throw new FST_ERR_CTP_INVALID_PARSE_TYPE(opts.parseAs);
        }
      }
      const parser = new Parser(opts.parseAs === "string", opts.parseAs === "buffer", opts.bodyLimit, parserFn);
      if (contentTypeIsString && contentType === "*") {
        this.customParsers[""] = parser;
      } else {
        if (contentTypeIsString) {
          this.parserList.unshift(contentType);
        } else {
          this.parserRegExpList.unshift(contentType);
        }
        this.customParsers[contentType] = parser;
      }
    };
    ContentTypeParser.prototype.hasParser = function(contentType) {
      return contentType in this.customParsers;
    };
    ContentTypeParser.prototype.existingParser = function(contentType) {
      if (contentType === "application/json") {
        return this.customParsers["application/json"] && this.customParsers["application/json"].fn !== this[kDefaultJsonParse];
      }
      if (contentType === "text/plain") {
        return this.customParsers["text/plain"] && this.customParsers["text/plain"].fn !== defaultPlainTextParser;
      }
      return contentType in this.customParsers;
    };
    ContentTypeParser.prototype.getParser = function(contentType) {
      for (var i = 0; i !== this.parserList.length; ++i) {
        const parserName = this.parserList[i];
        if (contentType.indexOf(parserName) > -1) {
          const parser = this.customParsers[parserName];
          this.cache.set(contentType, parser);
          return parser;
        }
      }
      for (var j = 0; j !== this.parserRegExpList.length; ++j) {
        const parserRegExp = this.parserRegExpList[j];
        if (parserRegExp.test(contentType)) {
          const parser = this.customParsers[parserRegExp];
          this.cache.set(contentType, parser);
          return parser;
        }
      }
      return this.customParsers[""];
    };
    ContentTypeParser.prototype.removeAll = function() {
      this.customParsers = {};
      this.parserRegExpList = [];
      this.parserList = [];
      this.cache = lru(100);
    };
    ContentTypeParser.prototype.remove = function(contentType) {
      if (!(typeof contentType === "string" || contentType instanceof RegExp))
        throw new FST_ERR_CTP_INVALID_TYPE();
      delete this.customParsers[contentType];
      const parsers = typeof contentType === "string" ? this.parserList : this.parserRegExpList;
      const idx = parsers.findIndex((ct) => ct.toString() === contentType.toString());
      if (idx > -1) {
        parsers.splice(idx, 1);
      }
    };
    ContentTypeParser.prototype.run = function(contentType, handler, request, reply) {
      const parser = this.cache.get(contentType) || this.getParser(contentType);
      const resource = new AsyncResource("content-type-parser:run", request);
      if (parser === void 0) {
        reply.send(new FST_ERR_CTP_INVALID_MEDIA_TYPE(contentType));
      } else if (parser.asString === true || parser.asBuffer === true) {
        rawBody(request, reply, reply.context._parserOptions, parser, done);
      } else {
        let result;
        if (parser.isDeprecatedSignature) {
          result = parser.fn(request[kRequestPayloadStream], done);
        } else {
          result = parser.fn(request, request[kRequestPayloadStream], done);
        }
        if (result && typeof result.then === "function") {
          result.then((body) => done(null, body), done);
        }
      }
      function done(error, body) {
        resource.runInAsyncScope(() => {
          if (error) {
            reply.send(error);
          } else {
            request.body = body;
            handler(request, reply);
          }
        });
      }
    };
    function rawBody(request, reply, options, parser, done) {
      const asString = parser.asString;
      const limit = options.limit === null ? parser.bodyLimit : options.limit;
      const contentLength = request.headers["content-length"] === void 0 ? NaN : Number.parseInt(request.headers["content-length"], 10);
      if (contentLength > limit) {
        reply.send(new FST_ERR_CTP_BODY_TOO_LARGE());
        return;
      }
      let receivedLength = 0;
      let body = asString === true ? "" : [];
      const payload = request[kRequestPayloadStream] || request.raw;
      if (asString === true) {
        payload.setEncoding("utf8");
      }
      payload.on("data", onData);
      payload.on("end", onEnd);
      payload.on("error", onEnd);
      payload.resume();
      function onData(chunk) {
        receivedLength += chunk.length;
        if ((payload.receivedEncodedLength || receivedLength) > limit) {
          payload.removeListener("data", onData);
          payload.removeListener("end", onEnd);
          payload.removeListener("error", onEnd);
          reply.send(new FST_ERR_CTP_BODY_TOO_LARGE());
          return;
        }
        if (asString === true) {
          body += chunk;
        } else {
          body.push(chunk);
        }
      }
      function onEnd(err) {
        payload.removeListener("data", onData);
        payload.removeListener("end", onEnd);
        payload.removeListener("error", onEnd);
        if (err !== void 0) {
          err.statusCode = 400;
          reply.code(err.statusCode).send(err);
          return;
        }
        if (asString === true) {
          receivedLength = Buffer.byteLength(body);
        }
        if (!Number.isNaN(contentLength) && (payload.receivedEncodedLength || receivedLength) !== contentLength) {
          reply.send(new FST_ERR_CTP_INVALID_CONTENT_LENGTH());
          return;
        }
        if (asString === false) {
          body = Buffer.concat(body);
        }
        const result = parser.fn(request, body, done);
        if (result && typeof result.then === "function") {
          result.then((body2) => done(null, body2), done);
        }
      }
    }
    function getDefaultJsonParser(onProtoPoisoning, onConstructorPoisoning) {
      return defaultJsonParser;
      function defaultJsonParser(req, body, done) {
        if (body === "" || body == null) {
          return done(new FST_ERR_CTP_EMPTY_JSON_BODY(), void 0);
        }
        let json;
        try {
          json = secureJson.parse(body, { protoAction: onProtoPoisoning, constructorAction: onConstructorPoisoning });
        } catch (err) {
          err.statusCode = 400;
          return done(err, void 0);
        }
        done(null, json);
      }
    }
    function defaultPlainTextParser(req, body, done) {
      done(null, body);
    }
    function Parser(asString, asBuffer, bodyLimit, fn2) {
      this.asString = asString;
      this.asBuffer = asBuffer;
      this.bodyLimit = bodyLimit;
      this.fn = fn2;
      if (fn2.length === (fn2.constructor.name === "AsyncFunction" ? 1 : 2)) {
        warning.emit("FSTDEP003");
        this.isDeprecatedSignature = true;
      }
    }
    function buildContentTypeParser(c) {
      const contentTypeParser = new ContentTypeParser();
      contentTypeParser[kDefaultJsonParse] = c[kDefaultJsonParse];
      Object.assign(contentTypeParser.customParsers, c.customParsers);
      contentTypeParser.parserList = c.parserList.slice();
      return contentTypeParser;
    }
    function addContentTypeParser(contentType, opts, parser) {
      if (this[kState].started) {
        throw new Error('Cannot call "addContentTypeParser" when fastify instance is already started!');
      }
      if (typeof opts === "function") {
        parser = opts;
        opts = {};
      }
      if (!opts)
        opts = {};
      if (!opts.bodyLimit)
        opts.bodyLimit = this[kBodyLimit];
      if (Array.isArray(contentType)) {
        contentType.forEach((type) => this[kContentTypeParser].add(type, opts, parser));
      } else {
        this[kContentTypeParser].add(contentType, opts, parser);
      }
      return this;
    }
    function hasContentTypeParser(contentType) {
      return this[kContentTypeParser].hasParser(contentType);
    }
    function removeContentTypeParser(contentType) {
      if (this[kState].started) {
        throw new Error('Cannot call "removeContentTypeParser" when fastify instance is already started!');
      }
      if (Array.isArray(contentType)) {
        for (const type of contentType) {
          this[kContentTypeParser].remove(type);
        }
      } else {
        this[kContentTypeParser].remove(contentType);
      }
    }
    function removeAllContentTypeParsers() {
      if (this[kState].started) {
        throw new Error('Cannot call "removeAllContentTypeParsers" when fastify instance is already started!');
      }
      this[kContentTypeParser].removeAll();
    }
    module2.exports = ContentTypeParser;
    module2.exports.helpers = {
      buildContentTypeParser,
      addContentTypeParser,
      hasContentTypeParser,
      removeContentTypeParser,
      removeAllContentTypeParsers
    };
    module2.exports.defaultParsers = {
      getDefaultJsonParser,
      defaultTextParser: defaultPlainTextParser
    };
    module2.exports[kTestInternals] = { rawBody };
  }
});

// packages/platform-fastify/node_modules/rfdc/index.js
var require_rfdc = __commonJS({
  "packages/platform-fastify/node_modules/rfdc/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = rfdc;
    function copyBuffer(cur) {
      if (cur instanceof Buffer) {
        return Buffer.from(cur);
      }
      return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
    }
    function rfdc(opts) {
      opts = opts || {};
      if (opts.circles)
        return rfdcCircles(opts);
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn2) {
        var keys = Object.keys(a);
        var a2 = new Array(keys.length);
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          var cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur instanceof Date) {
            a2[k] = new Date(cur);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            a2[k] = fn2(cur);
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, clone);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), clone));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), clone));
        var o2 = {};
        for (var k in o) {
          if (Object.hasOwnProperty.call(o, k) === false)
            continue;
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k] = new Map(cloneArray(Array.from(cur), clone));
          } else if (cur instanceof Set) {
            o2[k] = new Set(cloneArray(Array.from(cur), clone));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = clone(cur);
          }
        }
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, cloneProto);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), cloneProto));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), cloneProto));
        var o2 = {};
        for (var k in o) {
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k] = new Map(cloneArray(Array.from(cur), cloneProto));
          } else if (cur instanceof Set) {
            o2[k] = new Set(cloneArray(Array.from(cur), cloneProto));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = cloneProto(cur);
          }
        }
        return o2;
      }
    }
    function rfdcCircles(opts) {
      var refs = [];
      var refsNew = [];
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn2) {
        var keys = Object.keys(a);
        var a2 = new Array(keys.length);
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          var cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur instanceof Date) {
            a2[k] = new Date(cur);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            var index2 = refs.indexOf(cur);
            if (index2 !== -1) {
              a2[k] = refsNew[index2];
            } else {
              a2[k] = fn2(cur);
            }
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, clone);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), clone));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), clone));
        var o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (var k in o) {
          if (Object.hasOwnProperty.call(o, k) === false)
            continue;
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k] = new Map(cloneArray(Array.from(cur), clone));
          } else if (cur instanceof Set) {
            o2[k] = new Set(cloneArray(Array.from(cur), clone));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            var i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = clone(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, cloneProto);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), cloneProto));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), cloneProto));
        var o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (var k in o) {
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k] = new Map(cloneArray(Array.from(cur), cloneProto));
          } else if (cur instanceof Set) {
            o2[k] = new Set(cloneArray(Array.from(cur), cloneProto));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            var i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = cloneProto(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
    }
  }
});

// packages/platform-fastify/node_modules/fastify/lib/schemas.js
var require_schemas = __commonJS({
  "packages/platform-fastify/node_modules/fastify/lib/schemas.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var fastClone = require_rfdc()({ circles: false, proto: true });
    var { kSchemaVisited } = require_symbols();
    var kFluentSchema = Symbol.for("fluent-schema-object");
    var {
      FST_ERR_SCH_MISSING_ID,
      FST_ERR_SCH_ALREADY_PRESENT,
      FST_ERR_SCH_DUPLICATE
    } = require_errors();
    var SCHEMAS_SOURCE = ["params", "body", "querystring", "query", "headers"];
    function Schemas(initStore) {
      this.store = initStore || {};
    }
    Schemas.prototype.add = function(inputSchema) {
      const schema = fastClone(inputSchema.isFluentSchema || inputSchema.isFluentJSONSchema || inputSchema[kFluentSchema] ? inputSchema.valueOf() : inputSchema);
      const id = schema.$id;
      if (!id) {
        throw new FST_ERR_SCH_MISSING_ID();
      }
      if (this.store[id]) {
        throw new FST_ERR_SCH_ALREADY_PRESENT(id);
      }
      this.store[id] = schema;
    };
    Schemas.prototype.getSchemas = function() {
      return Object.assign({}, this.store);
    };
    Schemas.prototype.getSchema = function(schemaId) {
      return this.store[schemaId];
    };
    function normalizeSchema(routeSchemas, serverOptions) {
      if (routeSchemas[kSchemaVisited]) {
        return routeSchemas;
      }
      if (routeSchemas.query) {
        if (routeSchemas.querystring) {
          throw new FST_ERR_SCH_DUPLICATE("querystring");
        }
        routeSchemas.querystring = routeSchemas.query;
      }
      generateFluentSchema(routeSchemas);
      for (const key of ["headers", "querystring", "params", "body"]) {
        if (typeof routeSchemas[key] === "object" && Object.getPrototypeOf(routeSchemas[key]) !== Object.prototype) {
          return routeSchemas;
        }
      }
      if (routeSchemas.body) {
        routeSchemas.body = getSchemaAnyway(routeSchemas.body, serverOptions.jsonShorthand);
      }
      if (routeSchemas.headers) {
        routeSchemas.headers = getSchemaAnyway(routeSchemas.headers, serverOptions.jsonShorthand);
      }
      if (routeSchemas.querystring) {
        routeSchemas.querystring = getSchemaAnyway(routeSchemas.querystring, serverOptions.jsonShorthand);
      }
      if (routeSchemas.params) {
        routeSchemas.params = getSchemaAnyway(routeSchemas.params, serverOptions.jsonShorthand);
      }
      if (routeSchemas.response) {
        const httpCodes = Object.keys(routeSchemas.response);
        for (const code of httpCodes) {
          routeSchemas.response[code] = getSchemaAnyway(routeSchemas.response[code], serverOptions.jsonShorthand);
        }
      }
      routeSchemas[kSchemaVisited] = true;
      return routeSchemas;
    }
    function generateFluentSchema(schema) {
      for (const key of SCHEMAS_SOURCE) {
        if (schema[key] && (schema[key].isFluentSchema || schema[key][kFluentSchema])) {
          schema[key] = schema[key].valueOf();
        }
      }
      if (schema.response) {
        const httpCodes = Object.keys(schema.response);
        for (const code of httpCodes) {
          if (schema.response[code].isFluentSchema || schema.response[code][kFluentSchema]) {
            schema.response[code] = schema.response[code].valueOf();
          }
        }
      }
    }
    function getSchemaAnyway(schema, jsonShorthand) {
      if (!jsonShorthand || schema.$ref || schema.oneOf || schema.allOf || schema.anyOf || schema.$merge || schema.$patch)
        return schema;
      if (!schema.type && !schema.properties) {
        return {
          type: "object",
          properties: schema
        };
      }
      return schema;
    }
    module2.exports = {
      buildSchemas(initStore) {
        return new Schemas(initStore);
      },
      normalizeSchema
    };
  }
});

// packages/platform-fastify/node_modules/fastify/lib/schema-compilers.js
var require_schema_compilers = __commonJS({
  "packages/platform-fastify/node_modules/fastify/lib/schema-compilers.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var fastJsonStringify = __require("fast-json-stringify");
    function serializerFactory(externalSchemas, serializerOpts) {
      const opts = Object.assign({}, serializerOpts, { schema: externalSchemas });
      return function responseSchemaCompiler({ schema }) {
        return fastJsonStringify(schema, opts);
      };
    }
    module2.exports.serializerCompiler = serializerFactory;
  }
});

// packages/platform-fastify/node_modules/uri-js/dist/es5/uri.all.js
var require_uri_all = __commonJS({
  "packages/platform-fastify/node_modules/uri-js/dist/es5/uri.all.js"(exports2, module2) {
    init_esm_shims();
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.URI = global2.URI || {});
    })(exports2, function(exports3) {
      "use strict";
      function merge() {
        for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
          sets[_key] = arguments[_key];
        }
        if (sets.length > 1) {
          sets[0] = sets[0].slice(0, -1);
          var xl = sets.length - 1;
          for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
          }
          sets[xl] = sets[xl].slice(1);
          return sets.join("");
        } else {
          return sets[0];
        }
      }
      function subexp(str) {
        return "(?:" + str + ")";
      }
      function typeOf(o) {
        return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
      }
      function toUpperCase(str) {
        return str.toUpperCase();
      }
      function toArray(obj) {
        return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
      }
      function assign(target, source) {
        var obj = target;
        if (source) {
          for (var key in source) {
            obj[key] = source[key];
          }
        }
        return obj;
      }
      function buildExps(isIRI2) {
        var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI2 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI2 ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+"), IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + ZONEID$), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
        return {
          NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
          NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
          NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
          ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
          OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
          PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
          IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
          IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
        };
      }
      var URI_PROTOCOL = buildExps(false);
      var IRI_PROTOCOL = buildExps(true);
      var slicedToArray = function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"])
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var toConsumableArray = function(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
            arr2[i] = arr[i];
          return arr2;
        } else {
          return Array.from(arr);
        }
      };
      var maxInt = 2147483647;
      var base = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter = "-";
      var regexPunycode = /^xn--/;
      var regexNonASCII = /[^\0-\x7E]/;
      var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      var errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      };
      var baseMinusTMin = base - tMin;
      var floor = Math.floor;
      var stringFromCharCode = String.fromCharCode;
      function error$1(type) {
        throw new RangeError(errors[type]);
      }
      function map3(array, fn2) {
        var result = [];
        var length = array.length;
        while (length--) {
          result[length] = fn2(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn2) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map3(labels, fn2).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        while (counter < length) {
          var value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            var extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      var ucs2encode = function ucs2encode2(array) {
        return String.fromCodePoint.apply(String, toConsumableArray(array));
      };
      var basicToDigit = function basicToDigit2(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      };
      var digitToBasic = function digitToBasic2(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      };
      var adapt = function adapt2(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      var decode = function decode2(input) {
        var output = [];
        var inputLength = input.length;
        var i = 0;
        var n = initialN;
        var bias = initialBias;
        var basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (var j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error$1("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (var index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
          var oldi = i;
          for (var w = 1, k = base; ; k += base) {
            if (index2 >= inputLength) {
              error$1("invalid-input");
            }
            var digit = basicToDigit(input.charCodeAt(index2++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error$1("overflow");
            }
            i += digit * w;
            var t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t2) {
              break;
            }
            var baseMinusT = base - t2;
            if (w > floor(maxInt / baseMinusT)) {
              error$1("overflow");
            }
            w *= baseMinusT;
          }
          var out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error$1("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return String.fromCodePoint.apply(String, output);
      };
      var encode = function encode2(input) {
        var output = [];
        input = ucs2decode(input);
        var inputLength = input.length;
        var n = initialN;
        var delta = 0;
        var bias = initialBias;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _currentValue2 = _step.value;
            if (_currentValue2 < 128) {
              output.push(stringFromCharCode(_currentValue2));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          var m = maxInt;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var currentValue = _step2.value;
              if (currentValue >= n && currentValue < m) {
                m = currentValue;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          var handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error$1("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _currentValue = _step3.value;
              if (_currentValue < n && ++delta > maxInt) {
                error$1("overflow");
              }
              if (_currentValue == n) {
                var q = delta;
                for (var k = base; ; k += base) {
                  var t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q < t2) {
                    break;
                  }
                  var qMinusT = q - t2;
                  var baseMinusT = base - t2;
                  output.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
                  q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      };
      var toUnicode = function toUnicode2(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      };
      var toASCII = function toASCII2(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      };
      var punycode = {
        "version": "2.1.0",
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      var SCHEMES = {};
      function pctEncChar(chr) {
        var c = chr.charCodeAt(0);
        var e = void 0;
        if (c < 16)
          e = "%0" + c.toString(16).toUpperCase();
        else if (c < 128)
          e = "%" + c.toString(16).toUpperCase();
        else if (c < 2048)
          e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        else
          e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        return e;
      }
      function pctDecChars(str) {
        var newStr = "";
        var i = 0;
        var il = str.length;
        while (i < il) {
          var c = parseInt(str.substr(i + 1, 2), 16);
          if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
          } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
              var c2 = parseInt(str.substr(i + 4, 2), 16);
              newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
              newStr += str.substr(i, 6);
            }
            i += 6;
          } else if (c >= 224) {
            if (il - i >= 9) {
              var _c = parseInt(str.substr(i + 4, 2), 16);
              var c3 = parseInt(str.substr(i + 7, 2), 16);
              newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
              newStr += str.substr(i, 9);
            }
            i += 9;
          } else {
            newStr += str.substr(i, 3);
            i += 3;
          }
        }
        return newStr;
      }
      function _normalizeComponentEncoding(components, protocol) {
        function decodeUnreserved2(str) {
          var decStr = pctDecChars(str);
          return !decStr.match(protocol.UNRESERVED) ? str : decStr;
        }
        if (components.scheme)
          components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
        if (components.userinfo !== void 0)
          components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.host !== void 0)
          components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.path !== void 0)
          components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.query !== void 0)
          components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.fragment !== void 0)
          components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        return components;
      }
      function _stripLeadingZeros(str) {
        return str.replace(/^0*(.*)/, "$1") || "0";
      }
      function _normalizeIPv4(host, protocol) {
        var matches = host.match(protocol.IPV4ADDRESS) || [];
        var _matches = slicedToArray(matches, 2), address = _matches[1];
        if (address) {
          return address.split(".").map(_stripLeadingZeros).join(".");
        } else {
          return host;
        }
      }
      function _normalizeIPv6(host, protocol) {
        var matches = host.match(protocol.IPV6ADDRESS) || [];
        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
        if (address) {
          var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
          var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
          var lastFields = last.split(":").map(_stripLeadingZeros);
          var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
          var fieldCount = isLastFieldIPv4Address ? 7 : 8;
          var lastFieldsStart = lastFields.length - fieldCount;
          var fields = Array(fieldCount);
          for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
          }
          if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
          }
          var allZeroFields = fields.reduce(function(acc, field, index2) {
            if (!field || field === "0") {
              var lastLongest = acc[acc.length - 1];
              if (lastLongest && lastLongest.index + lastLongest.length === index2) {
                lastLongest.length++;
              } else {
                acc.push({ index: index2, length: 1 });
              }
            }
            return acc;
          }, []);
          var longestZeroFields = allZeroFields.sort(function(a, b) {
            return b.length - a.length;
          })[0];
          var newHost = void 0;
          if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
          } else {
            newHost = fields.join(":");
          }
          if (zone) {
            newHost += "%" + zone;
          }
          return newHost;
        } else {
          return host;
        }
      }
      var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
      var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
      function parse(uriString) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var components = {};
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix")
          uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches = uriString.match(URI_PARSE);
        if (matches) {
          if (NO_MATCH_IS_UNDEFINED) {
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            if (isNaN(components.port)) {
              components.port = matches[5];
            }
          } else {
            components.scheme = matches[1] || void 0;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
            if (isNaN(components.port)) {
              components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
            }
          }
          if (components.host) {
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
          }
          if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
            components.reference = "same-document";
          } else if (components.scheme === void 0) {
            components.reference = "relative";
          } else if (components.fragment === void 0) {
            components.reference = "absolute";
          } else {
            components.reference = "uri";
          }
          if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
          }
          var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
              try {
                components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
              } catch (e) {
                components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
              }
            }
            _normalizeComponentEncoding(components, URI_PROTOCOL);
          } else {
            _normalizeComponentEncoding(components, protocol);
          }
          if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
          }
        } else {
          components.error = components.error || "URI can not be parsed.";
        }
        return components;
      }
      function _recomposeAuthority(components, options) {
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== void 0) {
          uriTokens.push(components.userinfo);
          uriTokens.push("@");
        }
        if (components.host !== void 0) {
          uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
          }));
        }
        if (typeof components.port === "number" || typeof components.port === "string") {
          uriTokens.push(":");
          uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : void 0;
      }
      var RDS1 = /^\.\.?\//;
      var RDS2 = /^\/\.(\/|$)/;
      var RDS3 = /^\/\.\.(\/|$)/;
      var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
      function removeDotSegments(input) {
        var output = [];
        while (input.length) {
          if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
          } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
          } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
          } else if (input === "." || input === "..") {
            input = "";
          } else {
            var im = input.match(RDS5);
            if (im) {
              var s2 = im[0];
              input = input.slice(s2.length);
              output.push(s2);
            } else {
              throw new Error("Unexpected dot segment condition");
            }
          }
        }
        return output.join("");
      }
      function serialize(components) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (schemeHandler && schemeHandler.serialize)
          schemeHandler.serialize(components, options);
        if (components.host) {
          if (protocol.IPV6ADDRESS.test(components.host)) {
          } else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
            try {
              components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
          }
        }
        _normalizeComponentEncoding(components, protocol);
        if (options.reference !== "suffix" && components.scheme) {
          uriTokens.push(components.scheme);
          uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== void 0) {
          if (options.reference !== "suffix") {
            uriTokens.push("//");
          }
          uriTokens.push(authority);
          if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
          }
        }
        if (components.path !== void 0) {
          var s2 = components.path;
          if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s2 = removeDotSegments(s2);
          }
          if (authority === void 0) {
            s2 = s2.replace(/^\/\//, "/%2F");
          }
          uriTokens.push(s2);
        }
        if (components.query !== void 0) {
          uriTokens.push("?");
          uriTokens.push(components.query);
        }
        if (components.fragment !== void 0) {
          uriTokens.push("#");
          uriTokens.push(components.fragment);
        }
        return uriTokens.join("");
      }
      function resolveComponents(base2, relative2) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var skipNormalization = arguments[3];
        var target = {};
        if (!skipNormalization) {
          base2 = parse(serialize(base2, options), options);
          relative2 = parse(serialize(relative2, options), options);
        }
        options = options || {};
        if (!options.tolerant && relative2.scheme) {
          target.scheme = relative2.scheme;
          target.userinfo = relative2.userinfo;
          target.host = relative2.host;
          target.port = relative2.port;
          target.path = removeDotSegments(relative2.path || "");
          target.query = relative2.query;
        } else {
          if (relative2.userinfo !== void 0 || relative2.host !== void 0 || relative2.port !== void 0) {
            target.userinfo = relative2.userinfo;
            target.host = relative2.host;
            target.port = relative2.port;
            target.path = removeDotSegments(relative2.path || "");
            target.query = relative2.query;
          } else {
            if (!relative2.path) {
              target.path = base2.path;
              if (relative2.query !== void 0) {
                target.query = relative2.query;
              } else {
                target.query = base2.query;
              }
            } else {
              if (relative2.path.charAt(0) === "/") {
                target.path = removeDotSegments(relative2.path);
              } else {
                if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                  target.path = "/" + relative2.path;
                } else if (!base2.path) {
                  target.path = relative2.path;
                } else {
                  target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative2.path;
                }
                target.path = removeDotSegments(target.path);
              }
              target.query = relative2.query;
            }
            target.userinfo = base2.userinfo;
            target.host = base2.host;
            target.port = base2.port;
          }
          target.scheme = base2.scheme;
        }
        target.fragment = relative2.fragment;
        return target;
      }
      function resolve(baseURI, relativeURI, options) {
        var schemelessOptions = assign({ scheme: "null" }, options);
        return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
      }
      function normalize(uri, options) {
        if (typeof uri === "string") {
          uri = serialize(parse(uri, options), options);
        } else if (typeOf(uri) === "object") {
          uri = parse(serialize(uri, options), options);
        }
        return uri;
      }
      function equal(uriA, uriB, options) {
        if (typeof uriA === "string") {
          uriA = serialize(parse(uriA, options), options);
        } else if (typeOf(uriA) === "object") {
          uriA = serialize(uriA, options);
        }
        if (typeof uriB === "string") {
          uriB = serialize(parse(uriB, options), options);
        } else if (typeOf(uriB) === "object") {
          uriB = serialize(uriB, options);
        }
        return uriA === uriB;
      }
      function escapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
      }
      function unescapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
      }
      var handler = {
        scheme: "http",
        domainHost: true,
        parse: function parse2(components, options) {
          if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
          }
          return components;
        },
        serialize: function serialize2(components, options) {
          var secure = String(components.scheme).toLowerCase() === "https";
          if (components.port === (secure ? 443 : 80) || components.port === "") {
            components.port = void 0;
          }
          if (!components.path) {
            components.path = "/";
          }
          return components;
        }
      };
      var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize
      };
      function isSecure(wsComponents) {
        return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
      }
      var handler$2 = {
        scheme: "ws",
        domainHost: true,
        parse: function parse2(components, options) {
          var wsComponents = components;
          wsComponents.secure = isSecure(wsComponents);
          wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
          wsComponents.path = void 0;
          wsComponents.query = void 0;
          return wsComponents;
        },
        serialize: function serialize2(wsComponents, options) {
          if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
            wsComponents.port = void 0;
          }
          if (typeof wsComponents.secure === "boolean") {
            wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
            wsComponents.secure = void 0;
          }
          if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path2 = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
            wsComponents.path = path2 && path2 !== "/" ? path2 : void 0;
            wsComponents.query = query;
            wsComponents.resourceName = void 0;
          }
          wsComponents.fragment = void 0;
          return wsComponents;
        }
      };
      var handler$3 = {
        scheme: "wss",
        domainHost: handler$2.domainHost,
        parse: handler$2.parse,
        serialize: handler$2.serialize
      };
      var O = {};
      var isIRI = true;
      var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
      var HEXDIG$$ = "[0-9A-Fa-f]";
      var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
      var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
      var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
      var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
      var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
      var UNRESERVED = new RegExp(UNRESERVED$$, "g");
      var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
      var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
      var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
      var NOT_HFVALUE = NOT_HFNAME;
      function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(UNRESERVED) ? str : decStr;
      }
      var handler$4 = {
        scheme: "mailto",
        parse: function parse$$1(components, options) {
          var mailtoComponents = components;
          var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
          mailtoComponents.path = void 0;
          if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
              var hfield = hfields[x].split("=");
              switch (hfield[0]) {
                case "to":
                  var toAddrs = hfield[1].split(",");
                  for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                    to.push(toAddrs[_x]);
                  }
                  break;
                case "subject":
                  mailtoComponents.subject = unescapeComponent(hfield[1], options);
                  break;
                case "body":
                  mailtoComponents.body = unescapeComponent(hfield[1], options);
                  break;
                default:
                  unknownHeaders = true;
                  headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                  break;
              }
            }
            if (unknownHeaders)
              mailtoComponents.headers = headers;
          }
          mailtoComponents.query = void 0;
          for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
              try {
                addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
              } catch (e) {
                mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
              }
            } else {
              addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
          }
          return mailtoComponents;
        },
        serialize: function serialize$$1(mailtoComponents, options) {
          var components = mailtoComponents;
          var to = toArray(mailtoComponents.to);
          if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
              var toAddr = String(to[x]);
              var atIdx = toAddr.lastIndexOf("@");
              var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
              var domain = toAddr.slice(atIdx + 1);
              try {
                domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
              } catch (e) {
                components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
              }
              to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
          }
          var headers = mailtoComponents.headers = mailtoComponents.headers || {};
          if (mailtoComponents.subject)
            headers["subject"] = mailtoComponents.subject;
          if (mailtoComponents.body)
            headers["body"] = mailtoComponents.body;
          var fields = [];
          for (var name in headers) {
            if (headers[name] !== O[name]) {
              fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
          }
          if (fields.length) {
            components.query = fields.join("&");
          }
          return components;
        }
      };
      var URN_PARSE = /^([^\:]+)\:(.*)/;
      var handler$5 = {
        scheme: "urn",
        parse: function parse$$1(components, options) {
          var matches = components.path && components.path.match(URN_PARSE);
          var urnComponents = components;
          if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = void 0;
            if (schemeHandler) {
              urnComponents = schemeHandler.parse(urnComponents, options);
            }
          } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
          }
          return urnComponents;
        },
        serialize: function serialize$$1(urnComponents, options) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = urnComponents.nid;
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
          }
          var uriComponents = urnComponents;
          var nss = urnComponents.nss;
          uriComponents.path = (nid || options.nid) + ":" + nss;
          return uriComponents;
        }
      };
      var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
      var handler$6 = {
        scheme: "urn:uuid",
        parse: function parse2(urnComponents, options) {
          var uuidComponents = urnComponents;
          uuidComponents.uuid = uuidComponents.nss;
          uuidComponents.nss = void 0;
          if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
          }
          return uuidComponents;
        },
        serialize: function serialize2(uuidComponents, options) {
          var urnComponents = uuidComponents;
          urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
          return urnComponents;
        }
      };
      SCHEMES[handler.scheme] = handler;
      SCHEMES[handler$1.scheme] = handler$1;
      SCHEMES[handler$2.scheme] = handler$2;
      SCHEMES[handler$3.scheme] = handler$3;
      SCHEMES[handler$4.scheme] = handler$4;
      SCHEMES[handler$5.scheme] = handler$5;
      SCHEMES[handler$6.scheme] = handler$6;
      exports3.SCHEMES = SCHEMES;
      exports3.pctEncChar = pctEncChar;
      exports3.pctDecChars = pctDecChars;
      exports3.parse = parse;
      exports3.removeDotSegments = removeDotSegments;
      exports3.serialize = serialize;
      exports3.resolveComponents = resolveComponents;
      exports3.resolve = resolve;
      exports3.normalize = normalize;
      exports3.equal = equal;
      exports3.escapeComponent = escapeComponent;
      exports3.unescapeComponent = unescapeComponent;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// packages/platform-fastify/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "packages/platform-fastify/node_modules/fast-deep-equal/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function equal(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/compile/ucs2length.js
var require_ucs2length = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/compile/ucs2length.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function ucs2length(str) {
      var length = 0, len = str.length, pos = 0, value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) == 56320)
            pos++;
        }
      }
      return length;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/compile/util.js
var require_util = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/compile/util.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = {
      copy,
      checkDataType,
      checkDataTypes,
      coerceToTypes,
      toHash,
      getProperty,
      escapeQuotes,
      equal: require_fast_deep_equal(),
      ucs2length: require_ucs2length(),
      varOccurences,
      varReplace,
      schemaHasRules,
      schemaHasRulesExcept,
      schemaUnknownRules,
      toQuotedString,
      getPathExpr,
      getPath,
      getData,
      unescapeFragment,
      unescapeJsonPointer,
      escapeFragment,
      escapeJsonPointer
    };
    function copy(o, to) {
      to = to || {};
      for (var key in o)
        to[key] = o[key];
      return to;
    }
    function checkDataType(dataType, data, strictNumbers, negate) {
      var EQUAL = negate ? " !== " : " === ", AND = negate ? " || " : " && ", OK = negate ? "!" : "", NOT = negate ? "" : "!";
      switch (dataType) {
        case "null":
          return data + EQUAL + "null";
        case "array":
          return OK + "Array.isArray(" + data + ")";
        case "object":
          return "(" + OK + data + AND + "typeof " + data + EQUAL + '"object"' + AND + NOT + "Array.isArray(" + data + "))";
        case "integer":
          return "(typeof " + data + EQUAL + '"number"' + AND + NOT + "(" + data + " % 1)" + AND + data + EQUAL + data + (strictNumbers ? AND + OK + "isFinite(" + data + ")" : "") + ")";
        case "number":
          return "(typeof " + data + EQUAL + '"' + dataType + '"' + (strictNumbers ? AND + OK + "isFinite(" + data + ")" : "") + ")";
        default:
          return "typeof " + data + EQUAL + '"' + dataType + '"';
      }
    }
    function checkDataTypes(dataTypes, data, strictNumbers) {
      switch (dataTypes.length) {
        case 1:
          return checkDataType(dataTypes[0], data, strictNumbers, true);
        default:
          var code = "";
          var types2 = toHash(dataTypes);
          if (types2.array && types2.object) {
            code = types2.null ? "(" : "(!" + data + " || ";
            code += "typeof " + data + ' !== "object")';
            delete types2.null;
            delete types2.array;
            delete types2.object;
          }
          if (types2.number)
            delete types2.integer;
          for (var t2 in types2)
            code += (code ? " && " : "") + checkDataType(t2, data, strictNumbers, true);
          return code;
      }
    }
    var COERCE_TO_TYPES = toHash(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(optionCoerceTypes, dataTypes) {
      if (Array.isArray(dataTypes)) {
        var types2 = [];
        for (var i = 0; i < dataTypes.length; i++) {
          var t2 = dataTypes[i];
          if (COERCE_TO_TYPES[t2])
            types2[types2.length] = t2;
          else if (optionCoerceTypes === "array" && t2 === "array")
            types2[types2.length] = t2;
        }
        if (types2.length)
          return types2;
      } else if (COERCE_TO_TYPES[dataTypes]) {
        return [dataTypes];
      } else if (optionCoerceTypes === "array" && dataTypes === "array") {
        return ["array"];
      }
    }
    function toHash(arr) {
      var hash = {};
      for (var i = 0; i < arr.length; i++)
        hash[arr[i]] = true;
      return hash;
    }
    var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var SINGLE_QUOTE = /'|\\/g;
    function getProperty(key) {
      return typeof key == "number" ? "[" + key + "]" : IDENTIFIER.test(key) ? "." + key : "['" + escapeQuotes(key) + "']";
    }
    function escapeQuotes(str) {
      return str.replace(SINGLE_QUOTE, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
    }
    function varOccurences(str, dataVar) {
      dataVar += "[^0-9]";
      var matches = str.match(new RegExp(dataVar, "g"));
      return matches ? matches.length : 0;
    }
    function varReplace(str, dataVar, expr) {
      dataVar += "([^0-9])";
      expr = expr.replace(/\$/g, "$$$$");
      return str.replace(new RegExp(dataVar, "g"), expr + "$1");
    }
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (var key in schema)
        if (rules[key])
          return true;
    }
    function schemaHasRulesExcept(schema, rules, exceptKeyword) {
      if (typeof schema == "boolean")
        return !schema && exceptKeyword != "not";
      for (var key in schema)
        if (key != exceptKeyword && rules[key])
          return true;
    }
    function schemaUnknownRules(schema, rules) {
      if (typeof schema == "boolean")
        return;
      for (var key in schema)
        if (!rules[key])
          return key;
    }
    function toQuotedString(str) {
      return "'" + escapeQuotes(str) + "'";
    }
    function getPathExpr(currentPath, expr, jsonPointers, isNumber2) {
      var path2 = jsonPointers ? "'/' + " + expr + (isNumber2 ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : isNumber2 ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'";
      return joinPaths(currentPath, path2);
    }
    function getPath(currentPath, prop, jsonPointers) {
      var path2 = jsonPointers ? toQuotedString("/" + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
      return joinPaths(currentPath, path2);
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, lvl, paths) {
      var up, jsonPointer, data, matches;
      if ($data === "")
        return "rootData";
      if ($data[0] == "/") {
        if (!JSON_POINTER.test($data))
          throw new Error("Invalid JSON-pointer: " + $data);
        jsonPointer = $data;
        data = "rootData";
      } else {
        matches = $data.match(RELATIVE_JSON_POINTER);
        if (!matches)
          throw new Error("Invalid JSON-pointer: " + $data);
        up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer == "#") {
          if (up >= lvl)
            throw new Error("Cannot access property/index " + up + " levels up, current level is " + lvl);
          return paths[lvl - up];
        }
        if (up > lvl)
          throw new Error("Cannot access data " + up + " levels up, current level is " + lvl);
        data = "data" + (lvl - up || "");
        if (!jsonPointer)
          return data;
      }
      var expr = data;
      var segments = jsonPointer.split("/");
      for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];
        if (segment) {
          data += getProperty(unescapeJsonPointer(segment));
          expr += " && " + data;
        }
      }
      return expr;
    }
    function joinPaths(a, b) {
      if (a == '""')
        return b;
      return (a + " + " + b).replace(/([^\\])' \+ '/g, "$1");
    }
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    function escapeJsonPointer(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
  }
});

// packages/platform-fastify/node_modules/ajv/lib/compile/schema_obj.js
var require_schema_obj = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/compile/schema_obj.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var util = require_util();
    module2.exports = SchemaObject;
    function SchemaObject(obj) {
      util.copy(obj, this);
    }
  }
});

// packages/platform-fastify/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "packages/platform-fastify/node_modules/json-schema-traverse/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var traverse = module2.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// packages/platform-fastify/node_modules/ajv/lib/compile/resolve.js
var require_resolve = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/compile/resolve.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var URI = require_uri_all();
    var equal = require_fast_deep_equal();
    var util = require_util();
    var SchemaObject = require_schema_obj();
    var traverse = require_json_schema_traverse();
    module2.exports = resolve;
    resolve.normalizeId = normalizeId;
    resolve.fullPath = getFullPath;
    resolve.url = resolveUrl;
    resolve.ids = resolveIds;
    resolve.inlineRef = inlineRef;
    resolve.schema = resolveSchema;
    function resolve(compile, root, ref) {
      var refVal = this._refs[ref];
      if (typeof refVal == "string") {
        if (this._refs[refVal])
          refVal = this._refs[refVal];
        else
          return resolve.call(this, compile, root, refVal);
      }
      refVal = refVal || this._schemas[ref];
      if (refVal instanceof SchemaObject) {
        return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
      }
      var res = resolveSchema.call(this, root, ref);
      var schema, v, baseId;
      if (res) {
        schema = res.schema;
        root = res.root;
        baseId = res.baseId;
      }
      if (schema instanceof SchemaObject) {
        v = schema.validate || compile.call(this, schema.schema, root, void 0, baseId);
      } else if (schema !== void 0) {
        v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile.call(this, schema, root, void 0, baseId);
      }
      return v;
    }
    function resolveSchema(root, ref) {
      var p = URI.parse(ref), refPath = _getFullPath(p), baseId = getFullPath(this._getId(root.schema));
      if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
        var id = normalizeId(refPath);
        var refVal = this._refs[id];
        if (typeof refVal == "string") {
          return resolveRecursive.call(this, root, refVal, p);
        } else if (refVal instanceof SchemaObject) {
          if (!refVal.validate)
            this._compile(refVal);
          root = refVal;
        } else {
          refVal = this._schemas[id];
          if (refVal instanceof SchemaObject) {
            if (!refVal.validate)
              this._compile(refVal);
            if (id == normalizeId(ref))
              return { schema: refVal, root, baseId };
            root = refVal;
          } else {
            return;
          }
        }
        if (!root.schema)
          return;
        baseId = getFullPath(this._getId(root.schema));
      }
      return getJsonPointer.call(this, p, baseId, root.schema, root);
    }
    function resolveRecursive(root, ref, parsedRef) {
      var res = resolveSchema.call(this, root, ref);
      if (res) {
        var schema = res.schema;
        var baseId = res.baseId;
        root = res.root;
        var id = this._getId(schema);
        if (id)
          baseId = resolveUrl(baseId, id);
        return getJsonPointer.call(this, parsedRef, baseId, schema, root);
      }
    }
    var PREVENT_SCOPE_CHANGE = util.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
    function getJsonPointer(parsedRef, baseId, schema, root) {
      parsedRef.fragment = parsedRef.fragment || "";
      if (parsedRef.fragment.slice(0, 1) != "/")
        return;
      var parts = parsedRef.fragment.split("/");
      for (var i = 1; i < parts.length; i++) {
        var part = parts[i];
        if (part) {
          part = util.unescapeFragment(part);
          schema = schema[part];
          if (schema === void 0)
            break;
          var id;
          if (!PREVENT_SCOPE_CHANGE[part]) {
            id = this._getId(schema);
            if (id)
              baseId = resolveUrl(baseId, id);
            if (schema.$ref) {
              var $ref = resolveUrl(baseId, schema.$ref);
              var res = resolveSchema.call(this, root, $ref);
              if (res) {
                schema = res.schema;
                root = res.root;
                baseId = res.baseId;
              }
            }
          }
        }
      }
      if (schema !== void 0 && schema !== root.schema)
        return { schema, root, baseId };
    }
    var SIMPLE_INLINED = util.toHash([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum"
    ]);
    function inlineRef(schema, limit) {
      if (limit === false)
        return false;
      if (limit === void 0 || limit === true)
        return checkNoRef(schema);
      else if (limit)
        return countKeys(schema) <= limit;
    }
    function checkNoRef(schema) {
      var item;
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++) {
          item = schema[i];
          if (typeof item == "object" && !checkNoRef(item))
            return false;
        }
      } else {
        for (var key in schema) {
          if (key == "$ref")
            return false;
          item = schema[key];
          if (typeof item == "object" && !checkNoRef(item))
            return false;
        }
      }
      return true;
    }
    function countKeys(schema) {
      var count = 0, item;
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++) {
          item = schema[i];
          if (typeof item == "object")
            count += countKeys(item);
          if (count == Infinity)
            return Infinity;
        }
      } else {
        for (var key in schema) {
          if (key == "$ref")
            return Infinity;
          if (SIMPLE_INLINED[key]) {
            count++;
          } else {
            item = schema[key];
            if (typeof item == "object")
              count += countKeys(item) + 1;
            if (count == Infinity)
              return Infinity;
          }
        }
      }
      return count;
    }
    function getFullPath(id, normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      var p = URI.parse(id);
      return _getFullPath(p);
    }
    function _getFullPath(p) {
      return URI.serialize(p).split("#")[0] + "#";
    }
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    function resolveUrl(baseId, id) {
      id = normalizeId(id);
      return URI.resolve(baseId, id);
    }
    function resolveIds(schema) {
      var schemaId = normalizeId(this._getId(schema));
      var baseIds = { "": schemaId };
      var fullPaths = { "": getFullPath(schemaId, false) };
      var localRefs = {};
      var self = this;
      traverse(schema, { allKeys: true }, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
        if (jsonPtr === "")
          return;
        var id = self._getId(sch);
        var baseId = baseIds[parentJsonPtr];
        var fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
        if (keyIndex !== void 0)
          fullPath += "/" + (typeof keyIndex == "number" ? keyIndex : util.escapeFragment(keyIndex));
        if (typeof id == "string") {
          id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);
          var refVal = self._refs[id];
          if (typeof refVal == "string")
            refVal = self._refs[refVal];
          if (refVal && refVal.schema) {
            if (!equal(sch, refVal.schema))
              throw new Error('id "' + id + '" resolves to more than one schema');
          } else if (id != normalizeId(fullPath)) {
            if (id[0] == "#") {
              if (localRefs[id] && !equal(sch, localRefs[id]))
                throw new Error('id "' + id + '" resolves to more than one schema');
              localRefs[id] = sch;
            } else {
              self._refs[id] = fullPath;
            }
          }
        }
        baseIds[jsonPtr] = baseId;
        fullPaths[jsonPtr] = fullPath;
      });
      return localRefs;
    }
  }
});

// packages/platform-fastify/node_modules/ajv/lib/compile/error_classes.js
var require_error_classes = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/compile/error_classes.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var resolve = require_resolve();
    module2.exports = {
      Validation: errorSubclass(ValidationError2),
      MissingRef: errorSubclass(MissingRefError)
    };
    function ValidationError2(errors) {
      this.message = "validation failed";
      this.errors = errors;
      this.ajv = this.validation = true;
    }
    MissingRefError.message = function(baseId, ref) {
      return "can't resolve reference " + ref + " from id " + baseId;
    };
    function MissingRefError(baseId, ref, message2) {
      this.message = message2 || MissingRefError.message(baseId, ref);
      this.missingRef = resolve.url(baseId, ref);
      this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
    }
    function errorSubclass(Subclass) {
      Subclass.prototype = Object.create(Error.prototype);
      Subclass.prototype.constructor = Subclass;
      return Subclass;
    }
  }
});

// packages/platform-fastify/node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS({
  "packages/platform-fastify/node_modules/fast-json-stable-stringify/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function(data, opts) {
      if (!opts)
        opts = {};
      if (typeof opts === "function")
        opts = { cmp: opts };
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var cmp = opts.cmp && function(f) {
        return function(node) {
          return function(a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return function stringify(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0)
          return;
        if (typeof node == "number")
          return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object")
          return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i = 0; i < node.length; i++) {
            if (i)
              out += ",";
            out += stringify(node[i]) || "null";
          }
          return out + "]";
        }
        if (node === null)
          return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles)
            return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          var value = stringify(node[key]);
          if (!value)
            continue;
          if (out)
            out += ",";
          out += JSON.stringify(key) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      }(data);
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/dotjs/validate.js
var require_validate = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/dotjs/validate.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function generate_validate(it, $keyword, $ruleType) {
      var out = "";
      var $async = it.schema.$async === true, $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, "$ref"), $id = it.self._getId(it.schema);
      if (it.opts.strictKeywords) {
        var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
        if ($unknownKwd) {
          var $keywordsMsg = "unknown keyword: " + $unknownKwd;
          if (it.opts.strictKeywords === "log")
            it.logger.warn($keywordsMsg);
          else
            throw new Error($keywordsMsg);
        }
      }
      if (it.isTop) {
        out += " var validate = ";
        if ($async) {
          it.async = true;
          out += "async ";
        }
        out += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
        if ($id && (it.opts.sourceCode || it.opts.processCode)) {
          out += " " + ("/*# sourceURL=" + $id + " */") + " ";
        }
      }
      if (typeof it.schema == "boolean" || !($refKeywords || it.schema.$ref)) {
        var $keyword = "false schema";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        if (it.schema === false) {
          if (it.isTop) {
            $breakOnError = true;
          } else {
            out += " var " + $valid + " = false; ";
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "false schema") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it.opts.messages !== false) {
              out += " , message: 'boolean schema is false' ";
            }
            if (it.opts.verbose) {
              out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
        } else {
          if (it.isTop) {
            if ($async) {
              out += " return data; ";
            } else {
              out += " validate.errors = null; return true; ";
            }
          } else {
            out += " var " + $valid + " = true; ";
          }
        }
        if (it.isTop) {
          out += " }; return validate; ";
        }
        return out;
      }
      if (it.isTop) {
        var $top = it.isTop, $lvl = it.level = 0, $dataLvl = it.dataLevel = 0, $data = "data";
        it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
        it.baseId = it.baseId || it.rootId;
        delete it.isTop;
        it.dataPathArr = [""];
        if (it.schema.default !== void 0 && it.opts.useDefaults && it.opts.strictDefaults) {
          var $defaultMsg = "default is ignored in the schema root";
          if (it.opts.strictDefaults === "log")
            it.logger.warn($defaultMsg);
          else
            throw new Error($defaultMsg);
        }
        out += " var vErrors = null; ";
        out += " var errors = 0;     ";
        out += " if (rootData === undefined) rootData = data; ";
      } else {
        var $lvl = it.level, $dataLvl = it.dataLevel, $data = "data" + ($dataLvl || "");
        if ($id)
          it.baseId = it.resolve.url(it.baseId, $id);
        if ($async && !it.async)
          throw new Error("async schema in sync schema");
        out += " var errs_" + $lvl + " = errors;";
      }
      var $valid = "valid" + $lvl, $breakOnError = !it.opts.allErrors, $closingBraces1 = "", $closingBraces2 = "";
      var $errorKeyword;
      var $typeSchema = it.schema.type, $typeIsArray = Array.isArray($typeSchema);
      if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
        if ($typeIsArray) {
          if ($typeSchema.indexOf("null") == -1)
            $typeSchema = $typeSchema.concat("null");
        } else if ($typeSchema != "null") {
          $typeSchema = [$typeSchema, "null"];
          $typeIsArray = true;
        }
      }
      if ($typeIsArray && $typeSchema.length == 1) {
        $typeSchema = $typeSchema[0];
        $typeIsArray = false;
      }
      if (it.schema.$ref && $refKeywords) {
        if (it.opts.extendRefs == "fail") {
          throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
        } else if (it.opts.extendRefs !== true) {
          $refKeywords = false;
          it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
        }
      }
      if (it.schema.$comment && it.opts.$comment) {
        out += " " + it.RULES.all.$comment.code(it, "$comment");
      }
      if ($typeSchema) {
        if (it.opts.coerceTypes) {
          var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
        }
        var $rulesGroup = it.RULES.types[$typeSchema];
        if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
          var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
          var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type", $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
          out += " if (" + it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true) + ") { ";
          if ($coerceToTypes) {
            var $dataType = "dataType" + $lvl, $coerced = "coerced" + $lvl;
            out += " var " + $dataType + " = typeof " + $data + "; var " + $coerced + " = undefined; ";
            if (it.opts.coerceTypes == "array") {
              out += " if (" + $dataType + " == 'object' && Array.isArray(" + $data + ") && " + $data + ".length == 1) { " + $data + " = " + $data + "[0]; " + $dataType + " = typeof " + $data + "; if (" + it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers) + ") " + $coerced + " = " + $data + "; } ";
            }
            out += " if (" + $coerced + " !== undefined) ; ";
            var arr1 = $coerceToTypes;
            if (arr1) {
              var $type, $i = -1, l1 = arr1.length - 1;
              while ($i < l1) {
                $type = arr1[$i += 1];
                if ($type == "string") {
                  out += " else if (" + $dataType + " == 'number' || " + $dataType + " == 'boolean') " + $coerced + " = '' + " + $data + "; else if (" + $data + " === null) " + $coerced + " = ''; ";
                } else if ($type == "number" || $type == "integer") {
                  out += " else if (" + $dataType + " == 'boolean' || " + $data + " === null || (" + $dataType + " == 'string' && " + $data + " && " + $data + " == +" + $data + " ";
                  if ($type == "integer") {
                    out += " && !(" + $data + " % 1)";
                  }
                  out += ")) " + $coerced + " = +" + $data + "; ";
                } else if ($type == "boolean") {
                  out += " else if (" + $data + " === 'false' || " + $data + " === 0 || " + $data + " === null) " + $coerced + " = false; else if (" + $data + " === 'true' || " + $data + " === 1) " + $coerced + " = true; ";
                } else if ($type == "null") {
                  out += " else if (" + $data + " === '' || " + $data + " === 0 || " + $data + " === false) " + $coerced + " = null; ";
                } else if (it.opts.coerceTypes == "array" && $type == "array") {
                  out += " else if (" + $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " + $data + " == null) " + $coerced + " = [" + $data + "]; ";
                }
              }
            }
            out += " else {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should be ";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } if (" + $coerced + " !== undefined) {  ";
            var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
            out += " " + $data + " = " + $coerced + "; ";
            if (!$dataLvl) {
              out += "if (" + $parentData + " !== undefined)";
            }
            out += " " + $parentData + "[" + $parentDataProperty + "] = " + $coerced + "; } ";
          } else {
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should be ";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
          }
          out += " } ";
        }
      }
      if (it.schema.$ref && !$refKeywords) {
        out += " " + it.RULES.all.$ref.code(it, "$ref") + " ";
        if ($breakOnError) {
          out += " } if (errors === ";
          if ($top) {
            out += "0";
          } else {
            out += "errs_" + $lvl;
          }
          out += ") { ";
          $closingBraces2 += "}";
        }
      } else {
        var arr2 = it.RULES;
        if (arr2) {
          var $rulesGroup, i2 = -1, l2 = arr2.length - 1;
          while (i2 < l2) {
            $rulesGroup = arr2[i2 += 1];
            if ($shouldUseGroup($rulesGroup)) {
              if ($rulesGroup.type) {
                out += " if (" + it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers) + ") { ";
              }
              if (it.opts.useDefaults) {
                if ($rulesGroup.type == "object" && it.schema.properties) {
                  var $schema = it.schema.properties, $schemaKeys = Object.keys($schema);
                  var arr3 = $schemaKeys;
                  if (arr3) {
                    var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                    while (i3 < l3) {
                      $propertyKey = arr3[i3 += 1];
                      var $sch = $schema[$propertyKey];
                      if ($sch.default !== void 0) {
                        var $passData = $data + it.util.getProperty($propertyKey);
                        if (it.compositeRule) {
                          if (it.opts.strictDefaults) {
                            var $defaultMsg = "default is ignored for: " + $passData;
                            if (it.opts.strictDefaults === "log")
                              it.logger.warn($defaultMsg);
                            else
                              throw new Error($defaultMsg);
                          }
                        } else {
                          out += " if (" + $passData + " === undefined ";
                          if (it.opts.useDefaults == "empty") {
                            out += " || " + $passData + " === null || " + $passData + " === '' ";
                          }
                          out += " ) " + $passData + " = ";
                          if (it.opts.useDefaults == "shared") {
                            out += " " + it.useDefault($sch.default) + " ";
                          } else {
                            out += " " + JSON.stringify($sch.default) + " ";
                          }
                          out += "; ";
                        }
                      }
                    }
                  }
                } else if ($rulesGroup.type == "array" && Array.isArray(it.schema.items)) {
                  var arr4 = it.schema.items;
                  if (arr4) {
                    var $sch, $i = -1, l4 = arr4.length - 1;
                    while ($i < l4) {
                      $sch = arr4[$i += 1];
                      if ($sch.default !== void 0) {
                        var $passData = $data + "[" + $i + "]";
                        if (it.compositeRule) {
                          if (it.opts.strictDefaults) {
                            var $defaultMsg = "default is ignored for: " + $passData;
                            if (it.opts.strictDefaults === "log")
                              it.logger.warn($defaultMsg);
                            else
                              throw new Error($defaultMsg);
                          }
                        } else {
                          out += " if (" + $passData + " === undefined ";
                          if (it.opts.useDefaults == "empty") {
                            out += " || " + $passData + " === null || " + $passData + " === '' ";
                          }
                          out += " ) " + $passData + " = ";
                          if (it.opts.useDefaults == "shared") {
                            out += " " + it.useDefault($sch.default) + " ";
                          } else {
                            out += " " + JSON.stringify($sch.default) + " ";
                          }
                          out += "; ";
                        }
                      }
                    }
                  }
                }
              }
              var arr5 = $rulesGroup.rules;
              if (arr5) {
                var $rule, i5 = -1, l5 = arr5.length - 1;
                while (i5 < l5) {
                  $rule = arr5[i5 += 1];
                  if ($shouldUseRule($rule)) {
                    var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                    if ($code) {
                      out += " " + $code + " ";
                      if ($breakOnError) {
                        $closingBraces1 += "}";
                      }
                    }
                  }
                }
              }
              if ($breakOnError) {
                out += " " + $closingBraces1 + " ";
                $closingBraces1 = "";
              }
              if ($rulesGroup.type) {
                out += " } ";
                if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
                  out += " else { ";
                  var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  if (it.createErrors !== false) {
                    out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                    if ($typeIsArray) {
                      out += "" + $typeSchema.join(",");
                    } else {
                      out += "" + $typeSchema;
                    }
                    out += "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: 'should be ";
                      if ($typeIsArray) {
                        out += "" + $typeSchema.join(",");
                      } else {
                        out += "" + $typeSchema;
                      }
                      out += "' ";
                    }
                    if (it.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    if (it.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                  out += " } ";
                }
              }
              if ($breakOnError) {
                out += " if (errors === ";
                if ($top) {
                  out += "0";
                } else {
                  out += "errs_" + $lvl;
                }
                out += ") { ";
                $closingBraces2 += "}";
              }
            }
          }
        }
      }
      if ($breakOnError) {
        out += " " + $closingBraces2 + " ";
      }
      if ($top) {
        if ($async) {
          out += " if (errors === 0) return data;           ";
          out += " else throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; ";
          out += " return errors === 0;       ";
        }
        out += " }; return validate;";
      } else {
        out += " var " + $valid + " = errors === errs_" + $lvl + ";";
      }
      function $shouldUseGroup($rulesGroup2) {
        var rules = $rulesGroup2.rules;
        for (var i = 0; i < rules.length; i++)
          if ($shouldUseRule(rules[i]))
            return true;
      }
      function $shouldUseRule($rule2) {
        return it.schema[$rule2.keyword] !== void 0 || $rule2.implements && $ruleImplementsSomeKeyword($rule2);
      }
      function $ruleImplementsSomeKeyword($rule2) {
        var impl = $rule2.implements;
        for (var i = 0; i < impl.length; i++)
          if (it.schema[impl[i]] !== void 0)
            return true;
      }
      return out;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/compile/index.js
var require_compile = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/compile/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var resolve = require_resolve();
    var util = require_util();
    var errorClasses = require_error_classes();
    var stableStringify = require_fast_json_stable_stringify();
    var validateGenerator = require_validate();
    var ucs2length = util.ucs2length;
    var equal = require_fast_deep_equal();
    var ValidationError2 = errorClasses.Validation;
    module2.exports = compile;
    function compile(schema, root, localRefs, baseId) {
      var self = this, opts = this._opts, refVal = [void 0], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];
      root = root || { schema, refVal, refs };
      var c = checkCompiling.call(this, schema, root, baseId);
      var compilation = this._compilations[c.index];
      if (c.compiling)
        return compilation.callValidate = callValidate;
      var formats = this._formats;
      var RULES = this.RULES;
      try {
        var v = localCompile(schema, root, localRefs, baseId);
        compilation.validate = v;
        var cv = compilation.callValidate;
        if (cv) {
          cv.schema = v.schema;
          cv.errors = null;
          cv.refs = v.refs;
          cv.refVal = v.refVal;
          cv.root = v.root;
          cv.$async = v.$async;
          if (opts.sourceCode)
            cv.source = v.source;
        }
        return v;
      } finally {
        endCompiling.call(this, schema, root, baseId);
      }
      function callValidate() {
        var validate = compilation.validate;
        var result = validate.apply(this, arguments);
        callValidate.errors = validate.errors;
        return result;
      }
      function localCompile(_schema, _root, localRefs2, baseId2) {
        var isRoot = !_root || _root && _root.schema == _schema;
        if (_root.schema != root.schema)
          return compile.call(self, _schema, _root, localRefs2, baseId2);
        var $async = _schema.$async === true;
        var sourceCode = validateGenerator({
          isTop: true,
          schema: _schema,
          isRoot,
          baseId: baseId2,
          root: _root,
          schemaPath: "",
          errSchemaPath: "#",
          errorPath: '""',
          MissingRefError: errorClasses.MissingRef,
          RULES,
          validate: validateGenerator,
          util,
          resolve,
          resolveRef,
          usePattern,
          useDefault,
          useCustomRule,
          opts,
          formats,
          logger: self.logger,
          self
        });
        sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode) + sourceCode;
        if (opts.processCode)
          sourceCode = opts.processCode(sourceCode, _schema);
        var validate;
        try {
          var makeValidate = new Function("self", "RULES", "formats", "root", "refVal", "defaults", "customRules", "equal", "ucs2length", "ValidationError", sourceCode);
          validate = makeValidate(self, RULES, formats, root, refVal, defaults, customRules, equal, ucs2length, ValidationError2);
          refVal[0] = validate;
        } catch (e) {
          self.logger.error("Error compiling schema, function code:", sourceCode);
          throw e;
        }
        validate.schema = _schema;
        validate.errors = null;
        validate.refs = refs;
        validate.refVal = refVal;
        validate.root = isRoot ? validate : _root;
        if ($async)
          validate.$async = true;
        if (opts.sourceCode === true) {
          validate.source = {
            code: sourceCode,
            patterns,
            defaults
          };
        }
        return validate;
      }
      function resolveRef(baseId2, ref, isRoot) {
        ref = resolve.url(baseId2, ref);
        var refIndex = refs[ref];
        var _refVal, refCode;
        if (refIndex !== void 0) {
          _refVal = refVal[refIndex];
          refCode = "refVal[" + refIndex + "]";
          return resolvedRef(_refVal, refCode);
        }
        if (!isRoot && root.refs) {
          var rootRefId = root.refs[ref];
          if (rootRefId !== void 0) {
            _refVal = root.refVal[rootRefId];
            refCode = addLocalRef(ref, _refVal);
            return resolvedRef(_refVal, refCode);
          }
        }
        refCode = addLocalRef(ref);
        var v2 = resolve.call(self, localCompile, root, ref);
        if (v2 === void 0) {
          var localSchema = localRefs && localRefs[ref];
          if (localSchema) {
            v2 = resolve.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile.call(self, localSchema, root, localRefs, baseId2);
          }
        }
        if (v2 === void 0) {
          removeLocalRef(ref);
        } else {
          replaceLocalRef(ref, v2);
          return resolvedRef(v2, refCode);
        }
      }
      function addLocalRef(ref, v2) {
        var refId = refVal.length;
        refVal[refId] = v2;
        refs[ref] = refId;
        return "refVal" + refId;
      }
      function removeLocalRef(ref) {
        delete refs[ref];
      }
      function replaceLocalRef(ref, v2) {
        var refId = refs[ref];
        refVal[refId] = v2;
      }
      function resolvedRef(refVal2, code) {
        return typeof refVal2 == "object" || typeof refVal2 == "boolean" ? { code, schema: refVal2, inline: true } : { code, $async: refVal2 && !!refVal2.$async };
      }
      function usePattern(regexStr) {
        var index2 = patternsHash[regexStr];
        if (index2 === void 0) {
          index2 = patternsHash[regexStr] = patterns.length;
          patterns[index2] = regexStr;
        }
        return "pattern" + index2;
      }
      function useDefault(value) {
        switch (typeof value) {
          case "boolean":
          case "number":
            return "" + value;
          case "string":
            return util.toQuotedString(value);
          case "object":
            if (value === null)
              return "null";
            var valueStr = stableStringify(value);
            var index2 = defaultsHash[valueStr];
            if (index2 === void 0) {
              index2 = defaultsHash[valueStr] = defaults.length;
              defaults[index2] = value;
            }
            return "default" + index2;
        }
      }
      function useCustomRule(rule, schema2, parentSchema, it) {
        if (self._opts.validateSchema !== false) {
          var deps = rule.definition.dependencies;
          if (deps && !deps.every(function(keyword) {
            return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
          }))
            throw new Error("parent schema must have all required keywords: " + deps.join(","));
          var validateSchema = rule.definition.validateSchema;
          if (validateSchema) {
            var valid = validateSchema(schema2);
            if (!valid) {
              var message2 = "keyword schema is invalid: " + self.errorsText(validateSchema.errors);
              if (self._opts.validateSchema == "log")
                self.logger.error(message2);
              else
                throw new Error(message2);
            }
          }
        }
        var compile2 = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;
        var validate;
        if (compile2) {
          validate = compile2.call(self, schema2, parentSchema, it);
        } else if (macro) {
          validate = macro.call(self, schema2, parentSchema, it);
          if (opts.validateSchema !== false)
            self.validateSchema(validate, true);
        } else if (inline) {
          validate = inline.call(self, it, rule.keyword, schema2, parentSchema);
        } else {
          validate = rule.definition.validate;
          if (!validate)
            return;
        }
        if (validate === void 0)
          throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
        var index2 = customRules.length;
        customRules[index2] = validate;
        return {
          code: "customRule" + index2,
          validate
        };
      }
    }
    function checkCompiling(schema, root, baseId) {
      var index2 = compIndex.call(this, schema, root, baseId);
      if (index2 >= 0)
        return { index: index2, compiling: true };
      index2 = this._compilations.length;
      this._compilations[index2] = {
        schema,
        root,
        baseId
      };
      return { index: index2, compiling: false };
    }
    function endCompiling(schema, root, baseId) {
      var i = compIndex.call(this, schema, root, baseId);
      if (i >= 0)
        this._compilations.splice(i, 1);
    }
    function compIndex(schema, root, baseId) {
      for (var i = 0; i < this._compilations.length; i++) {
        var c = this._compilations[i];
        if (c.schema == schema && c.root == root && c.baseId == baseId)
          return i;
      }
      return -1;
    }
    function patternCode(i, patterns) {
      return "var pattern" + i + " = new RegExp(" + util.toQuotedString(patterns[i]) + ");";
    }
    function defaultCode(i) {
      return "var default" + i + " = defaults[" + i + "];";
    }
    function refValCode(i, refVal) {
      return refVal[i] === void 0 ? "" : "var refVal" + i + " = refVal[" + i + "];";
    }
    function customRuleCode(i) {
      return "var customRule" + i + " = customRules[" + i + "];";
    }
    function vars(arr, statement) {
      if (!arr.length)
        return "";
      var code = "";
      for (var i = 0; i < arr.length; i++)
        code += statement(i, arr);
      return code;
    }
  }
});

// packages/platform-fastify/node_modules/ajv/lib/cache.js
var require_cache = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/cache.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var Cache = module2.exports = function Cache2() {
      this._cache = {};
    };
    Cache.prototype.put = function Cache_put(key, value) {
      this._cache[key] = value;
    };
    Cache.prototype.get = function Cache_get(key) {
      return this._cache[key];
    };
    Cache.prototype.del = function Cache_del(key) {
      delete this._cache[key];
    };
    Cache.prototype.clear = function Cache_clear() {
      this._cache = {};
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/compile/formats.js
var require_formats = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/compile/formats.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var util = require_util();
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
    var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
    var URL2 = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
    var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
    var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
    var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
    var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
    module2.exports = formats;
    function formats(mode) {
      mode = mode == "full" ? "full" : "fast";
      return util.copy(formats[mode]);
    }
    formats.fast = {
      date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
      time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
      "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      "uri-template": URITEMPLATE,
      url: URL2,
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
      hostname: HOSTNAME,
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex,
      uuid: UUID,
      "json-pointer": JSON_POINTER,
      "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
      "relative-json-pointer": RELATIVE_JSON_POINTER
    };
    formats.full = {
      date,
      time,
      "date-time": date_time,
      uri,
      "uri-reference": URIREF,
      "uri-template": URITEMPLATE,
      url: URL2,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: HOSTNAME,
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex,
      uuid: UUID,
      "json-pointer": JSON_POINTER,
      "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
      "relative-json-pointer": RELATIVE_JSON_POINTER
    };
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    function date(str) {
      var matches = str.match(DATE);
      if (!matches)
        return false;
      var year = +matches[1];
      var month = +matches[2];
      var day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function time(str, full) {
      var matches = str.match(TIME);
      if (!matches)
        return false;
      var hour = matches[1];
      var minute = matches[2];
      var second = matches[3];
      var timeZone = matches[5];
      return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function date_time(str) {
      var dateTime = str.split(DATE_TIME_SEPARATOR);
      return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
    }
    var NOT_URI_FRAGMENT = /\/|:/;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }
  }
});

// packages/platform-fastify/node_modules/ajv/lib/dotjs/ref.js
var require_ref = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/dotjs/ref.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function generate_ref(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $async, $refCode;
      if ($schema == "#" || $schema == "#/") {
        if (it.isRoot) {
          $async = it.async;
          $refCode = "validate";
        } else {
          $async = it.root.schema.$async === true;
          $refCode = "root.refVal[0]";
        }
      } else {
        var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
        if ($refVal === void 0) {
          var $message = it.MissingRefError.message(it.baseId, $schema);
          if (it.opts.missingRefs == "fail") {
            it.logger.error($message);
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '$ref' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { ref: '" + it.util.escapeQuotes($schema) + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'can\\'t resolve reference " + it.util.escapeQuotes($schema) + "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: " + it.util.toQuotedString($schema) + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            if ($breakOnError) {
              out += " if (false) { ";
            }
          } else if (it.opts.missingRefs == "ignore") {
            it.logger.warn($message);
            if ($breakOnError) {
              out += " if (true) { ";
            }
          } else {
            throw new it.MissingRefError(it.baseId, $schema, $message);
          }
        } else if ($refVal.inline) {
          var $it = it.util.copy(it);
          $it.level++;
          var $nextValid = "valid" + $it.level;
          $it.schema = $refVal.schema;
          $it.schemaPath = "";
          $it.errSchemaPath = $schema;
          var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
          out += " " + $code + " ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
          }
        } else {
          $async = $refVal.$async === true || it.async && $refVal.$async !== false;
          $refCode = $refVal.code;
        }
      }
      if ($refCode) {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.opts.passContext) {
          out += " " + $refCode + ".call(this, ";
        } else {
          out += " " + $refCode + "( ";
        }
        out += " " + $data + ", (dataPath || '')";
        if (it.errorPath != '""') {
          out += " + " + it.errorPath;
        }
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " , " + $parentData + " , " + $parentDataProperty + ", rootData)  ";
        var __callValidate = out;
        out = $$outStack.pop();
        if ($async) {
          if (!it.async)
            throw new Error("async schema referenced by sync schema");
          if ($breakOnError) {
            out += " var " + $valid + "; ";
          }
          out += " try { await " + __callValidate + "; ";
          if ($breakOnError) {
            out += " " + $valid + " = true; ";
          }
          out += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ";
          if ($breakOnError) {
            out += " " + $valid + " = false; ";
          }
          out += " } ";
          if ($breakOnError) {
            out += " if (" + $valid + ") { ";
          }
        } else {
          out += " if (!" + __callValidate + ") { if (vErrors === null) vErrors = " + $refCode + ".errors; else vErrors = vErrors.concat(" + $refCode + ".errors); errors = vErrors.length; } ";
          if ($breakOnError) {
            out += " else { ";
          }
        }
      }
      return out;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/dotjs/allOf.js
var require_allOf = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/dotjs/allOf.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function generate_allOf(it, $keyword, $ruleType) {
      var out = " ";
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $currentBaseId = $it.baseId, $allSchemasEmpty = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            $allSchemasEmpty = false;
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
      if ($breakOnError) {
        if ($allSchemasEmpty) {
          out += " if (true) { ";
        } else {
          out += " " + $closingBraces.slice(0, -1) + " ";
        }
      }
      return out;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/dotjs/anyOf.js
var require_anyOf = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/dotjs/anyOf.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function generate_anyOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $noEmptySchema = $schema.every(function($sch2) {
        return it.opts.strictKeywords ? typeof $sch2 == "object" && Object.keys($sch2).length > 0 || $sch2 === false : it.util.schemaHasRules($sch2, it.RULES.all);
      });
      if ($noEmptySchema) {
        var $currentBaseId = $it.baseId;
        out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            out += " " + $valid + " = " + $valid + " || " + $nextValid + "; if (!" + $valid + ") { ";
            $closingBraces += "}";
          }
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $closingBraces + " if (!" + $valid + ") {   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should match some schema in anyOf' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        if (it.opts.allErrors) {
          out += " } ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/dotjs/comment.js
var require_comment = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/dotjs/comment.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function generate_comment(it, $keyword, $ruleType) {
      var out = " ";
      var $schema = it.schema[$keyword];
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $comment = it.util.toQuotedString($schema);
      if (it.opts.$comment === true) {
        out += " console.log(" + $comment + ");";
      } else if (typeof it.opts.$comment == "function") {
        out += " self._opts.$comment(" + $comment + ", " + it.util.toQuotedString($errSchemaPath) + ", validate.root.schema);";
      }
      return out;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/dotjs/const.js
var require_const = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/dotjs/const.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function generate_const(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!$isData) {
        out += " var schema" + $lvl + " = validate.schema" + $schemaPath + ";";
      }
      out += "var " + $valid + " = equal(" + $data + ", schema" + $lvl + "); if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'const' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValue: schema" + $lvl + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be equal to constant' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " }";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/dotjs/contains.js
var require_contains = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/dotjs/contains.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function generate_contains(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId, $nonEmptySchema = it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all);
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if ($nonEmptySchema) {
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $nextValid + " = false; for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        out += " if (" + $nextValid + ") break; }  ";
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $closingBraces + " if (!" + $nextValid + ") {";
      } else {
        out += " if (" + $data + ".length == 0) {";
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'contains' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: 'should contain a valid item' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } else { ";
      if ($nonEmptySchema) {
        out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
      }
      if (it.opts.allErrors) {
        out += " } ";
      }
      return out;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/dotjs/dependencies.js
var require_dependencies = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/dotjs/dependencies.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function generate_dependencies(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it.opts.ownProperties;
      for ($property in $schema) {
        if ($property == "__proto__")
          continue;
        var $sch = $schema[$property];
        var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
        $deps[$property] = $sch;
      }
      out += "var " + $errs + " = errors;";
      var $currentErrorPath = it.errorPath;
      out += "var missing" + $lvl + ";";
      for (var $property in $propertyDeps) {
        $deps = $propertyDeps[$property];
        if ($deps.length) {
          out += " if ( " + $data + it.util.getProperty($property) + " !== undefined ";
          if ($ownProperties) {
            out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
          }
          if ($breakOnError) {
            out += " && ( ";
            var arr1 = $deps;
            if (arr1) {
              var $propertyKey, $i = -1, l1 = arr1.length - 1;
              while ($i < l1) {
                $propertyKey = arr1[$i += 1];
                if ($i) {
                  out += " || ";
                }
                var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                out += " ( ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
              }
            }
            out += ")) {  ";
            var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should have ";
                if ($deps.length == 1) {
                  out += "property " + it.util.escapeQuotes($deps[0]);
                } else {
                  out += "properties " + it.util.escapeQuotes($deps.join(", "));
                }
                out += " when property " + it.util.escapeQuotes($property) + " is present' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
          } else {
            out += " ) { ";
            var arr2 = $deps;
            if (arr2) {
              var $propertyKey, i2 = -1, l2 = arr2.length - 1;
              while (i2 < l2) {
                $propertyKey = arr2[i2 += 1];
                var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") {  var err =   ";
                if (it.createErrors !== false) {
                  out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: 'should have ";
                    if ($deps.length == 1) {
                      out += "property " + it.util.escapeQuotes($deps[0]);
                    } else {
                      out += "properties " + it.util.escapeQuotes($deps.join(", "));
                    }
                    out += " when property " + it.util.escapeQuotes($property) + " is present' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
              }
            }
          }
          out += " }   ";
          if ($breakOnError) {
            $closingBraces += "}";
            out += " else { ";
          }
        }
      }
      it.errorPath = $currentErrorPath;
      var $currentBaseId = $it.baseId;
      for (var $property in $schemaDeps) {
        var $sch = $schemaDeps[$property];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          out += " " + $nextValid + " = true; if ( " + $data + it.util.getProperty($property) + " !== undefined ";
          if ($ownProperties) {
            out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
          }
          out += ") { ";
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + it.util.getProperty($property);
          $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($property);
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
      if ($breakOnError) {
        out += "   " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/dotjs/enum.js
var require_enum = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/dotjs/enum.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function generate_enum(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $i = "i" + $lvl, $vSchema = "schema" + $lvl;
      if (!$isData) {
        out += " var " + $vSchema + " = validate.schema" + $schemaPath + ";";
      }
      out += "var " + $valid + ";";
      if ($isData) {
        out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
      }
      out += "" + $valid + " = false;for (var " + $i + "=0; " + $i + "<" + $vSchema + ".length; " + $i + "++) if (equal(" + $data + ", " + $vSchema + "[" + $i + "])) { " + $valid + " = true; break; }";
      if ($isData) {
        out += "  }  ";
      }
      out += " if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'enum' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValues: schema" + $lvl + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be equal to one of the allowed values' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " }";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/dotjs/format.js
var require_format = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/dotjs/format.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function generate_format(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      if (it.opts.format === false) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
        return out;
      }
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $unknownFormats = it.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
      if ($isData) {
        var $format = "format" + $lvl, $isObject = "isObject" + $lvl, $formatType = "formatType" + $lvl;
        out += " var " + $format + " = formats[" + $schemaValue + "]; var " + $isObject + " = typeof " + $format + " == 'object' && !(" + $format + " instanceof RegExp) && " + $format + ".validate; var " + $formatType + " = " + $isObject + " && " + $format + ".type || 'string'; if (" + $isObject + ") { ";
        if (it.async) {
          out += " var async" + $lvl + " = " + $format + ".async; ";
        }
        out += " " + $format + " = " + $format + ".validate; } if (  ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
        }
        out += " (";
        if ($unknownFormats != "ignore") {
          out += " (" + $schemaValue + " && !" + $format + " ";
          if ($allowUnknown) {
            out += " && self._opts.unknownFormats.indexOf(" + $schemaValue + ") == -1 ";
          }
          out += ") || ";
        }
        out += " (" + $format + " && " + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ";
        if (it.async) {
          out += " (async" + $lvl + " ? await " + $format + "(" + $data + ") : " + $format + "(" + $data + ")) ";
        } else {
          out += " " + $format + "(" + $data + ") ";
        }
        out += " : " + $format + ".test(" + $data + "))))) {";
      } else {
        var $format = it.formats[$schema];
        if (!$format) {
          if ($unknownFormats == "ignore") {
            it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
            if ($breakOnError) {
              out += " if (true) { ";
            }
            return out;
          } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
            if ($breakOnError) {
              out += " if (true) { ";
            }
            return out;
          } else {
            throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
          }
        }
        var $isObject = typeof $format == "object" && !($format instanceof RegExp) && $format.validate;
        var $formatType = $isObject && $format.type || "string";
        if ($isObject) {
          var $async = $format.async === true;
          $format = $format.validate;
        }
        if ($formatType != $ruleType) {
          if ($breakOnError) {
            out += " if (true) { ";
          }
          return out;
        }
        if ($async) {
          if (!it.async)
            throw new Error("async format in sync schema");
          var $formatRef = "formats" + it.util.getProperty($schema) + ".validate";
          out += " if (!(await " + $formatRef + "(" + $data + "))) { ";
        } else {
          out += " if (! ";
          var $formatRef = "formats" + it.util.getProperty($schema);
          if ($isObject)
            $formatRef += ".validate";
          if (typeof $format == "function") {
            out += " " + $formatRef + "(" + $data + ") ";
          } else {
            out += " " + $formatRef + ".test(" + $data + ") ";
          }
          out += ") { ";
        }
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'format' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { format:  ";
        if ($isData) {
          out += "" + $schemaValue;
        } else {
          out += "" + it.util.toQuotedString($schema);
        }
        out += "  } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should match format "`;
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + it.util.escapeQuotes($schema);
          }
          out += `"' `;
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + it.util.toQuotedString($schema);
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/dotjs/if.js
var require_if = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/dotjs/if.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function generate_if(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $thenSch = it.schema["then"], $elseSch = it.schema["else"], $thenPresent = $thenSch !== void 0 && (it.opts.strictKeywords ? typeof $thenSch == "object" && Object.keys($thenSch).length > 0 || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)), $elsePresent = $elseSch !== void 0 && (it.opts.strictKeywords ? typeof $elseSch == "object" && Object.keys($elseSch).length > 0 || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)), $currentBaseId = $it.baseId;
      if ($thenPresent || $elsePresent) {
        var $ifClause;
        $it.createErrors = false;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $errs + " = errors; var " + $valid + " = true;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        $it.createErrors = true;
        out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }  ";
        it.compositeRule = $it.compositeRule = $wasComposite;
        if ($thenPresent) {
          out += " if (" + $nextValid + ") {  ";
          $it.schema = it.schema["then"];
          $it.schemaPath = it.schemaPath + ".then";
          $it.errSchemaPath = it.errSchemaPath + "/then";
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " " + $valid + " = " + $nextValid + "; ";
          if ($thenPresent && $elsePresent) {
            $ifClause = "ifClause" + $lvl;
            out += " var " + $ifClause + " = 'then'; ";
          } else {
            $ifClause = "'then'";
          }
          out += " } ";
          if ($elsePresent) {
            out += " else { ";
          }
        } else {
          out += " if (!" + $nextValid + ") { ";
        }
        if ($elsePresent) {
          $it.schema = it.schema["else"];
          $it.schemaPath = it.schemaPath + ".else";
          $it.errSchemaPath = it.errSchemaPath + "/else";
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " " + $valid + " = " + $nextValid + "; ";
          if ($thenPresent && $elsePresent) {
            $ifClause = "ifClause" + $lvl;
            out += " var " + $ifClause + " = 'else'; ";
          } else {
            $ifClause = "'else'";
          }
          out += " } ";
        }
        out += " if (!" + $valid + ") {   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'if' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { failingKeyword: " + $ifClause + " } ";
          if (it.opts.messages !== false) {
            out += ` , message: 'should match "' + ` + $ifClause + ` + '" schema' `;
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        out += " }   ";
        if ($breakOnError) {
          out += " else { ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/dotjs/items.js
var require_items = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/dotjs/items.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function generate_items(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId;
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if (Array.isArray($schema)) {
        var $additionalItems = it.schema.additionalItems;
        if ($additionalItems === false) {
          out += " " + $valid + " = " + $data + ".length <= " + $schema.length + "; ";
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + "/additionalItems";
          out += "  if (!" + $valid + ") {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schema.length + " } ";
            if (it.opts.messages !== false) {
              out += " , message: 'should NOT have more than " + $schema.length + " items' ";
            }
            if (it.opts.verbose) {
              out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } ";
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            $closingBraces += "}";
            out += " else { ";
          }
        }
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              out += " " + $nextValid + " = true; if (" + $data + ".length > " + $i + ") { ";
              var $passData = $data + "[" + $i + "]";
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + "[" + $i + "]";
              $it.errSchemaPath = $errSchemaPath + "/" + $i;
              $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
              $it.dataPathArr[$dataNxt] = $i;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              out += " }  ";
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
          }
        }
        if (typeof $additionalItems == "object" && (it.opts.strictKeywords ? typeof $additionalItems == "object" && Object.keys($additionalItems).length > 0 || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
          $it.schema = $additionalItems;
          $it.schemaPath = it.schemaPath + ".additionalItems";
          $it.errSchemaPath = it.errSchemaPath + "/additionalItems";
          out += " " + $nextValid + " = true; if (" + $data + ".length > " + $schema.length + ") {  for (var " + $idx + " = " + $schema.length + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
          $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
          var $passData = $data + "[" + $idx + "]";
          $it.dataPathArr[$dataNxt] = $idx;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          if ($breakOnError) {
            out += " if (!" + $nextValid + ") break; ";
          }
          out += " } }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      } else if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += "  for (var " + $idx + " = " + 0 + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        if ($breakOnError) {
          out += " if (!" + $nextValid + ") break; ";
        }
        out += " }";
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/dotjs/_limit.js
var require_limit = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/dotjs/_limit.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function generate__limit(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $isMax = $keyword == "maximum", $exclusiveKeyword = $isMax ? "exclusiveMaximum" : "exclusiveMinimum", $schemaExcl = it.schema[$exclusiveKeyword], $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $notOp = $isMax ? ">" : "<", $errorKeyword = void 0;
      if (!($isData || typeof $schema == "number" || $schema === void 0)) {
        throw new Error($keyword + " must be number");
      }
      if (!($isDataExcl || $schemaExcl === void 0 || typeof $schemaExcl == "number" || typeof $schemaExcl == "boolean")) {
        throw new Error($exclusiveKeyword + " must be number or boolean");
      }
      if ($isDataExcl) {
        var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr), $exclusive = "exclusive" + $lvl, $exclType = "exclType" + $lvl, $exclIsNumber = "exclIsNumber" + $lvl, $opExpr = "op" + $lvl, $opStr = "' + " + $opExpr + " + '";
        out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ";
        $schemaValueExcl = "schemaExcl" + $lvl;
        out += " var " + $exclusive + "; var " + $exclType + " = typeof " + $schemaValueExcl + "; if (" + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
        var $errorKeyword = $exclusiveKeyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: '" + $exclusiveKeyword + " should be boolean' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " " + $exclType + " == 'number' ? ( (" + $exclusive + " = " + $schemaValue + " === undefined || " + $schemaValueExcl + " " + $op + "= " + $schemaValue + ") ? " + $data + " " + $notOp + "= " + $schemaValueExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) : ( (" + $exclusive + " = " + $schemaValueExcl + " === true) ? " + $data + " " + $notOp + "= " + $schemaValue + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "='; ";
        if ($schema === void 0) {
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
          $schemaValue = $schemaValueExcl;
          $isData = $isDataExcl;
        }
      } else {
        var $exclIsNumber = typeof $schemaExcl == "number", $opStr = $op;
        if ($exclIsNumber && $isData) {
          var $opExpr = "'" + $opStr + "'";
          out += " if ( ";
          if ($isData) {
            out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
          }
          out += " ( " + $schemaValue + " === undefined || " + $schemaExcl + " " + $op + "= " + $schemaValue + " ? " + $data + " " + $notOp + "= " + $schemaExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { ";
        } else {
          if ($exclIsNumber && $schema === void 0) {
            $exclusive = true;
            $errorKeyword = $exclusiveKeyword;
            $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
            $schemaValue = $schemaExcl;
            $notOp += "=";
          } else {
            if ($exclIsNumber)
              $schemaValue = Math[$isMax ? "min" : "max"]($schemaExcl, $schema);
            if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
              $exclusive = true;
              $errorKeyword = $exclusiveKeyword;
              $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
              $notOp += "=";
            } else {
              $exclusive = false;
              $opStr += "=";
            }
          }
          var $opExpr = "'" + $opStr + "'";
          out += " if ( ";
          if ($isData) {
            out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
          }
          out += " " + $data + " " + $notOp + " " + $schemaValue + " || " + $data + " !== " + $data + ") { ";
        }
      }
      $errorKeyword = $errorKeyword || $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit: " + $schemaValue + ", exclusive: " + $exclusive + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be " + $opStr + " ";
          if ($isData) {
            out += "' + " + $schemaValue;
          } else {
            out += "" + $schemaValue + "'";
          }
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/dotjs/_limitItems.js
var require_limitItems = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/dotjs/_limitItems.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function generate__limitItems(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxItems" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitItems") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT have ";
          if ($keyword == "maxItems") {
            out += "more";
          } else {
            out += "fewer";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " items' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/dotjs/_limitLength.js
var require_limitLength = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/dotjs/_limitLength.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function generate__limitLength(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxLength" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      if (it.opts.unicode === false) {
        out += " " + $data + ".length ";
      } else {
        out += " ucs2length(" + $data + ") ";
      }
      out += " " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitLength") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT be ";
          if ($keyword == "maxLength") {
            out += "longer";
          } else {
            out += "shorter";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " characters' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/dotjs/_limitProperties.js
var require_limitProperties = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/dotjs/_limitProperties.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function generate__limitProperties(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxProperties" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " Object.keys(" + $data + ").length " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitProperties") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT have ";
          if ($keyword == "maxProperties") {
            out += "more";
          } else {
            out += "fewer";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " properties' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/dotjs/multipleOf.js
var require_multipleOf = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/dotjs/multipleOf.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function generate_multipleOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      out += "var division" + $lvl + ";if (";
      if ($isData) {
        out += " " + $schemaValue + " !== undefined && ( typeof " + $schemaValue + " != 'number' || ";
      }
      out += " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ";
      if (it.opts.multipleOfPrecision) {
        out += " Math.abs(Math.round(division" + $lvl + ") - division" + $lvl + ") > 1e-" + it.opts.multipleOfPrecision + " ";
      } else {
        out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ";
      }
      out += " ) ";
      if ($isData) {
        out += "  )  ";
      }
      out += " ) {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { multipleOf: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be multiple of ";
          if ($isData) {
            out += "' + " + $schemaValue;
          } else {
            out += "" + $schemaValue + "'";
          }
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/dotjs/not.js
var require_not = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/dotjs/not.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function generate_not(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = "valid" + $it.level;
      if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $errs + " = errors;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.createErrors = false;
        var $allErrorsOption;
        if ($it.opts.allErrors) {
          $allErrorsOption = $it.opts.allErrors;
          $it.opts.allErrors = false;
        }
        out += " " + it.validate($it) + " ";
        $it.createErrors = true;
        if ($allErrorsOption)
          $it.opts.allErrors = $allErrorsOption;
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " if (" + $nextValid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT be valid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        if (it.opts.allErrors) {
          out += " } ";
        }
      } else {
        out += "  var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT be valid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if ($breakOnError) {
          out += " if (false) { ";
        }
      }
      return out;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/dotjs/oneOf.js
var require_oneOf = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/dotjs/oneOf.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function generate_oneOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $currentBaseId = $it.baseId, $prevValid = "prevValid" + $lvl, $passingSchemas = "passingSchemas" + $lvl;
      out += "var " + $errs + " = errors , " + $prevValid + " = false , " + $valid + " = false , " + $passingSchemas + " = null; ";
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
          } else {
            out += " var " + $nextValid + " = true; ";
          }
          if ($i) {
            out += " if (" + $nextValid + " && " + $prevValid + ") { " + $valid + " = false; " + $passingSchemas + " = [" + $passingSchemas + ", " + $i + "]; } else { ";
            $closingBraces += "}";
          }
          out += " if (" + $nextValid + ") { " + $valid + " = " + $prevValid + " = true; " + $passingSchemas + " = " + $i + "; }";
        }
      }
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { passingSchemas: " + $passingSchemas + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should match exactly one schema in oneOf' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      out += "} else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }";
      if (it.opts.allErrors) {
        out += " } ";
      }
      return out;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/dotjs/pattern.js
var require_pattern = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/dotjs/pattern.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function generate_pattern(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $regexp = $isData ? "(new RegExp(" + $schemaValue + "))" : it.usePattern($schema);
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
      }
      out += " !" + $regexp + ".test(" + $data + ") ) {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { pattern:  ";
        if ($isData) {
          out += "" + $schemaValue;
        } else {
          out += "" + it.util.toQuotedString($schema);
        }
        out += "  } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should match pattern "`;
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + it.util.escapeQuotes($schema);
          }
          out += `"' `;
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + it.util.toQuotedString($schema);
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/dotjs/properties.js
var require_properties = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/dotjs/properties.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function generate_properties(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $key = "key" + $lvl, $idx = "idx" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl;
      var $schemaKeys = Object.keys($schema || {}).filter(notProto), $pProperties = it.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties).filter(notProto), $aProperties = it.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == "object" && Object.keys($aProperties).length, $removeAdditional = it.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
      var $required = it.schema.required;
      if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {
        var $requiredHash = it.util.toHash($required);
      }
      function notProto(p) {
        return p !== "__proto__";
      }
      out += "var " + $errs + " = errors;var " + $nextValid + " = true;";
      if ($ownProperties) {
        out += " var " + $dataProperties + " = undefined;";
      }
      if ($checkAdditional) {
        if ($ownProperties) {
          out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
        } else {
          out += " for (var " + $key + " in " + $data + ") { ";
        }
        if ($someProperties) {
          out += " var isAdditional" + $lvl + " = !(false ";
          if ($schemaKeys.length) {
            if ($schemaKeys.length > 8) {
              out += " || validate.schema" + $schemaPath + ".hasOwnProperty(" + $key + ") ";
            } else {
              var arr1 = $schemaKeys;
              if (arr1) {
                var $propertyKey, i1 = -1, l1 = arr1.length - 1;
                while (i1 < l1) {
                  $propertyKey = arr1[i1 += 1];
                  out += " || " + $key + " == " + it.util.toQuotedString($propertyKey) + " ";
                }
              }
            }
          }
          if ($pPropertyKeys.length) {
            var arr2 = $pPropertyKeys;
            if (arr2) {
              var $pProperty, $i = -1, l2 = arr2.length - 1;
              while ($i < l2) {
                $pProperty = arr2[$i += 1];
                out += " || " + it.usePattern($pProperty) + ".test(" + $key + ") ";
              }
            }
          }
          out += " ); if (isAdditional" + $lvl + ") { ";
        }
        if ($removeAdditional == "all") {
          out += " delete " + $data + "[" + $key + "]; ";
        } else {
          var $currentErrorPath = it.errorPath;
          var $additionalProperty = "' + " + $key + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          }
          if ($noAdditional) {
            if ($removeAdditional) {
              out += " delete " + $data + "[" + $key + "]; ";
            } else {
              out += " " + $nextValid + " = false; ";
              var $currErrSchemaPath = $errSchemaPath;
              $errSchemaPath = it.errSchemaPath + "/additionalProperties";
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { additionalProperty: '" + $additionalProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is an invalid additional property";
                  } else {
                    out += "should NOT have additional properties";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              $errSchemaPath = $currErrSchemaPath;
              if ($breakOnError) {
                out += " break; ";
              }
            }
          } else if ($additionalIsSchema) {
            if ($removeAdditional == "failing") {
              out += " var " + $errs + " = errors;  ";
              var $wasComposite = it.compositeRule;
              it.compositeRule = $it.compositeRule = true;
              $it.schema = $aProperties;
              $it.schemaPath = it.schemaPath + ".additionalProperties";
              $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
              $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              out += " if (!" + $nextValid + ") { errors = " + $errs + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + $data + "[" + $key + "]; }  ";
              it.compositeRule = $it.compositeRule = $wasComposite;
            } else {
              $it.schema = $aProperties;
              $it.schemaPath = it.schemaPath + ".additionalProperties";
              $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
              $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              if ($breakOnError) {
                out += " if (!" + $nextValid + ") break; ";
              }
            }
          }
          it.errorPath = $currentErrorPath;
        }
        if ($someProperties) {
          out += " } ";
        }
        out += " }  ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
      var $useDefaults = it.opts.useDefaults && !it.compositeRule;
      if ($schemaKeys.length) {
        var arr3 = $schemaKeys;
        if (arr3) {
          var $propertyKey, i3 = -1, l3 = arr3.length - 1;
          while (i3 < l3) {
            $propertyKey = arr3[i3 += 1];
            var $sch = $schema[$propertyKey];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              var $prop = it.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== void 0;
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + $prop;
              $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($propertyKey);
              $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
              $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                $code = it.util.varReplace($code, $nextData, $passData);
                var $useData = $passData;
              } else {
                var $useData = $nextData;
                out += " var " + $nextData + " = " + $passData + "; ";
              }
              if ($hasDefault) {
                out += " " + $code + " ";
              } else {
                if ($requiredHash && $requiredHash[$propertyKey]) {
                  out += " if ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") { " + $nextValid + " = false; ";
                  var $currentErrorPath = it.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it.util.escapeQuotes($propertyKey);
                  if (it.opts._errorDataPathProperty) {
                    it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                  }
                  $errSchemaPath = it.errSchemaPath + "/required";
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  if (it.createErrors !== false) {
                    out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: '";
                      if (it.opts._errorDataPathProperty) {
                        out += "is a required property";
                      } else {
                        out += "should have required property \\'" + $missingProperty + "\\'";
                      }
                      out += "' ";
                    }
                    if (it.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    if (it.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                  $errSchemaPath = $currErrSchemaPath;
                  it.errorPath = $currentErrorPath;
                  out += " } else { ";
                } else {
                  if ($breakOnError) {
                    out += " if ( " + $useData + " === undefined ";
                    if ($ownProperties) {
                      out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                    }
                    out += ") { " + $nextValid + " = true; } else { ";
                  } else {
                    out += " if (" + $useData + " !== undefined ";
                    if ($ownProperties) {
                      out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                    }
                    out += " ) { ";
                  }
                }
                out += " " + $code + " } ";
              }
            }
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr4 = $pPropertyKeys;
        if (arr4) {
          var $pProperty, i4 = -1, l4 = arr4.length - 1;
          while (i4 < l4) {
            $pProperty = arr4[i4 += 1];
            var $sch = $pProperties[$pProperty];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              $it.schema = $sch;
              $it.schemaPath = it.schemaPath + ".patternProperties" + it.util.getProperty($pProperty);
              $it.errSchemaPath = it.errSchemaPath + "/patternProperties/" + it.util.escapeFragment($pProperty);
              if ($ownProperties) {
                out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
              } else {
                out += " for (var " + $key + " in " + $data + ") { ";
              }
              out += " if (" + it.usePattern($pProperty) + ".test(" + $key + ")) { ";
              $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              if ($breakOnError) {
                out += " if (!" + $nextValid + ") break; ";
              }
              out += " } ";
              if ($breakOnError) {
                out += " else " + $nextValid + " = true; ";
              }
              out += " }  ";
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
          }
        }
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/dotjs/propertyNames.js
var require_propertyNames = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/dotjs/propertyNames.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function generate_propertyNames(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      out += "var " + $errs + " = errors;";
      if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        var $key = "key" + $lvl, $idx = "idx" + $lvl, $i = "i" + $lvl, $invalidName = "' + " + $key + " + '", $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
        if ($ownProperties) {
          out += " var " + $dataProperties + " = undefined; ";
        }
        if ($ownProperties) {
          out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
        } else {
          out += " for (var " + $key + " in " + $data + ") { ";
        }
        out += " var startErrs" + $lvl + " = errors; ";
        var $passData = $key;
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " if (!" + $nextValid + ") { for (var " + $i + "=startErrs" + $lvl + "; " + $i + "<errors; " + $i + "++) { vErrors[" + $i + "].propertyName = " + $key + "; }   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { propertyName: '" + $invalidName + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        if ($breakOnError) {
          out += " break; ";
        }
        out += " } }";
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/dotjs/required.js
var require_required = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/dotjs/required.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function generate_required(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $vSchema = "schema" + $lvl;
      if (!$isData) {
        if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
          var $required = [];
          var arr1 = $schema;
          if (arr1) {
            var $property, i1 = -1, l1 = arr1.length - 1;
            while (i1 < l1) {
              $property = arr1[i1 += 1];
              var $propertySch = it.schema.properties[$property];
              if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == "object" && Object.keys($propertySch).length > 0 || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
                $required[$required.length] = $property;
              }
            }
          }
        } else {
          var $required = $schema;
        }
      }
      if ($isData || $required.length) {
        var $currentErrorPath = it.errorPath, $loopRequired = $isData || $required.length >= it.opts.loopRequired, $ownProperties = it.opts.ownProperties;
        if ($breakOnError) {
          out += " var missing" + $lvl + "; ";
          if ($loopRequired) {
            if (!$isData) {
              out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
            }
            var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
            }
            out += " var " + $valid + " = true; ";
            if ($isData) {
              out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
            }
            out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { " + $valid + " = " + $data + "[" + $vSchema + "[" + $i + "]] !== undefined ";
            if ($ownProperties) {
              out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
            }
            out += "; if (!" + $valid + ") break; } ";
            if ($isData) {
              out += "  }  ";
            }
            out += "  if (!" + $valid + ") {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } else { ";
          } else {
            out += " if ( ";
            var arr2 = $required;
            if (arr2) {
              var $propertyKey, $i = -1, l2 = arr2.length - 1;
              while ($i < l2) {
                $propertyKey = arr2[$i += 1];
                if ($i) {
                  out += " || ";
                }
                var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                out += " ( ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
              }
            }
            out += ") {  ";
            var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } else { ";
          }
        } else {
          if ($loopRequired) {
            if (!$isData) {
              out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
            }
            var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
            }
            if ($isData) {
              out += " if (" + $vSchema + " && !Array.isArray(" + $vSchema + ")) {  var err =   ";
              if (it.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + $vSchema + " !== undefined) { ";
            }
            out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { if (" + $data + "[" + $vSchema + "[" + $i + "]] === undefined ";
            if ($ownProperties) {
              out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
            }
            out += ") {  var err =   ";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ";
            if ($isData) {
              out += "  }  ";
            }
          } else {
            var arr3 = $required;
            if (arr3) {
              var $propertyKey, i3 = -1, l3 = arr3.length - 1;
              while (i3 < l3) {
                $propertyKey = arr3[i3 += 1];
                var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") {  var err =   ";
                if (it.createErrors !== false) {
                  out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: '";
                    if (it.opts._errorDataPathProperty) {
                      out += "is a required property";
                    } else {
                      out += "should have required property \\'" + $missingProperty + "\\'";
                    }
                    out += "' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
              }
            }
          }
        }
        it.errorPath = $currentErrorPath;
      } else if ($breakOnError) {
        out += " if (true) {";
      }
      return out;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/dotjs/uniqueItems.js
var require_uniqueItems = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/dotjs/uniqueItems.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (($schema || $isData) && it.opts.uniqueItems !== false) {
        if ($isData) {
          out += " var " + $valid + "; if (" + $schemaValue + " === false || " + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'boolean') " + $valid + " = false; else { ";
        }
        out += " var i = " + $data + ".length , " + $valid + " = true , j; if (i > 1) { ";
        var $itemType = it.schema.items && it.schema.items.type, $typeIsArray = Array.isArray($itemType);
        if (!$itemType || $itemType == "object" || $itemType == "array" || $typeIsArray && ($itemType.indexOf("object") >= 0 || $itemType.indexOf("array") >= 0)) {
          out += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + $data + "[i], " + $data + "[j])) { " + $valid + " = false; break outer; } } } ";
        } else {
          out += " var itemIndices = {}, item; for (;i--;) { var item = " + $data + "[i]; ";
          var $method = "checkDataType" + ($typeIsArray ? "s" : "");
          out += " if (" + it.util[$method]($itemType, "item", it.opts.strictNumbers, true) + ") continue; ";
          if ($typeIsArray) {
            out += ` if (typeof item == 'string') item = '"' + item; `;
          }
          out += " if (typeof itemIndices[item] == 'number') { " + $valid + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
        }
        out += " } ";
        if ($isData) {
          out += "  }  ";
        }
        out += " if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { i: i, j: j } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
          }
          if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + $schema;
            }
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } ";
        if ($breakOnError) {
          out += " else { ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/dotjs/index.js
var require_dotjs = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/dotjs/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = {
      "$ref": require_ref(),
      allOf: require_allOf(),
      anyOf: require_anyOf(),
      "$comment": require_comment(),
      const: require_const(),
      contains: require_contains(),
      dependencies: require_dependencies(),
      "enum": require_enum(),
      format: require_format(),
      "if": require_if(),
      items: require_items(),
      maximum: require_limit(),
      minimum: require_limit(),
      maxItems: require_limitItems(),
      minItems: require_limitItems(),
      maxLength: require_limitLength(),
      minLength: require_limitLength(),
      maxProperties: require_limitProperties(),
      minProperties: require_limitProperties(),
      multipleOf: require_multipleOf(),
      not: require_not(),
      oneOf: require_oneOf(),
      pattern: require_pattern(),
      properties: require_properties(),
      propertyNames: require_propertyNames(),
      required: require_required(),
      uniqueItems: require_uniqueItems(),
      validate: require_validate()
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/compile/rules.js
var require_rules = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/compile/rules.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var ruleModules = require_dotjs();
    var toHash = require_util().toHash;
    module2.exports = function rules() {
      var RULES = [
        {
          type: "number",
          rules: [
            { "maximum": ["exclusiveMaximum"] },
            { "minimum": ["exclusiveMinimum"] },
            "multipleOf",
            "format"
          ]
        },
        {
          type: "string",
          rules: ["maxLength", "minLength", "pattern", "format"]
        },
        {
          type: "array",
          rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
        },
        {
          type: "object",
          rules: [
            "maxProperties",
            "minProperties",
            "required",
            "dependencies",
            "propertyNames",
            { "properties": ["additionalProperties", "patternProperties"] }
          ]
        },
        { rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"] }
      ];
      var ALL = ["type", "$comment"];
      var KEYWORDS = [
        "$schema",
        "$id",
        "id",
        "$data",
        "$async",
        "title",
        "description",
        "default",
        "definitions",
        "examples",
        "readOnly",
        "writeOnly",
        "contentMediaType",
        "contentEncoding",
        "additionalItems",
        "then",
        "else"
      ];
      var TYPES = ["number", "integer", "string", "array", "object", "boolean", "null"];
      RULES.all = toHash(ALL);
      RULES.types = toHash(TYPES);
      RULES.forEach(function(group) {
        group.rules = group.rules.map(function(keyword) {
          var implKeywords;
          if (typeof keyword == "object") {
            var key = Object.keys(keyword)[0];
            implKeywords = keyword[key];
            keyword = key;
            implKeywords.forEach(function(k) {
              ALL.push(k);
              RULES.all[k] = true;
            });
          }
          ALL.push(keyword);
          var rule = RULES.all[keyword] = {
            keyword,
            code: ruleModules[keyword],
            implements: implKeywords
          };
          return rule;
        });
        RULES.all.$comment = {
          keyword: "$comment",
          code: ruleModules.$comment
        };
        if (group.type)
          RULES.types[group.type] = group;
      });
      RULES.keywords = toHash(ALL.concat(KEYWORDS));
      RULES.custom = {};
      return RULES;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/data.js
var require_data = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/data.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var KEYWORDS = [
      "multipleOf",
      "maximum",
      "exclusiveMaximum",
      "minimum",
      "exclusiveMinimum",
      "maxLength",
      "minLength",
      "pattern",
      "additionalItems",
      "maxItems",
      "minItems",
      "uniqueItems",
      "maxProperties",
      "minProperties",
      "required",
      "additionalProperties",
      "enum",
      "format",
      "const"
    ];
    module2.exports = function(metaSchema, keywordsJsonPointers) {
      for (var i = 0; i < keywordsJsonPointers.length; i++) {
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        var segments = keywordsJsonPointers[i].split("/");
        var keywords = metaSchema;
        var j;
        for (j = 1; j < segments.length; j++)
          keywords = keywords[segments[j]];
        for (j = 0; j < KEYWORDS.length; j++) {
          var key = KEYWORDS[j];
          var schema = keywords[key];
          if (schema) {
            keywords[key] = {
              anyOf: [
                schema,
                { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
              ]
            };
          }
        }
      }
      return metaSchema;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/compile/async.js
var require_async = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/compile/async.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var MissingRefError = require_error_classes().MissingRef;
    module2.exports = compileAsync;
    function compileAsync(schema, meta, callback) {
      var self = this;
      if (typeof this._opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      if (typeof meta == "function") {
        callback = meta;
        meta = void 0;
      }
      var p = loadMetaSchemaOf(schema).then(function() {
        var schemaObj = self._addSchema(schema, void 0, meta);
        return schemaObj.validate || _compileAsync(schemaObj);
      });
      if (callback) {
        p.then(function(v) {
          callback(null, v);
        }, callback);
      }
      return p;
      function loadMetaSchemaOf(sch) {
        var $schema = sch.$schema;
        return $schema && !self.getSchema($schema) ? compileAsync.call(self, { $ref: $schema }, true) : Promise.resolve();
      }
      function _compileAsync(schemaObj) {
        try {
          return self._compile(schemaObj);
        } catch (e) {
          if (e instanceof MissingRefError)
            return loadMissingSchema(e);
          throw e;
        }
        function loadMissingSchema(e) {
          var ref = e.missingSchema;
          if (added(ref))
            throw new Error("Schema " + ref + " is loaded but " + e.missingRef + " cannot be resolved");
          var schemaPromise = self._loadingSchemas[ref];
          if (!schemaPromise) {
            schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
            schemaPromise.then(removePromise, removePromise);
          }
          return schemaPromise.then(function(sch) {
            if (!added(ref)) {
              return loadMetaSchemaOf(sch).then(function() {
                if (!added(ref))
                  self.addSchema(sch, ref, void 0, meta);
              });
            }
          }).then(function() {
            return _compileAsync(schemaObj);
          });
          function removePromise() {
            delete self._loadingSchemas[ref];
          }
          function added(ref2) {
            return self._refs[ref2] || self._schemas[ref2];
          }
        }
      }
    }
  }
});

// packages/platform-fastify/node_modules/ajv/lib/dotjs/custom.js
var require_custom = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/dotjs/custom.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function generate_custom(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $rule = this, $definition = "definition" + $lvl, $rDef = $rule.definition, $closingBraces = "";
      var $compile, $inline, $macro, $ruleValidate, $validateCode;
      if ($isData && $rDef.$data) {
        $validateCode = "keywordValidate" + $lvl;
        var $validateSchema = $rDef.validateSchema;
        out += " var " + $definition + " = RULES.custom['" + $keyword + "'].definition; var " + $validateCode + " = " + $definition + ".validate;";
      } else {
        $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
        if (!$ruleValidate)
          return;
        $schemaValue = "validate.schema" + $schemaPath;
        $validateCode = $ruleValidate.code;
        $compile = $rDef.compile;
        $inline = $rDef.inline;
        $macro = $rDef.macro;
      }
      var $ruleErrs = $validateCode + ".errors", $i = "i" + $lvl, $ruleErr = "ruleErr" + $lvl, $asyncKeyword = $rDef.async;
      if ($asyncKeyword && !it.async)
        throw new Error("async keyword in sync schema");
      if (!($inline || $macro)) {
        out += "" + $ruleErrs + " = null;";
      }
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if ($isData && $rDef.$data) {
        $closingBraces += "}";
        out += " if (" + $schemaValue + " === undefined) { " + $valid + " = true; } else { ";
        if ($validateSchema) {
          $closingBraces += "}";
          out += " " + $valid + " = " + $definition + ".validateSchema(" + $schemaValue + "); if (" + $valid + ") { ";
        }
      }
      if ($inline) {
        if ($rDef.statements) {
          out += " " + $ruleValidate.validate + " ";
        } else {
          out += " " + $valid + " = " + $ruleValidate.validate + "; ";
        }
      } else if ($macro) {
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        $it.schema = $ruleValidate.validate;
        $it.schemaPath = "";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $code;
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        out += "  " + $validateCode + ".call( ";
        if (it.opts.passContext) {
          out += "this";
        } else {
          out += "self";
        }
        if ($compile || $rDef.schema === false) {
          out += " , " + $data + " ";
        } else {
          out += " , " + $schemaValue + " , " + $data + " , validate.schema" + it.schemaPath + " ";
        }
        out += " , (dataPath || '')";
        if (it.errorPath != '""') {
          out += " + " + it.errorPath;
        }
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " , " + $parentData + " , " + $parentDataProperty + " , rootData )  ";
        var def_callRuleValidate = out;
        out = $$outStack.pop();
        if ($rDef.errors === false) {
          out += " " + $valid + " = ";
          if ($asyncKeyword) {
            out += "await ";
          }
          out += "" + def_callRuleValidate + "; ";
        } else {
          if ($asyncKeyword) {
            $ruleErrs = "customErrors" + $lvl;
            out += " var " + $ruleErrs + " = null; try { " + $valid + " = await " + def_callRuleValidate + "; } catch (e) { " + $valid + " = false; if (e instanceof ValidationError) " + $ruleErrs + " = e.errors; else throw e; } ";
          } else {
            out += " " + $ruleErrs + " = null; " + $valid + " = " + def_callRuleValidate + "; ";
          }
        }
      }
      if ($rDef.modifying) {
        out += " if (" + $parentData + ") " + $data + " = " + $parentData + "[" + $parentDataProperty + "];";
      }
      out += "" + $closingBraces;
      if ($rDef.valid) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      } else {
        out += " if ( ";
        if ($rDef.valid === void 0) {
          out += " !";
          if ($macro) {
            out += "" + $nextValid;
          } else {
            out += "" + $valid;
          }
        } else {
          out += " " + !$rDef.valid + " ";
        }
        out += ") { ";
        $errorKeyword = $rule.keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
          if (it.opts.messages !== false) {
            out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        var def_customError = out;
        out = $$outStack.pop();
        if ($inline) {
          if ($rDef.errors) {
            if ($rDef.errors != "full") {
              out += "  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
              if (it.opts.verbose) {
                out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
              }
              out += " } ";
            }
          } else {
            if ($rDef.errors === false) {
              out += " " + def_customError + " ";
            } else {
              out += " if (" + $errs + " == errors) { " + def_customError + " } else {  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
              if (it.opts.verbose) {
                out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
              }
              out += " } } ";
            }
          }
        } else if ($macro) {
          out += "   var err =   ";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
            if (it.opts.messages !== false) {
              out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError(vErrors); ";
            } else {
              out += " validate.errors = vErrors; return false; ";
            }
          }
        } else {
          if ($rDef.errors === false) {
            out += " " + def_customError + " ";
          } else {
            out += " if (Array.isArray(" + $ruleErrs + ")) { if (vErrors === null) vErrors = " + $ruleErrs + "; else vErrors = vErrors.concat(" + $ruleErrs + "); errors = vErrors.length;  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + ";  " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
            if (it.opts.verbose) {
              out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
            }
            out += " } } else { " + def_customError + " } ";
          }
        }
        out += " } ";
        if ($breakOnError) {
          out += " else { ";
        }
      }
      return out;
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/refs/json-schema-draft-07.json"(exports2, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [
            { $ref: "#/definitions/nonNegativeInteger" },
            { default: 0 }
          ]
        },
        simpleTypes: {
          enum: [
            "array",
            "boolean",
            "integer",
            "null",
            "number",
            "object",
            "string"
          ]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [
            { $ref: "#" },
            { $ref: "#/definitions/schemaArray" }
          ],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [
              { $ref: "#" },
              { $ref: "#/definitions/stringArray" }
            ]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/definition_schema.js
var require_definition_schema = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/definition_schema.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var metaSchema = require_json_schema_draft_07();
    module2.exports = {
      $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
      definitions: {
        simpleTypes: metaSchema.definitions.simpleTypes
      },
      type: "object",
      dependencies: {
        schema: ["validate"],
        $data: ["validate"],
        statements: ["inline"],
        valid: { not: { required: ["macro"] } }
      },
      properties: {
        type: metaSchema.properties.type,
        schema: { type: "boolean" },
        statements: { type: "boolean" },
        dependencies: {
          type: "array",
          items: { type: "string" }
        },
        metaSchema: { type: "object" },
        modifying: { type: "boolean" },
        valid: { type: "boolean" },
        $data: { type: "boolean" },
        async: { type: "boolean" },
        errors: {
          anyOf: [
            { type: "boolean" },
            { const: "full" }
          ]
        }
      }
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/keyword.js
var require_keyword = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/keyword.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
    var customRuleCode = require_custom();
    var definitionSchema = require_definition_schema();
    module2.exports = {
      add: addKeyword,
      get: getKeyword,
      remove: removeKeyword,
      validate: validateKeyword
    };
    function addKeyword(keyword, definition) {
      var RULES = this.RULES;
      if (RULES.keywords[keyword])
        throw new Error("Keyword " + keyword + " is already defined");
      if (!IDENTIFIER.test(keyword))
        throw new Error("Keyword " + keyword + " is not a valid identifier");
      if (definition) {
        this.validateKeyword(definition, true);
        var dataType = definition.type;
        if (Array.isArray(dataType)) {
          for (var i = 0; i < dataType.length; i++)
            _addRule(keyword, dataType[i], definition);
        } else {
          _addRule(keyword, dataType, definition);
        }
        var metaSchema = definition.metaSchema;
        if (metaSchema) {
          if (definition.$data && this._opts.$data) {
            metaSchema = {
              anyOf: [
                metaSchema,
                { "$ref": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
              ]
            };
          }
          definition.validateSchema = this.compile(metaSchema, true);
        }
      }
      RULES.keywords[keyword] = RULES.all[keyword] = true;
      function _addRule(keyword2, dataType2, definition2) {
        var ruleGroup;
        for (var i2 = 0; i2 < RULES.length; i2++) {
          var rg = RULES[i2];
          if (rg.type == dataType2) {
            ruleGroup = rg;
            break;
          }
        }
        if (!ruleGroup) {
          ruleGroup = { type: dataType2, rules: [] };
          RULES.push(ruleGroup);
        }
        var rule = {
          keyword: keyword2,
          definition: definition2,
          custom: true,
          code: customRuleCode,
          implements: definition2.implements
        };
        ruleGroup.rules.push(rule);
        RULES.custom[keyword2] = rule;
      }
      return this;
    }
    function getKeyword(keyword) {
      var rule = this.RULES.custom[keyword];
      return rule ? rule.definition : this.RULES.keywords[keyword] || false;
    }
    function removeKeyword(keyword) {
      var RULES = this.RULES;
      delete RULES.keywords[keyword];
      delete RULES.all[keyword];
      delete RULES.custom[keyword];
      for (var i = 0; i < RULES.length; i++) {
        var rules = RULES[i].rules;
        for (var j = 0; j < rules.length; j++) {
          if (rules[j].keyword == keyword) {
            rules.splice(j, 1);
            break;
          }
        }
      }
      return this;
    }
    function validateKeyword(definition, throwError) {
      validateKeyword.errors = null;
      var v = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);
      if (v(definition))
        return true;
      validateKeyword.errors = v.errors;
      if (throwError)
        throw new Error("custom keyword definition is invalid: " + this.errorsText(v.errors));
      else
        return false;
    }
  }
});

// packages/platform-fastify/node_modules/ajv/lib/refs/data.json
var require_data2 = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/refs/data.json"(exports2, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON Schema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [
            { format: "relative-json-pointer" },
            { format: "json-pointer" }
          ]
        }
      },
      additionalProperties: false
    };
  }
});

// packages/platform-fastify/node_modules/ajv/lib/ajv.js
var require_ajv = __commonJS({
  "packages/platform-fastify/node_modules/ajv/lib/ajv.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var compileSchema = require_compile();
    var resolve = require_resolve();
    var Cache = require_cache();
    var SchemaObject = require_schema_obj();
    var stableStringify = require_fast_json_stable_stringify();
    var formats = require_formats();
    var rules = require_rules();
    var $dataMetaSchema = require_data();
    var util = require_util();
    module2.exports = Ajv;
    Ajv.prototype.validate = validate;
    Ajv.prototype.compile = compile;
    Ajv.prototype.addSchema = addSchema;
    Ajv.prototype.addMetaSchema = addMetaSchema;
    Ajv.prototype.validateSchema = validateSchema;
    Ajv.prototype.getSchema = getSchema;
    Ajv.prototype.removeSchema = removeSchema;
    Ajv.prototype.addFormat = addFormat;
    Ajv.prototype.errorsText = errorsText;
    Ajv.prototype._addSchema = _addSchema;
    Ajv.prototype._compile = _compile;
    Ajv.prototype.compileAsync = require_async();
    var customKeyword = require_keyword();
    Ajv.prototype.addKeyword = customKeyword.add;
    Ajv.prototype.getKeyword = customKeyword.get;
    Ajv.prototype.removeKeyword = customKeyword.remove;
    Ajv.prototype.validateKeyword = customKeyword.validate;
    var errorClasses = require_error_classes();
    Ajv.ValidationError = errorClasses.Validation;
    Ajv.MissingRefError = errorClasses.MissingRef;
    Ajv.$dataMetaSchema = $dataMetaSchema;
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"];
    var META_SUPPORT_DATA = ["/properties"];
    function Ajv(opts) {
      if (!(this instanceof Ajv))
        return new Ajv(opts);
      opts = this._opts = util.copy(opts) || {};
      setLogger(this);
      this._schemas = {};
      this._refs = {};
      this._fragments = {};
      this._formats = formats(opts.format);
      this._cache = opts.cache || new Cache();
      this._loadingSchemas = {};
      this._compilations = [];
      this.RULES = rules();
      this._getId = chooseGetId(opts);
      opts.loopRequired = opts.loopRequired || Infinity;
      if (opts.errorDataPath == "property")
        opts._errorDataPathProperty = true;
      if (opts.serialize === void 0)
        opts.serialize = stableStringify;
      this._metaOpts = getMetaSchemaOptions(this);
      if (opts.formats)
        addInitialFormats(this);
      if (opts.keywords)
        addInitialKeywords(this);
      addDefaultMetaSchema(this);
      if (typeof opts.meta == "object")
        this.addMetaSchema(opts.meta);
      if (opts.nullable)
        this.addKeyword("nullable", { metaSchema: { type: "boolean" } });
      addInitialSchemas(this);
    }
    function validate(schemaKeyRef, data) {
      var v;
      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v)
          throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
      } else {
        var schemaObj = this._addSchema(schemaKeyRef);
        v = schemaObj.validate || this._compile(schemaObj);
      }
      var valid = v(data);
      if (v.$async !== true)
        this.errors = v.errors;
      return valid;
    }
    function compile(schema, _meta) {
      var schemaObj = this._addSchema(schema, void 0, _meta);
      return schemaObj.validate || this._compile(schemaObj);
    }
    function addSchema(schema, key, _skipValidation, _meta) {
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++)
          this.addSchema(schema[i], void 0, _skipValidation, _meta);
        return this;
      }
      var id = this._getId(schema);
      if (id !== void 0 && typeof id != "string")
        throw new Error("schema id must be string");
      key = resolve.normalizeId(key || id);
      checkUnique(this, key);
      this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
      return this;
    }
    function addMetaSchema(schema, key, skipValidation) {
      this.addSchema(schema, key, skipValidation, true);
      return this;
    }
    function validateSchema(schema, throwOrLogError) {
      var $schema = schema.$schema;
      if ($schema !== void 0 && typeof $schema != "string")
        throw new Error("$schema must be a string");
      $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
      if (!$schema) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      var valid = this.validate($schema, schema);
      if (!valid && throwOrLogError) {
        var message2 = "schema is invalid: " + this.errorsText();
        if (this._opts.validateSchema == "log")
          this.logger.error(message2);
        else
          throw new Error(message2);
      }
      return valid;
    }
    function defaultMeta(self) {
      var meta = self._opts.meta;
      self._opts.defaultMeta = typeof meta == "object" ? self._getId(meta) || meta : self.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0;
      return self._opts.defaultMeta;
    }
    function getSchema(keyRef) {
      var schemaObj = _getSchemaObj(this, keyRef);
      switch (typeof schemaObj) {
        case "object":
          return schemaObj.validate || this._compile(schemaObj);
        case "string":
          return this.getSchema(schemaObj);
        case "undefined":
          return _getSchemaFragment(this, keyRef);
      }
    }
    function _getSchemaFragment(self, ref) {
      var res = resolve.schema.call(self, { schema: {} }, ref);
      if (res) {
        var schema = res.schema, root = res.root, baseId = res.baseId;
        var v = compileSchema.call(self, schema, root, void 0, baseId);
        self._fragments[ref] = new SchemaObject({
          ref,
          fragment: true,
          schema,
          root,
          baseId,
          validate: v
        });
        return v;
      }
    }
    function _getSchemaObj(self, keyRef) {
      keyRef = resolve.normalizeId(keyRef);
      return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
    }
    function removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        _removeAllSchemas(this, this._schemas, schemaKeyRef);
        _removeAllSchemas(this, this._refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          _removeAllSchemas(this, this._schemas);
          _removeAllSchemas(this, this._refs);
          this._cache.clear();
          return this;
        case "string":
          var schemaObj = _getSchemaObj(this, schemaKeyRef);
          if (schemaObj)
            this._cache.del(schemaObj.cacheKey);
          delete this._schemas[schemaKeyRef];
          delete this._refs[schemaKeyRef];
          return this;
        case "object":
          var serialize = this._opts.serialize;
          var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
          this._cache.del(cacheKey);
          var id = this._getId(schemaKeyRef);
          if (id) {
            id = resolve.normalizeId(id);
            delete this._schemas[id];
            delete this._refs[id];
          }
      }
      return this;
    }
    function _removeAllSchemas(self, schemas, regex) {
      for (var keyRef in schemas) {
        var schemaObj = schemas[keyRef];
        if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
          self._cache.del(schemaObj.cacheKey);
          delete schemas[keyRef];
        }
      }
    }
    function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
      if (typeof schema != "object" && typeof schema != "boolean")
        throw new Error("schema should be object or boolean");
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schema) : schema;
      var cached = this._cache.get(cacheKey);
      if (cached)
        return cached;
      shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
      var id = resolve.normalizeId(this._getId(schema));
      if (id && shouldAddSchema)
        checkUnique(this, id);
      var willValidate = this._opts.validateSchema !== false && !skipValidation;
      var recursiveMeta;
      if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
        this.validateSchema(schema, true);
      var localRefs = resolve.ids.call(this, schema);
      var schemaObj = new SchemaObject({
        id,
        schema,
        localRefs,
        cacheKey,
        meta
      });
      if (id[0] != "#" && shouldAddSchema)
        this._refs[id] = schemaObj;
      this._cache.put(cacheKey, schemaObj);
      if (willValidate && recursiveMeta)
        this.validateSchema(schema, true);
      return schemaObj;
    }
    function _compile(schemaObj, root) {
      if (schemaObj.compiling) {
        schemaObj.validate = callValidate;
        callValidate.schema = schemaObj.schema;
        callValidate.errors = null;
        callValidate.root = root ? root : callValidate;
        if (schemaObj.schema.$async === true)
          callValidate.$async = true;
        return callValidate;
      }
      schemaObj.compiling = true;
      var currentOpts;
      if (schemaObj.meta) {
        currentOpts = this._opts;
        this._opts = this._metaOpts;
      }
      var v;
      try {
        v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
      } catch (e) {
        delete schemaObj.validate;
        throw e;
      } finally {
        schemaObj.compiling = false;
        if (schemaObj.meta)
          this._opts = currentOpts;
      }
      schemaObj.validate = v;
      schemaObj.refs = v.refs;
      schemaObj.refVal = v.refVal;
      schemaObj.root = v.root;
      return v;
      function callValidate() {
        var _validate = schemaObj.validate;
        var result = _validate.apply(this, arguments);
        callValidate.errors = _validate.errors;
        return result;
      }
    }
    function chooseGetId(opts) {
      switch (opts.schemaId) {
        case "auto":
          return _get$IdOrId;
        case "id":
          return _getId;
        default:
          return _get$Id;
      }
    }
    function _getId(schema) {
      if (schema.$id)
        this.logger.warn("schema $id ignored", schema.$id);
      return schema.id;
    }
    function _get$Id(schema) {
      if (schema.id)
        this.logger.warn("schema id ignored", schema.id);
      return schema.$id;
    }
    function _get$IdOrId(schema) {
      if (schema.$id && schema.id && schema.$id != schema.id)
        throw new Error("schema $id is different from id");
      return schema.$id || schema.id;
    }
    function errorsText(errors, options) {
      errors = errors || this.errors;
      if (!errors)
        return "No errors";
      options = options || {};
      var separator = options.separator === void 0 ? ", " : options.separator;
      var dataVar = options.dataVar === void 0 ? "data" : options.dataVar;
      var text = "";
      for (var i = 0; i < errors.length; i++) {
        var e = errors[i];
        if (e)
          text += dataVar + e.dataPath + " " + e.message + separator;
      }
      return text.slice(0, -separator.length);
    }
    function addFormat(name, format) {
      if (typeof format == "string")
        format = new RegExp(format);
      this._formats[name] = format;
      return this;
    }
    function addDefaultMetaSchema(self) {
      var $dataSchema;
      if (self._opts.$data) {
        $dataSchema = require_data2();
        self.addMetaSchema($dataSchema, $dataSchema.$id, true);
      }
      if (self._opts.meta === false)
        return;
      var metaSchema = require_json_schema_draft_07();
      if (self._opts.$data)
        metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
      self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
      self._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    function addInitialSchemas(self) {
      var optsSchemas = self._opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        self.addSchema(optsSchemas);
      else
        for (var key in optsSchemas)
          self.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats(self) {
      for (var name in self._opts.formats) {
        var format = self._opts.formats[name];
        self.addFormat(name, format);
      }
    }
    function addInitialKeywords(self) {
      for (var name in self._opts.keywords) {
        var keyword = self._opts.keywords[name];
        self.addKeyword(name, keyword);
      }
    }
    function checkUnique(self, id) {
      if (self._schemas[id] || self._refs[id])
        throw new Error('schema with key or id "' + id + '" already exists');
    }
    function getMetaSchemaOptions(self) {
      var metaOpts = util.copy(self._opts);
      for (var i = 0; i < META_IGNORE_OPTIONS.length; i++)
        delete metaOpts[META_IGNORE_OPTIONS[i]];
      return metaOpts;
    }
    function setLogger(self) {
      var logger2 = self._opts.logger;
      if (logger2 === false) {
        self.logger = { log: noop, warn: noop, error: noop };
      } else {
        if (logger2 === void 0)
          logger2 = console;
        if (!(typeof logger2 == "object" && logger2.log && logger2.warn && logger2.error))
          throw new Error("logger must implement log, warn and error methods");
        self.logger = logger2;
      }
    }
    function noop() {
    }
  }
});

// packages/platform-fastify/node_modules/@fastify/ajv-compiler/index.js
var require_ajv_compiler = __commonJS({
  "packages/platform-fastify/node_modules/@fastify/ajv-compiler/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var Ajv = require_ajv();
    function ValidatorSelector() {
      const validatorPool = /* @__PURE__ */ new Map();
      const cache = /* @__PURE__ */ new Map();
      cache.put = cache.set;
      return function buildCompilerFromPool(externalSchemas, options) {
        const externals = JSON.stringify(externalSchemas);
        const ajvConfig = JSON.stringify(options.customOptions);
        const uniqueAjvKey = `${externals}${ajvConfig}`;
        if (validatorPool.has(uniqueAjvKey)) {
          return validatorPool.get(uniqueAjvKey);
        }
        const compiler = ValidatorCompiler(externalSchemas, options, cache);
        validatorPool.set(uniqueAjvKey, compiler);
        return compiler;
      };
    }
    function ValidatorCompiler(externalSchemas, options, cache) {
      const ajv = new Ajv(Object.assign({
        coerceTypes: true,
        useDefaults: true,
        removeAdditional: true,
        allErrors: false,
        nullable: true
      }, options.customOptions, { cache }));
      if (options.plugins && options.plugins.length > 0) {
        for (const plugin of options.plugins) {
          if (Array.isArray(plugin)) {
            plugin[0](ajv, plugin[1]);
          } else {
            plugin(ajv);
          }
        }
      }
      const sourceSchemas = Object.values(externalSchemas);
      for (const extSchema of sourceSchemas) {
        ajv.addSchema(extSchema);
      }
      return function({ schema }) {
        if (schema.$id) {
          const stored = ajv.getSchema(schema.$id);
          if (stored) {
            return stored;
          }
        }
        return ajv.compile(schema);
      };
    }
    module2.exports = ValidatorSelector;
  }
});

// packages/platform-fastify/node_modules/fastify/lib/schema-controller.js
var require_schema_controller = __commonJS({
  "packages/platform-fastify/node_modules/fastify/lib/schema-controller.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var { buildSchemas } = require_schemas();
    var { serializerCompiler } = require_schema_compilers();
    var ValidatorSelector = require_ajv_compiler();
    function buildSchemaController(parentSchemaCtrl, opts) {
      if (parentSchemaCtrl) {
        return new SchemaController(parentSchemaCtrl, opts);
      }
      let compilersFactory = {
        buildValidator: ValidatorSelector(),
        buildSerializer: serializerCompiler
      };
      if (opts && opts.compilersFactory) {
        compilersFactory = Object.assign(compilersFactory, opts.compilersFactory);
      }
      const option = {
        bucket: opts && opts.bucket || buildSchemas,
        compilersFactory
      };
      return new SchemaController(void 0, option);
    }
    var SchemaController = class {
      constructor(parent2, options) {
        this.opts = options || parent2 && parent2.opts;
        this.addedSchemas = false;
        this.compilersFactory = this.opts.compilersFactory;
        if (parent2) {
          this.schemaBucket = this.opts.bucket(parent2.getSchemas());
          this.validatorCompiler = parent2.getValidatorCompiler();
          this.serializerCompiler = parent2.getSerializerCompiler();
          this.parent = parent2;
        } else {
          this.schemaBucket = this.opts.bucket();
        }
      }
      add(schema) {
        this.addedSchemas = true;
        return this.schemaBucket.add(schema);
      }
      getSchema(schemaId) {
        return this.schemaBucket.getSchema(schemaId);
      }
      getSchemas() {
        return this.schemaBucket.getSchemas();
      }
      setValidatorCompiler(validatorCompiler) {
        this.validatorCompiler = validatorCompiler;
      }
      setSerializerCompiler(serializerCompiler2) {
        this.serializerCompiler = serializerCompiler2;
      }
      getValidatorCompiler() {
        return this.validatorCompiler || this.parent && this.parent.getValidatorCompiler();
      }
      getSerializerCompiler() {
        return this.serializerCompiler || this.parent && this.parent.getSerializerCompiler();
      }
      getSerializerBuilder() {
        return this.compilersFactory.buildSerializer || this.parent && this.parent.getSerializerBuilder();
      }
      getValidatorBuilder() {
        return this.compilersFactory.buildValidator || this.parent && this.parent.getValidatorBuilder();
      }
      setupValidator(serverOption) {
        const isReady = this.validatorCompiler !== void 0 && !this.addedSchemas;
        if (isReady) {
          return;
        }
        this.validatorCompiler = this.getValidatorBuilder()(this.schemaBucket.getSchemas(), serverOption.ajv);
      }
      setupSerializer(serverOption) {
        const isReady = this.serializerCompiler !== void 0 && !this.addedSchemas;
        if (isReady) {
          return;
        }
        this.serializerCompiler = this.getSerializerBuilder()(this.schemaBucket.getSchemas(), serverOption.serializerOpts);
      }
    };
    SchemaController.buildSchemaController = buildSchemaController;
    module2.exports = SchemaController;
  }
});

// packages/platform-fastify/node_modules/fastify/lib/pluginUtils.js
var require_pluginUtils = __commonJS({
  "packages/platform-fastify/node_modules/fastify/lib/pluginUtils.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var semver = require_semver2();
    var assert = __require("assert");
    var registeredPlugins = Symbol.for("registered-plugin");
    var {
      kTestInternals
    } = require_symbols();
    var { exist, existReply, existRequest } = require_decorate();
    var { FST_ERR_PLUGIN_VERSION_MISMATCH } = require_errors();
    function getMeta(fn2) {
      return fn2[Symbol.for("plugin-meta")];
    }
    function getPluginName(func) {
      const display = getDisplayName(func);
      if (display) {
        return display;
      }
      const cache = __require.cache;
      const keys = Object.keys(cache);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (cache[key].exports === func) {
          return key;
        }
      }
      if (func.name) {
        return func.name;
      }
      return null;
    }
    function getFuncPreview(func) {
      return func.toString().split("\n").slice(0, 2).map((s2) => s2.trim()).join(" -- ");
    }
    function getDisplayName(fn2) {
      return fn2[Symbol.for("fastify.display-name")];
    }
    function shouldSkipOverride(fn2) {
      return !!fn2[Symbol.for("skip-override")];
    }
    function checkDependencies(fn2) {
      const meta = getMeta(fn2);
      if (!meta)
        return;
      const dependencies = meta.dependencies;
      if (!dependencies)
        return;
      assert(Array.isArray(dependencies), "The dependencies should be an array of strings");
      dependencies.forEach((dependency) => {
        assert(this[registeredPlugins].indexOf(dependency) > -1, `The dependency '${dependency}' of plugin '${meta.name}' is not registered`);
      });
    }
    function checkDecorators(fn2) {
      const meta = getMeta(fn2);
      if (!meta)
        return;
      const { decorators, name } = meta;
      if (!decorators)
        return;
      if (decorators.fastify)
        _checkDecorators(this, "Fastify", decorators.fastify, name);
      if (decorators.reply)
        _checkDecorators(this, "Reply", decorators.reply, name);
      if (decorators.request)
        _checkDecorators(this, "Request", decorators.request, name);
    }
    var checks = {
      Fastify: exist,
      Request: existRequest,
      Reply: existReply
    };
    function _checkDecorators(that, instance, decorators, name) {
      assert(Array.isArray(decorators), "The decorators should be an array of strings");
      decorators.forEach((decorator) => {
        const withPluginName = typeof name === "string" ? ` required by '${name}'` : "";
        if (!checks[instance].call(that, decorator)) {
          throw new Error(`The decorator '${decorator}'${withPluginName} is not present in ${instance}`);
        }
      });
    }
    function checkVersion(fn2) {
      const meta = getMeta(fn2);
      if (!meta)
        return;
      const requiredVersion = meta.fastify;
      if (!requiredVersion)
        return;
      if (!semver.satisfies(this.version, requiredVersion))
        throw new FST_ERR_PLUGIN_VERSION_MISMATCH(meta.name, requiredVersion, this.version);
    }
    function registerPluginName(fn2) {
      const meta = getMeta(fn2);
      if (!meta)
        return;
      const name = meta.name;
      if (!name)
        return;
      this[registeredPlugins].push(name);
    }
    function registerPlugin(fn2) {
      registerPluginName.call(this, fn2);
      checkVersion.call(this, fn2);
      checkDecorators.call(this, fn2);
      checkDependencies.call(this, fn2);
      return shouldSkipOverride(fn2);
    }
    module2.exports = {
      getPluginName,
      getFuncPreview,
      registeredPlugins,
      getDisplayName,
      registerPlugin
    };
    module2.exports[kTestInternals] = {
      shouldSkipOverride,
      getMeta,
      checkDecorators,
      checkDependencies
    };
  }
});

// packages/platform-fastify/node_modules/fastify/lib/reqIdGenFactory.js
var require_reqIdGenFactory = __commonJS({
  "packages/platform-fastify/node_modules/fastify/lib/reqIdGenFactory.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function() {
      const maxInt = 2147483647;
      let nextReqId = 0;
      return function genReqId(req) {
        nextReqId = nextReqId + 1 & maxInt;
        return `req-${nextReqId.toString(36)}`;
      };
    };
  }
});

// packages/platform-fastify/node_modules/fast-decode-uri-component/index.js
var require_fast_decode_uri_component = __commonJS({
  "packages/platform-fastify/node_modules/fast-decode-uri-component/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var UTF8_ACCEPT = 12;
    var UTF8_REJECT = 0;
    var UTF8_DATA = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      4,
      4,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      6,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      8,
      7,
      7,
      10,
      9,
      9,
      9,
      11,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      12,
      0,
      0,
      0,
      0,
      24,
      36,
      48,
      60,
      72,
      84,
      96,
      0,
      12,
      12,
      12,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      127,
      63,
      63,
      63,
      0,
      31,
      15,
      15,
      15,
      7,
      7,
      7
    ];
    function decodeURIComponent2(uri) {
      var percentPosition = uri.indexOf("%");
      if (percentPosition === -1)
        return uri;
      var length = uri.length;
      var decoded = "";
      var last = 0;
      var codepoint = 0;
      var startOfOctets = percentPosition;
      var state = UTF8_ACCEPT;
      while (percentPosition > -1 && percentPosition < length) {
        var high = hexCodeToInt(uri[percentPosition + 1], 4);
        var low = hexCodeToInt(uri[percentPosition + 2], 0);
        var byte = high | low;
        var type = UTF8_DATA[byte];
        state = UTF8_DATA[256 + state + type];
        codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type];
        if (state === UTF8_ACCEPT) {
          decoded += uri.slice(last, startOfOctets);
          decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
          codepoint = 0;
          last = percentPosition + 3;
          percentPosition = startOfOctets = uri.indexOf("%", last);
        } else if (state === UTF8_REJECT) {
          return null;
        } else {
          percentPosition += 3;
          if (percentPosition < length && uri.charCodeAt(percentPosition) === 37)
            continue;
          return null;
        }
      }
      return decoded + uri.slice(last);
    }
    var HEX = {
      "0": 0,
      "1": 1,
      "2": 2,
      "3": 3,
      "4": 4,
      "5": 5,
      "6": 6,
      "7": 7,
      "8": 8,
      "9": 9,
      "a": 10,
      "A": 10,
      "b": 11,
      "B": 11,
      "c": 12,
      "C": 12,
      "d": 13,
      "D": 13,
      "e": 14,
      "E": 14,
      "f": 15,
      "F": 15
    };
    function hexCodeToInt(c, shift) {
      var i = HEX[c];
      return i === void 0 ? 255 : i << shift;
    }
    module2.exports = decodeURIComponent2;
  }
});

// packages/platform-fastify/node_modules/ret/lib/types.js
var require_types = __commonJS({
  "packages/platform-fastify/node_modules/ret/lib/types.js"(exports2, module2) {
    init_esm_shims();
    module2.exports = {
      ROOT: 0,
      GROUP: 1,
      POSITION: 2,
      SET: 3,
      RANGE: 4,
      REPETITION: 5,
      REFERENCE: 6,
      CHAR: 7
    };
  }
});

// packages/platform-fastify/node_modules/ret/lib/sets.js
var require_sets = __commonJS({
  "packages/platform-fastify/node_modules/ret/lib/sets.js"(exports2) {
    init_esm_shims();
    var types2 = require_types();
    var INTS = () => [{ type: types2.RANGE, from: 48, to: 57 }];
    var WORDS = () => {
      return [
        { type: types2.CHAR, value: 95 },
        { type: types2.RANGE, from: 97, to: 122 },
        { type: types2.RANGE, from: 65, to: 90 }
      ].concat(INTS());
    };
    var WHITESPACE = () => {
      return [
        { type: types2.CHAR, value: 9 },
        { type: types2.CHAR, value: 10 },
        { type: types2.CHAR, value: 11 },
        { type: types2.CHAR, value: 12 },
        { type: types2.CHAR, value: 13 },
        { type: types2.CHAR, value: 32 },
        { type: types2.CHAR, value: 160 },
        { type: types2.CHAR, value: 5760 },
        { type: types2.RANGE, from: 8192, to: 8202 },
        { type: types2.CHAR, value: 8232 },
        { type: types2.CHAR, value: 8233 },
        { type: types2.CHAR, value: 8239 },
        { type: types2.CHAR, value: 8287 },
        { type: types2.CHAR, value: 12288 },
        { type: types2.CHAR, value: 65279 }
      ];
    };
    var NOTANYCHAR = () => {
      return [
        { type: types2.CHAR, value: 10 },
        { type: types2.CHAR, value: 13 },
        { type: types2.CHAR, value: 8232 },
        { type: types2.CHAR, value: 8233 }
      ];
    };
    exports2.words = () => ({ type: types2.SET, set: WORDS(), not: false });
    exports2.notWords = () => ({ type: types2.SET, set: WORDS(), not: true });
    exports2.ints = () => ({ type: types2.SET, set: INTS(), not: false });
    exports2.notInts = () => ({ type: types2.SET, set: INTS(), not: true });
    exports2.whitespace = () => ({ type: types2.SET, set: WHITESPACE(), not: false });
    exports2.notWhitespace = () => ({ type: types2.SET, set: WHITESPACE(), not: true });
    exports2.anyChar = () => ({ type: types2.SET, set: NOTANYCHAR(), not: true });
  }
});

// packages/platform-fastify/node_modules/ret/lib/util.js
var require_util2 = __commonJS({
  "packages/platform-fastify/node_modules/ret/lib/util.js"(exports2) {
    init_esm_shims();
    var types2 = require_types();
    var sets = require_sets();
    var CTRL = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?";
    var SLSH = { "0": 0, "t": 9, "n": 10, "v": 11, "f": 12, "r": 13 };
    exports2.strToChars = function(str) {
      var chars_regex = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g;
      str = str.replace(chars_regex, function(s2, b, lbs, a16, b16, c8, dctrl, eslsh) {
        if (lbs) {
          return s2;
        }
        var code = b ? 8 : a16 ? parseInt(a16, 16) : b16 ? parseInt(b16, 16) : c8 ? parseInt(c8, 8) : dctrl ? CTRL.indexOf(dctrl) : SLSH[eslsh];
        var c = String.fromCharCode(code);
        if (/[[\]{}^$.|?*+()]/.test(c)) {
          c = "\\" + c;
        }
        return c;
      });
      return str;
    };
    exports2.tokenizeClass = (str, regexpStr) => {
      var tokens = [];
      var regexp = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(?:\\)?([^\]]))|(\])|(?:\\)?([^])/g;
      var rs, c;
      while ((rs = regexp.exec(str)) != null) {
        if (rs[1]) {
          tokens.push(sets.words());
        } else if (rs[2]) {
          tokens.push(sets.ints());
        } else if (rs[3]) {
          tokens.push(sets.whitespace());
        } else if (rs[4]) {
          tokens.push(sets.notWords());
        } else if (rs[5]) {
          tokens.push(sets.notInts());
        } else if (rs[6]) {
          tokens.push(sets.notWhitespace());
        } else if (rs[7]) {
          tokens.push({
            type: types2.RANGE,
            from: (rs[8] || rs[9]).charCodeAt(0),
            to: rs[10].charCodeAt(0)
          });
        } else if (c = rs[12]) {
          tokens.push({
            type: types2.CHAR,
            value: c.charCodeAt(0)
          });
        } else {
          return [tokens, regexp.lastIndex];
        }
      }
      exports2.error(regexpStr, "Unterminated character class");
    };
    exports2.error = (regexp, msg) => {
      throw new SyntaxError("Invalid regular expression: /" + regexp + "/: " + msg);
    };
  }
});

// packages/platform-fastify/node_modules/ret/lib/positions.js
var require_positions = __commonJS({
  "packages/platform-fastify/node_modules/ret/lib/positions.js"(exports2) {
    init_esm_shims();
    var types2 = require_types();
    exports2.wordBoundary = () => ({ type: types2.POSITION, value: "b" });
    exports2.nonWordBoundary = () => ({ type: types2.POSITION, value: "B" });
    exports2.begin = () => ({ type: types2.POSITION, value: "^" });
    exports2.end = () => ({ type: types2.POSITION, value: "$" });
  }
});

// packages/platform-fastify/node_modules/ret/lib/index.js
var require_lib2 = __commonJS({
  "packages/platform-fastify/node_modules/ret/lib/index.js"(exports2, module2) {
    init_esm_shims();
    var util = require_util2();
    var types2 = require_types();
    var sets = require_sets();
    var positions = require_positions();
    module2.exports = (regexpStr) => {
      var i = 0, l, c, start = { type: types2.ROOT, stack: [] }, lastGroup = start, last = start.stack, groupStack = [];
      var repeatErr = (i2) => {
        util.error(regexpStr, `Nothing to repeat at column ${i2 - 1}`);
      };
      var str = util.strToChars(regexpStr);
      l = str.length;
      while (i < l) {
        c = str[i++];
        switch (c) {
          case "\\":
            c = str[i++];
            switch (c) {
              case "b":
                last.push(positions.wordBoundary());
                break;
              case "B":
                last.push(positions.nonWordBoundary());
                break;
              case "w":
                last.push(sets.words());
                break;
              case "W":
                last.push(sets.notWords());
                break;
              case "d":
                last.push(sets.ints());
                break;
              case "D":
                last.push(sets.notInts());
                break;
              case "s":
                last.push(sets.whitespace());
                break;
              case "S":
                last.push(sets.notWhitespace());
                break;
              default:
                if (/\d/.test(c)) {
                  last.push({ type: types2.REFERENCE, value: parseInt(c, 10) });
                } else {
                  last.push({ type: types2.CHAR, value: c.charCodeAt(0) });
                }
            }
            break;
          case "^":
            last.push(positions.begin());
            break;
          case "$":
            last.push(positions.end());
            break;
          case "[":
            var not;
            if (str[i] === "^") {
              not = true;
              i++;
            } else {
              not = false;
            }
            var classTokens = util.tokenizeClass(str.slice(i), regexpStr);
            i += classTokens[1];
            last.push({
              type: types2.SET,
              set: classTokens[0],
              not
            });
            break;
          case ".":
            last.push(sets.anyChar());
            break;
          case "(":
            var group = {
              type: types2.GROUP,
              stack: [],
              remember: true
            };
            c = str[i];
            if (c === "?") {
              c = str[i + 1];
              i += 2;
              if (c === "=") {
                group.followedBy = true;
              } else if (c === "!") {
                group.notFollowedBy = true;
              } else if (c !== ":") {
                util.error(regexpStr, `Invalid group, character '${c}' after '?' at column ${i - 1}`);
              }
              group.remember = false;
            }
            last.push(group);
            groupStack.push(lastGroup);
            lastGroup = group;
            last = group.stack;
            break;
          case ")":
            if (groupStack.length === 0) {
              util.error(regexpStr, `Unmatched ) at column ${i - 1}`);
            }
            lastGroup = groupStack.pop();
            last = lastGroup.options ? lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;
            break;
          case "|":
            if (!lastGroup.options) {
              lastGroup.options = [lastGroup.stack];
              delete lastGroup.stack;
            }
            var stack2 = [];
            lastGroup.options.push(stack2);
            last = stack2;
            break;
          case "{":
            var rs = /^(\d+)(,(\d+)?)?\}/.exec(str.slice(i)), min, max;
            if (rs !== null) {
              if (last.length === 0) {
                repeatErr(i);
              }
              min = parseInt(rs[1], 10);
              max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;
              i += rs[0].length;
              last.push({
                type: types2.REPETITION,
                min,
                max,
                value: last.pop()
              });
            } else {
              last.push({
                type: types2.CHAR,
                value: 123
              });
            }
            break;
          case "?":
            if (last.length === 0) {
              repeatErr(i);
            }
            last.push({
              type: types2.REPETITION,
              min: 0,
              max: 1,
              value: last.pop()
            });
            break;
          case "+":
            if (last.length === 0) {
              repeatErr(i);
            }
            last.push({
              type: types2.REPETITION,
              min: 1,
              max: Infinity,
              value: last.pop()
            });
            break;
          case "*":
            if (last.length === 0) {
              repeatErr(i);
            }
            last.push({
              type: types2.REPETITION,
              min: 0,
              max: Infinity,
              value: last.pop()
            });
            break;
          default:
            last.push({
              type: types2.CHAR,
              value: c.charCodeAt(0)
            });
        }
      }
      if (groupStack.length !== 0) {
        util.error(regexpStr, "Unterminated group");
      }
      return start;
    };
    module2.exports.types = types2;
  }
});

// packages/platform-fastify/node_modules/safe-regex2/index.js
var require_safe_regex2 = __commonJS({
  "packages/platform-fastify/node_modules/safe-regex2/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var parse = require_lib2();
    var types2 = parse.types;
    module2.exports = function(re, opts) {
      if (!opts)
        opts = {};
      var replimit = opts.limit === void 0 ? 25 : opts.limit;
      if (isRegExp(re))
        re = re.source;
      else if (typeof re !== "string")
        re = String(re);
      try {
        re = parse(re);
      } catch (err) {
        return false;
      }
      var reps = 0;
      return function walk(node, starHeight) {
        var i;
        var ok;
        var len;
        if (node.type === types2.REPETITION) {
          starHeight++;
          reps++;
          if (starHeight > 1)
            return false;
          if (reps > replimit)
            return false;
        }
        if (node.options) {
          for (i = 0, len = node.options.length; i < len; i++) {
            ok = walk({ stack: node.options[i] }, starHeight);
            if (!ok)
              return false;
          }
        }
        var stack2 = node.stack || node.value && node.value.stack;
        if (!stack2)
          return true;
        for (i = 0; i < stack2.length; i++) {
          ok = walk(stack2[i], starHeight);
          if (!ok)
            return false;
        }
        return true;
      }(re, 0);
    };
    function isRegExp(x) {
      return {}.toString.call(x) === "[object RegExp]";
    }
  }
});

// packages/platform-fastify/node_modules/find-my-way/lib/pretty-print.js
var require_pretty_print = __commonJS({
  "packages/platform-fastify/node_modules/find-my-way/lib/pretty-print.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var indent = "    ";
    var branchIndent = "\u2502   ";
    var midBranchIndent = "\u251C\u2500\u2500 ";
    var endBranchIndent = "\u2514\u2500\u2500 ";
    var wildcardDelimiter = "*";
    var pathDelimiter = "/";
    var pathRegExp = /(?=\/)/;
    function parseFunctionName(fn2) {
      let fName = fn2.name || "";
      fName = fName.replace("bound", "").trim();
      fName = (fName || "anonymous") + "()";
      return fName;
    }
    function parseMeta(meta) {
      if (Array.isArray(meta))
        return meta.map((m) => parseMeta(m));
      if (typeof meta === "symbol")
        return meta.toString();
      if (typeof meta === "function")
        return parseFunctionName(meta);
      return meta;
    }
    function buildMetaObject(route, metaArray) {
      const out = {};
      const cleanMeta = this.buildPrettyMeta(route);
      if (!Array.isArray(metaArray))
        metaArray = cleanMeta ? Reflect.ownKeys(cleanMeta) : [];
      metaArray.forEach((m) => {
        const metaKey = typeof m === "symbol" ? m.toString() : m;
        if (cleanMeta && cleanMeta[m]) {
          out[metaKey] = parseMeta(cleanMeta[m]);
        }
      });
      return out;
    }
    function prettyPrintRoutesArray(routeArray, opts = {}) {
      if (!this.buildPrettyMeta)
        throw new Error("buildPrettyMeta not defined");
      opts.includeMeta = opts.includeMeta || null;
      const mergedRouteArray = [];
      let tree = "";
      routeArray.sort((a, b) => {
        if (!a.path || !b.path)
          return 0;
        return a.path.localeCompare(b.path);
      });
      for (let i = 0; i < routeArray.length; i++) {
        const route = routeArray[i];
        const pathExists = mergedRouteArray.find((r) => route.path === r.path);
        if (pathExists) {
          pathExists.handlers.push({
            method: route.method,
            opts: route.opts.constraints || void 0,
            meta: opts.includeMeta ? buildMetaObject.call(this, route, opts.includeMeta) : null
          });
          continue;
        }
        const routeHandler = {
          method: route.method,
          opts: route.opts.constraints || void 0,
          meta: opts.includeMeta ? buildMetaObject.call(this, route, opts.includeMeta) : null
        };
        mergedRouteArray.push({
          path: route.path,
          methods: [route.method],
          opts: [route.opts],
          handlers: [routeHandler]
        });
      }
      if (!mergedRouteArray.filter((r) => r.path === pathDelimiter).length) {
        const rootPath = {
          path: pathDelimiter,
          truncatedPath: "",
          methods: [],
          opts: [],
          handlers: [{}]
        };
        if (mergedRouteArray.filter((r) => r.path === wildcardDelimiter).length) {
          mergedRouteArray.splice(1, 0, rootPath);
        } else {
          mergedRouteArray.unshift(rootPath);
        }
      }
      const routeTree = buildRouteTree(mergedRouteArray);
      routeTree.forEach((rootBranch, idx) => {
        tree += drawBranch(rootBranch, null, idx === routeTree.length - 1, false, true);
        tree += "\n";
      });
      return tree;
    }
    function buildRouteTree(mergedRouteArray, rootPath) {
      rootPath = rootPath || pathDelimiter;
      const result = [];
      const temp = { result };
      mergedRouteArray.forEach((route, idx) => {
        let splitPath = route.path.split(pathRegExp);
        if (splitPath[0] !== pathDelimiter) {
          if (splitPath[0] !== wildcardDelimiter)
            splitPath = [pathDelimiter, splitPath[0].slice(1), ...splitPath.slice(1)];
        }
        splitPath.reduce((acc, path2, pidx) => {
          if (!acc[path2]) {
            acc[path2] = { result: [] };
            const pathSeg = { path: path2, children: acc[path2].result };
            if (pidx === splitPath.length - 1)
              pathSeg.handlers = route.handlers;
            acc.result.push(pathSeg);
          }
          return acc[path2];
        }, temp);
      });
      return result;
    }
    function drawBranch(pathSeg, prefix, endBranch, noPrefix, rootBranch) {
      let branch = "";
      if (!noPrefix && !rootBranch)
        branch += "\n";
      if (!noPrefix)
        branch += `${prefix || ""}${endBranch ? endBranchIndent : midBranchIndent}`;
      branch += `${pathSeg.path}`;
      if (pathSeg.handlers) {
        const flatHandlers = pathSeg.handlers.reduce((acc, curr) => {
          const match = acc.findIndex((h) => JSON.stringify(h.opts) === JSON.stringify(curr.opts));
          if (match !== -1) {
            acc[match].method = [acc[match].method, curr.method].join(", ");
          } else {
            acc.push(curr);
          }
          return acc;
        }, []);
        flatHandlers.forEach((handler, idx) => {
          if (idx > 0)
            branch += `${noPrefix ? "" : prefix || ""}${endBranch ? indent : branchIndent}${pathSeg.path}`;
          branch += ` (${handler.method || "-"})`;
          if (handler.opts && JSON.stringify(handler.opts) !== "{}")
            branch += ` ${JSON.stringify(handler.opts)}`;
          if (handler.meta) {
            Reflect.ownKeys(handler.meta).forEach((m, hidx) => {
              branch += `
${noPrefix ? "" : prefix || ""}${endBranch ? indent : branchIndent}`;
              branch += `\u2022 (${m}) ${JSON.stringify(handler.meta[m])}`;
            });
          }
          if (flatHandlers.length > 1 && idx !== flatHandlers.length - 1)
            branch += "\n";
        });
      } else {
        if (pathSeg.children.length > 1)
          branch += " (-)";
      }
      if (!noPrefix)
        prefix = `${prefix || ""}${endBranch ? indent : branchIndent}`;
      pathSeg.children.forEach((child, idx) => {
        const endBranch2 = idx === pathSeg.children.length - 1;
        const skipPrefix = !pathSeg.handlers && pathSeg.children.length === 1;
        branch += drawBranch(child, prefix, endBranch2, skipPrefix);
      });
      return branch;
    }
    function prettyPrintFlattenedNode(flattenedNode, prefix, tail, opts) {
      if (!this.buildPrettyMeta)
        throw new Error("buildPrettyMeta not defined");
      opts.includeMeta = opts.includeMeta || null;
      let paramName = "";
      const printHandlers = [];
      for (const node of flattenedNode.nodes) {
        for (const handler of node.handlers) {
          printHandlers.push(__spreadValues({ method: node.method }, handler));
        }
      }
      if (printHandlers.length) {
        printHandlers.forEach((handler, index2) => {
          let suffix = `(${handler.method || "-"})`;
          if (Object.keys(handler.constraints).length > 0) {
            suffix += " " + JSON.stringify(handler.constraints);
          }
          let name = "";
          const paramIndices = flattenedNode.prefix.split("").map((ch, idx) => ch === ":" ? idx : null).filter((idx) => idx !== null);
          if (paramIndices.length) {
            let prevLoc = 0;
            paramIndices.forEach((loc, idx) => {
              name += flattenedNode.prefix.slice(prevLoc, loc + 1);
              name += handler.params[handler.params.length - paramIndices.length + idx];
              if (idx === paramIndices.length - 1)
                name += flattenedNode.prefix.slice(loc + 1);
              prevLoc = loc + 1;
            });
          } else {
            name = flattenedNode.prefix;
          }
          if (index2 === 0) {
            paramName += `${name} ${suffix}`;
          } else {
            paramName += `
${prefix}${tail ? indent : branchIndent}${name} ${suffix}`;
          }
          if (opts.includeMeta) {
            const meta = buildMetaObject.call(this, handler, opts.includeMeta);
            Object.keys(meta).forEach((m, hidx) => {
              paramName += `
${prefix || ""}${tail ? indent : branchIndent}`;
              paramName += `\u2022 (${m}) ${JSON.stringify(meta[m])}`;
            });
          }
        });
      } else {
        paramName = flattenedNode.prefix;
      }
      let tree = `${prefix}${tail ? endBranchIndent : midBranchIndent}${paramName}
`;
      prefix = `${prefix}${tail ? indent : branchIndent}`;
      const labels = Object.keys(flattenedNode.children);
      for (let i = 0; i < labels.length; i++) {
        const child = flattenedNode.children[labels[i]];
        tree += prettyPrintFlattenedNode.call(this, child, prefix, i === labels.length - 1, opts);
      }
      return tree;
    }
    function flattenNode(flattened, node) {
      if (node.handlers.length > 0) {
        flattened.nodes.push(node);
      }
      if (node.children) {
        for (const child of Object.values(node.children)) {
          const childPrefixSegments = child.prefix.split(pathRegExp);
          let cursor = flattened;
          let parent2;
          for (const segment of childPrefixSegments) {
            parent2 = cursor;
            cursor = cursor.children[segment];
            if (!cursor) {
              cursor = {
                prefix: segment,
                nodes: [],
                children: {}
              };
              parent2.children[segment] = cursor;
            }
          }
          flattenNode(cursor, child);
        }
      }
    }
    function compressFlattenedNode(flattenedNode) {
      const childKeys = Object.keys(flattenedNode.children);
      if (flattenedNode.nodes.length === 0 && childKeys.length === 1) {
        const child = flattenedNode.children[childKeys[0]];
        if (child.nodes.length <= 1) {
          compressFlattenedNode(child);
          flattenedNode.nodes = child.nodes;
          flattenedNode.prefix += child.prefix;
          flattenedNode.children = child.children;
          return flattenedNode;
        }
      }
      for (const key of Object.keys(flattenedNode.children)) {
        compressFlattenedNode(flattenedNode.children[key]);
      }
      return flattenedNode;
    }
    module2.exports = { flattenNode, compressFlattenedNode, prettyPrintFlattenedNode, prettyPrintRoutesArray };
  }
});

// packages/platform-fastify/node_modules/find-my-way/node.js
var require_node2 = __commonJS({
  "packages/platform-fastify/node_modules/find-my-way/node.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var assert = __require("assert");
    var deepEqual = require_fast_deep_equal();
    var types2 = {
      STATIC: 0,
      PARAM: 1,
      MATCH_ALL: 2,
      REGEX: 3,
      MULTI_PARAM: 4
    };
    function Node(options) {
      options = options || {};
      this.prefix = options.prefix || "/";
      this.label = this.prefix[0];
      this.method = options.method;
      this.handlers = options.handlers || [];
      this.unconstrainedHandler = options.unconstrainedHandler || null;
      this.children = options.children || {};
      this.numberOfChildren = Object.keys(this.children).length;
      this.kind = options.kind || this.types.STATIC;
      this.regex = options.regex || null;
      this.wildcardChild = null;
      this.parametricBrother = null;
      this.constrainer = options.constrainer;
      this.hasConstraints = options.hasConstraints || false;
      this.constrainedHandlerStores = null;
    }
    Object.defineProperty(Node.prototype, "types", {
      value: types2
    });
    Node.prototype.getLabel = function() {
      return this.prefix[0];
    };
    Node.prototype.addChild = function(node) {
      var label = "";
      switch (node.kind) {
        case this.types.STATIC:
          label = node.getLabel();
          break;
        case this.types.PARAM:
        case this.types.REGEX:
        case this.types.MULTI_PARAM:
          label = ":";
          break;
        case this.types.MATCH_ALL:
          this.wildcardChild = node;
          label = "*";
          break;
        default:
          throw new Error(`Unknown node kind: ${node.kind}`);
      }
      assert(this.children[label] === void 0, `There is already a child with label '${label}'`);
      this.children[label] = node;
      const nodeChildren = Object.values(this.children);
      this.numberOfChildren = nodeChildren.length;
      this._saveParametricBrother();
      return this;
    };
    Node.prototype._saveParametricBrother = function() {
      let parametricBrother = this.parametricBrother;
      for (const child of Object.values(this.children)) {
        if (child.prefix === ":") {
          parametricBrother = child;
          break;
        }
      }
      if (parametricBrother) {
        for (const child of Object.values(this.children)) {
          if (child && child.kind === this.types.STATIC) {
            child.parametricBrother = parametricBrother;
            child._saveParametricBrother(parametricBrother);
          }
        }
      }
    };
    Node.prototype.reset = function(prefix) {
      this.prefix = prefix;
      this.children = {};
      this.handlers = [];
      this.unconstrainedHandler = null;
      this.kind = this.types.STATIC;
      this.numberOfChildren = 0;
      this.regex = null;
      this.wildcardChild = null;
      this.hasConstraints = false;
      this._decompileGetHandlerMatchingConstraints();
      return this;
    };
    Node.prototype.split = function(length) {
      const newChild = new Node({
        prefix: this.prefix.slice(length),
        children: this.children,
        kind: this.kind,
        method: this.method,
        handlers: this.handlers.slice(0),
        regex: this.regex,
        constrainer: this.constrainer,
        hasConstraints: this.hasConstraints,
        unconstrainedHandler: this.unconstrainedHandler
      });
      if (this.wildcardChild !== null) {
        newChild.wildcardChild = this.wildcardChild;
      }
      this.reset(this.prefix.slice(0, length));
      this.addChild(newChild);
      return newChild;
    };
    Node.prototype.findByLabel = function(path2) {
      return this.children[path2[0]];
    };
    Node.prototype.findMatchingChild = function(derivedConstraints, path2) {
      var child = this.children[path2[0]];
      if (child !== void 0 && (child.numberOfChildren > 0 || child.getMatchingHandler(derivedConstraints) !== null)) {
        if (path2.slice(0, child.prefix.length) === child.prefix) {
          return child;
        }
      }
      child = this.children[":"];
      if (child !== void 0 && (child.numberOfChildren > 0 || child.getMatchingHandler(derivedConstraints) !== null)) {
        return child;
      }
      child = this.children["*"];
      if (child !== void 0 && (child.numberOfChildren > 0 || child.getMatchingHandler(derivedConstraints) !== null)) {
        return child;
      }
      return null;
    };
    Node.prototype.addHandler = function(handler, params, store, constraints) {
      if (!handler)
        return;
      assert(!this.getHandler(constraints), `There is already a handler with constraints '${JSON.stringify(constraints)}' and method '${this.method}'`);
      const handlerObject = {
        handler,
        params,
        constraints,
        store: store || null,
        paramsLength: params.length
      };
      this.handlers.push(handlerObject);
      this.handlers.sort((a, b) => Object.keys(a.constraints).length - Object.keys(b.constraints).length);
      if (Object.keys(constraints).length > 0) {
        this.hasConstraints = true;
      } else {
        this.unconstrainedHandler = handlerObject;
      }
      if (this.hasConstraints && this.handlers.length > 32) {
        throw new Error("find-my-way supports a maximum of 32 route handlers per node when there are constraints, limit reached");
      }
      this._decompileGetHandlerMatchingConstraints();
    };
    Node.prototype.getHandler = function(constraints) {
      return this.handlers.filter((handler) => deepEqual(constraints, handler.constraints))[0];
    };
    function compileThenGetHandlerMatchingConstraints(derivedConstraints) {
      this._compileGetHandlerMatchingConstraints();
      return this._getHandlerMatchingConstraints(derivedConstraints);
    }
    Node.prototype.getMatchingHandler = function(derivedConstraints) {
      if (this.hasConstraints) {
        return this._getHandlerMatchingConstraints(derivedConstraints);
      } else {
        if (derivedConstraints && derivedConstraints.__hasMustMatchValues) {
          return null;
        } else {
          return this.unconstrainedHandler;
        }
      }
    };
    Node.prototype._getHandlerMatchingConstraints = compileThenGetHandlerMatchingConstraints;
    Node.prototype._decompileGetHandlerMatchingConstraints = function() {
      this._getHandlerMatchingConstraints = compileThenGetHandlerMatchingConstraints;
      return null;
    };
    Node.prototype._buildConstraintStore = function(constraint) {
      const store = this.constrainer.newStoreForConstraint(constraint);
      for (let i = 0; i < this.handlers.length; i++) {
        const handler = this.handlers[i];
        const mustMatchValue = handler.constraints[constraint];
        if (typeof mustMatchValue !== "undefined") {
          let indexes = store.get(mustMatchValue);
          if (!indexes) {
            indexes = 0;
          }
          indexes |= 1 << i;
          store.set(mustMatchValue, indexes);
        }
      }
      return store;
    };
    Node.prototype._constrainedIndexBitmask = function(constraint) {
      let mask = 0;
      for (let i = 0; i < this.handlers.length; i++) {
        const handler = this.handlers[i];
        if (handler.constraints && constraint in handler.constraints) {
          mask |= 1 << i;
        }
      }
      return ~mask;
    };
    Node.prototype._compileGetHandlerMatchingConstraints = function() {
      this.constrainedHandlerStores = {};
      let constraints = /* @__PURE__ */ new Set();
      for (const handler of this.handlers) {
        for (const key of Object.keys(handler.constraints)) {
          constraints.add(key);
        }
      }
      constraints = Array.from(constraints);
      const lines = [];
      constraints.sort((a, b) => a === "version" ? 1 : 0);
      for (const constraint of constraints) {
        this.constrainedHandlerStores[constraint] = this._buildConstraintStore(constraint);
      }
      lines.push(`
  let candidates = 0b${"1".repeat(this.handlers.length)}
  let mask, matches
  `);
      for (const constraint of constraints) {
        lines.push(`
    mask = ${this._constrainedIndexBitmask(constraint)}
    value = derivedConstraints.${constraint}
    `);
        lines.push(`
    if (typeof value === "undefined") {
      candidates &= mask
    } else {
      matches = this.constrainedHandlerStores.${constraint}.get(value) || 0
      candidates &= (matches | mask)
    }
    if (candidates === 0) return null;
    `);
      }
      lines.push(`
  const handler = this.handlers[Math.floor(Math.log2(candidates))]
  if (handler && derivedConstraints.__hasMustMatchValues && handler === this.unconstrainedHandler) {
    return null;
  }
  return handler;
  `);
      this._getHandlerMatchingConstraints = new Function("derivedConstraints", lines.join("\n"));
    };
    module2.exports = Node;
  }
});

// packages/platform-fastify/node_modules/semver-store/index.js
var require_semver_store = __commonJS({
  "packages/platform-fastify/node_modules/semver-store/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    function SemVerStore() {
      if (!(this instanceof SemVerStore)) {
        return new SemVerStore();
      }
      this.tree = new Node();
    }
    SemVerStore.prototype.set = function(version, store) {
      if (typeof version !== "string") {
        throw new TypeError("Version should be a string");
      }
      var currentNode = this.tree;
      version = version.split(".");
      while (version.length) {
        currentNode = currentNode.addChild(new Node(version.shift()));
      }
      currentNode.setStore(store);
      return this;
    };
    SemVerStore.prototype.get = function(version) {
      if (typeof version !== "string")
        return null;
      if (version === "*")
        version = "x.x.x";
      var node = this.tree;
      var firstDot = version.indexOf(".");
      var secondDot = version.indexOf(".", firstDot + 1);
      var major = version.slice(0, firstDot);
      var minor = secondDot === -1 ? version.slice(firstDot + 1) : version.slice(firstDot + 1, secondDot);
      var patch = secondDot === -1 ? "x" : version.slice(secondDot + 1);
      node = node.getChild(major);
      if (node === null)
        return null;
      node = node.getChild(minor);
      if (node === null)
        return null;
      node = node.getChild(patch);
      if (node === null)
        return null;
      return node.store;
    };
    SemVerStore.prototype.del = function(version) {
      if (typeof version !== "string") {
        throw new TypeError("Version should be a string");
      }
      var firstDot = version.indexOf(".");
      var secondDot = version.indexOf(".", firstDot + 1);
      var major = version.slice(0, firstDot);
      var minor = secondDot === -1 ? version.slice(firstDot + 1) : version.slice(firstDot + 1, secondDot);
      var patch = secondDot === -1 ? "x" : version.slice(secondDot + 1);
      var majorNode = this.tree.children[major];
      if (majorNode == null)
        return this;
      if (minor === "x") {
        this.tree.removeChild(major);
        return this;
      }
      var minorNode = majorNode.children[minor];
      if (minorNode == null)
        return this;
      if (patch === "x") {
        this.tree.children[major].removeChild(minor);
        if (this.tree.children[major].length === 0) {
          this.tree.removeChild(major);
        }
        return this;
      }
      var patchNode = minorNode.children[patch];
      if (patchNode == null)
        return this;
      this.tree.children[major].children[minor].removeChild(patch);
      if (this.tree.children[major].children[minor].length === 0) {
        this.tree.children[major].removeChild(minor);
        if (this.tree.children[major].length === 0) {
          this.tree.removeChild(major);
        }
      }
      return this;
    };
    SemVerStore.prototype.empty = function() {
      this.tree = new Node();
      return this;
    };
    function getMax(arr) {
      var l = arr.length;
      var max = arr[0];
      for (var i = 1; i < l; i++) {
        if (arr[i] > max) {
          max = arr[i];
        }
      }
      return max;
    }
    function Node(prefix, children, store) {
      this.prefix = Number(prefix) || 0;
      this.children = children || null;
      this.childrenPrefixes = children ? Object.keys(children) : [];
      this.store = store || null;
    }
    Node.prototype.getChild = function(prefix) {
      if (this.children === null)
        return null;
      if (prefix === "x") {
        var max = getMax(this.childrenPrefixes);
        return this.children[max];
      }
      return this.children[prefix] || null;
    };
    Node.prototype.addChild = function(node) {
      this.children = this.children || {};
      var child = this.getChild(node.prefix);
      if (child === null) {
        this.children[node.prefix] = node;
        this.childrenPrefixes.push(node.prefix);
      }
      return child || node;
    };
    Node.prototype.removeChild = function(prefix) {
      if (prefix === "x") {
        this.children = null;
        this.childrenPrefixes = [];
        return this;
      }
      if (this.children[prefix] !== void 0) {
        prefix = Number(prefix);
        delete this.children[prefix];
        this.childrenPrefixes.splice(this.childrenPrefixes.indexOf(prefix), 1);
      }
      return this;
    };
    Node.prototype.setStore = function(store) {
      this.store = store;
      return this;
    };
    Object.defineProperty(Node.prototype, "length", {
      get: function() {
        return this.childrenPrefixes.length;
      }
    });
    module2.exports = SemVerStore;
  }
});

// packages/platform-fastify/node_modules/find-my-way/lib/strategies/accept-version.js
var require_accept_version = __commonJS({
  "packages/platform-fastify/node_modules/find-my-way/lib/strategies/accept-version.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var SemVerStore = require_semver_store();
    var assert = __require("assert");
    module2.exports = {
      name: "version",
      mustMatchWhenDerived: true,
      storage: SemVerStore,
      validate(value) {
        assert(typeof value === "string", "Version should be a string");
      }
    };
  }
});

// packages/platform-fastify/node_modules/find-my-way/lib/strategies/accept-host.js
var require_accept_host = __commonJS({
  "packages/platform-fastify/node_modules/find-my-way/lib/strategies/accept-host.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var assert = __require("assert");
    function HostStorage() {
      var hosts = {};
      var regexHosts = [];
      return {
        get: (host) => {
          var exact = hosts[host];
          if (exact) {
            return exact;
          }
          var item;
          for (var i = 0; i < regexHosts.length; i++) {
            item = regexHosts[i];
            if (item.host.test(host)) {
              return item.value;
            }
          }
        },
        set: (host, value) => {
          if (host instanceof RegExp) {
            regexHosts.push({ host, value });
          } else {
            hosts[host] = value;
          }
        },
        del: (host) => {
          delete hosts[host];
          regexHosts = regexHosts.filter((obj) => String(obj.host) !== String(host));
        },
        empty: () => {
          hosts = {};
          regexHosts = [];
        }
      };
    }
    module2.exports = {
      name: "host",
      mustMatchWhenDerived: false,
      storage: HostStorage,
      validate(value) {
        assert(typeof value === "string" || Object.prototype.toString.call(value) === "[object RegExp]", "Host should be a string or a RegExp");
      }
    };
  }
});

// packages/platform-fastify/node_modules/find-my-way/lib/constrainer.js
var require_constrainer = __commonJS({
  "packages/platform-fastify/node_modules/find-my-way/lib/constrainer.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var acceptVersionStrategy = require_accept_version();
    var acceptHostStrategy = require_accept_host();
    var assert = __require("assert");
    var Constrainer = class {
      constructor(customStrategies) {
        this.strategies = {
          version: acceptVersionStrategy,
          host: acceptHostStrategy
        };
        this.strategiesInUse = /* @__PURE__ */ new Set();
        if (customStrategies) {
          var kCustomStrategies = Object.keys(customStrategies);
          var strategy;
          for (var i = 0; i < kCustomStrategies.length; i++) {
            strategy = customStrategies[kCustomStrategies[i]];
            assert(typeof strategy.name === "string" && strategy.name !== "", "strategy.name is required.");
            assert(strategy.storage && typeof strategy.storage === "function", "strategy.storage function is required.");
            assert(strategy.deriveConstraint && typeof strategy.deriveConstraint === "function", "strategy.deriveConstraint function is required.");
            strategy.isCustom = true;
            this.strategies[strategy.name] = strategy;
            if (strategy.mustMatchWhenDerived) {
              this.noteUsage({ [kCustomStrategies[i]]: strategy });
            }
          }
        }
      }
      deriveConstraints(req, ctx) {
        return void 0;
      }
      noteUsage(constraints) {
        if (constraints) {
          const beforeSize = this.strategiesInUse.size;
          for (const key in constraints) {
            this.strategiesInUse.add(key);
          }
          if (beforeSize !== this.strategiesInUse.size) {
            this._buildDeriveConstraints();
          }
        }
      }
      newStoreForConstraint(constraint) {
        if (!this.strategies[constraint]) {
          throw new Error(`No strategy registered for constraint key ${constraint}`);
        }
        return this.strategies[constraint].storage();
      }
      validateConstraints(constraints) {
        for (const key in constraints) {
          const value = constraints[key];
          if (typeof value === "undefined") {
            throw new Error("Can't pass an undefined constraint value, must pass null or no key at all");
          }
          const strategy = this.strategies[key];
          if (!strategy) {
            throw new Error(`No strategy registered for constraint key ${key}`);
          }
          if (strategy.validate) {
            strategy.validate(value);
          }
        }
      }
      _buildDeriveConstraints() {
        if (this.strategiesInUse.size === 0)
          return;
        const lines = [`
      const derivedConstraints = {
        __hasMustMatchValues: false,
    `];
        const mustMatchKeys = [];
        for (const key of this.strategiesInUse) {
          const strategy = this.strategies[key];
          if (!strategy.isCustom) {
            if (key === "version") {
              lines.push("   version: req.headers['accept-version'],");
            } else if (key === "host") {
              lines.push("   host: req.headers.host || req.headers[':authority'],");
            } else {
              throw new Error("unknown non-custom strategy for compiling constraint derivation function");
            }
          } else {
            lines.push(`  ${strategy.name}: this.strategies.${key}.deriveConstraint(req, ctx),`);
          }
          if (strategy.mustMatchWhenDerived) {
            mustMatchKeys.push(key);
          }
        }
        lines.push("}");
        if (mustMatchKeys.length > 0) {
          lines.push(`derivedConstraints.__hasMustMatchValues = !!(${mustMatchKeys.map((key) => `derivedConstraints.${key}`).join(" || ")})`);
        }
        lines.push("return derivedConstraints");
        this.deriveConstraints = new Function("req", "ctx", lines.join("\n")).bind(this);
      }
    };
    module2.exports = Constrainer;
  }
});

// packages/platform-fastify/node_modules/find-my-way/index.js
var require_find_my_way = __commonJS({
  "packages/platform-fastify/node_modules/find-my-way/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var assert = __require("assert");
    var http = __require("http");
    var fastDecode = require_fast_decode_uri_component();
    var isRegexSafe = require_safe_regex2();
    var { flattenNode, compressFlattenedNode, prettyPrintFlattenedNode, prettyPrintRoutesArray } = require_pretty_print();
    var Node = require_node2();
    var Constrainer = require_constrainer();
    var NODE_TYPES = Node.prototype.types;
    var httpMethods = http.METHODS;
    var FULL_PATH_REGEXP = /^https?:\/\/.*?\//;
    var OPTIONAL_PARAM_REGEXP = /(\/:[^/()]*?)\?(\/?)/;
    if (!isRegexSafe(FULL_PATH_REGEXP)) {
      throw new Error("the FULL_PATH_REGEXP is not safe, update this module");
    }
    if (!isRegexSafe(OPTIONAL_PARAM_REGEXP)) {
      throw new Error("the OPTIONAL_PARAM_REGEXP is not safe, update this module");
    }
    function Router(opts) {
      if (!(this instanceof Router)) {
        return new Router(opts);
      }
      opts = opts || {};
      if (opts.defaultRoute) {
        assert(typeof opts.defaultRoute === "function", "The default route must be a function");
        this.defaultRoute = opts.defaultRoute;
      } else {
        this.defaultRoute = null;
      }
      if (opts.onBadUrl) {
        assert(typeof opts.onBadUrl === "function", "The bad url handler must be a function");
        this.onBadUrl = opts.onBadUrl;
      } else {
        this.onBadUrl = null;
      }
      if (opts.buildPrettyMeta) {
        assert(typeof opts.buildPrettyMeta === "function", "buildPrettyMeta must be a function");
        this.buildPrettyMeta = opts.buildPrettyMeta;
      } else {
        this.buildPrettyMeta = defaultBuildPrettyMeta;
      }
      this.caseSensitive = opts.caseSensitive === void 0 ? true : opts.caseSensitive;
      this.ignoreTrailingSlash = opts.ignoreTrailingSlash || false;
      this.maxParamLength = opts.maxParamLength || 100;
      this.allowUnsafeRegex = opts.allowUnsafeRegex || false;
      this.constrainer = new Constrainer(opts.constraints);
      this.trees = {};
      this.routes = [];
    }
    Router.prototype.on = function on(method, path2, opts, handler, store) {
      if (typeof opts === "function") {
        if (handler !== void 0) {
          store = handler;
        }
        handler = opts;
        opts = {};
      }
      assert(typeof path2 === "string", "Path should be a string");
      assert(path2.length > 0, "The path could not be empty");
      assert(path2[0] === "/" || path2[0] === "*", "The first character of a path should be `/` or `*`");
      assert(typeof handler === "function", "Handler should be a function");
      const optionalParamMatch = path2.match(OPTIONAL_PARAM_REGEXP);
      if (optionalParamMatch) {
        assert(path2.length === optionalParamMatch.index + optionalParamMatch[0].length, "Optional Parameter needs to be the last parameter of the path");
        const pathFull = path2.replace(OPTIONAL_PARAM_REGEXP, "$1$2");
        const pathOptional = path2.replace(OPTIONAL_PARAM_REGEXP, "$2");
        this.on(method, pathFull, opts, handler, store);
        this.on(method, pathOptional, opts, handler, store);
        return;
      }
      this._on(method, path2, opts, handler, store);
      if (this.ignoreTrailingSlash && path2 !== "/" && !path2.endsWith("*")) {
        if (path2.endsWith("/")) {
          this._on(method, path2.slice(0, -1), opts, handler, store);
        } else {
          this._on(method, path2 + "/", opts, handler, store);
        }
      }
    };
    Router.prototype._on = function _on(method, path2, opts, handler, store) {
      if (Array.isArray(method)) {
        for (var k = 0; k < method.length; k++) {
          this._on(method[k], path2, opts, handler, store);
        }
        return;
      }
      assert(typeof method === "string", "Method should be a string");
      assert(httpMethods.indexOf(method) !== -1, `Method '${method}' is not an http method.`);
      let constraints = {};
      if (opts.constraints !== void 0) {
        assert(typeof opts.constraints === "object" && opts.constraints !== null, "Constraints should be an object");
        if (Object.keys(opts.constraints).length !== 0) {
          constraints = opts.constraints;
        }
      }
      this.constrainer.validateConstraints(constraints);
      this.constrainer.noteUsage(constraints);
      const params = [];
      var j = 0;
      this.routes.push({
        method,
        path: path2,
        opts,
        handler,
        store
      });
      for (var i2 = 0, len = path2.length; i2 < len; i2++) {
        if (path2.charCodeAt(i2) === 58) {
          if (i2 !== len - 1 && path2.charCodeAt(i2 + 1) === 58) {
            path2 = path2.slice(0, i2) + path2.slice(i2 + 1);
            len = path2.length;
            continue;
          }
          var nodeType = NODE_TYPES.PARAM;
          j = i2 + 1;
          var staticPart = path2.slice(0, i2);
          if (this.caseSensitive === false) {
            staticPart = staticPart.toLowerCase();
          }
          this._insert(method, staticPart, NODE_TYPES.STATIC, null, null, null, null, constraints);
          var isRegex = false;
          while (i2 < len && path2.charCodeAt(i2) !== 47) {
            isRegex = isRegex || path2[i2] === "(";
            if (isRegex) {
              i2 = getClosingParenthensePosition(path2, i2) + 1;
              break;
            } else if (path2.charCodeAt(i2) !== 45 && path2.charCodeAt(i2) !== 46) {
              i2++;
            } else {
              break;
            }
          }
          if (isRegex && (i2 === len || path2.charCodeAt(i2) === 47)) {
            nodeType = NODE_TYPES.REGEX;
          } else if (i2 < len && path2.charCodeAt(i2) !== 47) {
            nodeType = NODE_TYPES.MULTI_PARAM;
          }
          var parameter = path2.slice(j, i2);
          var regex = isRegex ? parameter.slice(parameter.indexOf("("), i2) : null;
          if (isRegex) {
            regex = new RegExp(regex);
            if (!this.allowUnsafeRegex) {
              assert(isRegexSafe(regex), `The regex '${regex.toString()}' is not safe!`);
            }
          }
          params.push(parameter.slice(0, isRegex ? parameter.indexOf("(") : i2));
          path2 = path2.slice(0, j) + path2.slice(i2);
          i2 = j;
          len = path2.length;
          if (i2 === len) {
            var completedPath = path2.slice(0, i2);
            if (this.caseSensitive === false) {
              completedPath = completedPath.toLowerCase();
            }
            return this._insert(method, completedPath, nodeType, params, handler, store, regex, constraints);
          }
          staticPart = path2.slice(0, i2);
          if (this.caseSensitive === false) {
            staticPart = staticPart.toLowerCase();
          }
          this._insert(method, staticPart, nodeType, params, null, null, regex, constraints);
          i2--;
        } else if (path2.charCodeAt(i2) === 42) {
          this._insert(method, path2.slice(0, i2), NODE_TYPES.STATIC, null, null, null, null, constraints);
          params.push("*");
          return this._insert(method, path2.slice(0, len), NODE_TYPES.MATCH_ALL, params, handler, store, null, constraints);
        }
      }
      if (this.caseSensitive === false) {
        path2 = path2.toLowerCase();
      }
      this._insert(method, path2, NODE_TYPES.STATIC, params, handler, store, null, constraints);
    };
    Router.prototype._insert = function _insert(method, path2, kind, params, handler, store, regex, constraints) {
      const route = path2;
      var prefix = "";
      var pathLen = 0;
      var prefixLen = 0;
      var len = 0;
      var max = 0;
      var node = null;
      var currentNode = this.trees[method];
      if (typeof currentNode === "undefined") {
        currentNode = new Node({ method, constrainer: this.constrainer });
        this.trees[method] = currentNode;
      }
      while (true) {
        prefix = currentNode.prefix;
        prefixLen = prefix.length;
        pathLen = path2.length;
        len = 0;
        max = pathLen < prefixLen ? pathLen : prefixLen;
        while (len < max && path2[len] === prefix[len])
          len++;
        if (len < prefixLen) {
          node = currentNode.split(len);
          if (len === pathLen) {
            assert(!currentNode.getHandler(constraints), `Method '${method}' already declared for route '${route}' with constraints '${JSON.stringify(constraints)}'`);
            currentNode.addHandler(handler, params, store, constraints);
            currentNode.kind = kind;
          } else {
            node = new Node({
              method,
              prefix: path2.slice(len),
              kind,
              handlers: null,
              regex,
              constrainer: this.constrainer
            });
            node.addHandler(handler, params, store, constraints);
            currentNode.addChild(node);
          }
        } else if (len < pathLen) {
          path2 = path2.slice(len);
          node = currentNode.findByLabel(path2);
          if (node) {
            currentNode = node;
            continue;
          }
          node = new Node({ method, prefix: path2, kind, handlers: null, regex, constrainer: this.constrainer });
          node.addHandler(handler, params, store, constraints);
          currentNode.addChild(node);
        } else if (handler) {
          assert(!currentNode.getHandler(constraints), `Method '${method}' already declared for route '${route}' with constraints '${JSON.stringify(constraints)}'`);
          currentNode.addHandler(handler, params, store, constraints);
        }
        return;
      }
    };
    Router.prototype.reset = function reset() {
      this.trees = {};
      this.routes = [];
    };
    Router.prototype.off = function off(method, path2) {
      var self = this;
      if (Array.isArray(method)) {
        return method.map(function(method2) {
          return self.off(method2, path2);
        });
      }
      assert(typeof method === "string", "Method should be a string");
      assert(httpMethods.indexOf(method) !== -1, `Method '${method}' is not an http method.`);
      assert(typeof path2 === "string", "Path should be a string");
      assert(path2.length > 0, "The path could not be empty");
      assert(path2[0] === "/" || path2[0] === "*", "The first character of a path should be `/` or `*`");
      const optionalParamMatch = path2.match(OPTIONAL_PARAM_REGEXP);
      if (optionalParamMatch) {
        assert(path2.length === optionalParamMatch.index + optionalParamMatch[0].length, "Optional Parameter needs to be the last parameter of the path");
        const pathFull = path2.replace(OPTIONAL_PARAM_REGEXP, "$1$2");
        const pathOptional = path2.replace(OPTIONAL_PARAM_REGEXP, "$2");
        this.off(method, pathFull);
        this.off(method, pathOptional);
        return;
      }
      const ignoreTrailingSlash = this.ignoreTrailingSlash;
      var newRoutes = self.routes.filter(function(route) {
        if (!ignoreTrailingSlash) {
          return !(method === route.method && path2 === route.path);
        }
        if (path2.endsWith("/")) {
          const routeMatches2 = path2 === route.path || path2.slice(0, -1) === route.path;
          return !(method === route.method && routeMatches2);
        }
        const routeMatches = path2 === route.path || path2 + "/" === route.path;
        return !(method === route.method && routeMatches);
      });
      if (ignoreTrailingSlash) {
        newRoutes = newRoutes.filter(function(route, i2, ar) {
          if (route.path.endsWith("/") && i2 < ar.length - 1) {
            return route.path.slice(0, -1) !== ar[i2 + 1].path;
          } else if (route.path.endsWith("/") === false && i2 < ar.length - 1) {
            return route.path + "/" !== ar[i2 + 1].path;
          }
          return true;
        });
      }
      self.reset();
      newRoutes.forEach(function(route) {
        self.on(route.method, route.path, route.opts, route.handler, route.store);
      });
    };
    Router.prototype.lookup = function lookup(req, res, ctx) {
      var handle = this.find(req.method, sanitizeUrl(req.url), this.constrainer.deriveConstraints(req, ctx));
      if (handle === null)
        return this._defaultRoute(req, res, ctx);
      return ctx === void 0 ? handle.handler(req, res, handle.params, handle.store) : handle.handler.call(ctx, req, res, handle.params, handle.store);
    };
    Router.prototype.find = function find(method, path2, derivedConstraints) {
      var currentNode = this.trees[method];
      if (currentNode === void 0)
        return null;
      if (path2.charCodeAt(0) !== 47) {
        path2 = path2.replace(FULL_PATH_REGEXP, "/");
      }
      var originalPath = path2;
      var originalPathLength = path2.length;
      if (this.caseSensitive === false) {
        path2 = path2.toLowerCase();
      }
      var maxParamLength = this.maxParamLength;
      var wildcardNode = null;
      var pathLenWildcard = 0;
      var decoded = null;
      var pindex = 0;
      var params = null;
      var i2 = 0;
      var idxInOriginalPath = 0;
      while (true) {
        var pathLen = path2.length;
        var prefix = currentNode.prefix;
        if (pathLen === 0 || path2 === prefix) {
          var handle = derivedConstraints !== void 0 ? currentNode.getMatchingHandler(derivedConstraints) : currentNode.unconstrainedHandler;
          if (handle !== null && handle !== void 0) {
            var paramsObj = {};
            if (handle.paramsLength > 0) {
              var paramNames = handle.params;
              for (i2 = 0; i2 < handle.paramsLength; i2++) {
                paramsObj[paramNames[i2]] = params[i2];
              }
            }
            return {
              handler: handle.handler,
              params: paramsObj,
              store: handle.store
            };
          }
        }
        var prefixLen = prefix.length;
        var len = 0;
        var previousPath = path2;
        i2 = pathLen < prefixLen ? pathLen : prefixLen;
        while (len < i2 && path2.charCodeAt(len) === prefix.charCodeAt(len))
          len++;
        if (len === prefixLen) {
          path2 = path2.slice(len);
          pathLen = path2.length;
          idxInOriginalPath += len;
        }
        var node = currentNode.findMatchingChild(derivedConstraints, path2);
        if (node === null) {
          node = currentNode.parametricBrother;
          if (node === null) {
            return this._getWildcardNode(wildcardNode, originalPath, pathLenWildcard, derivedConstraints, params);
          }
          var goBack = previousPath.charCodeAt(0) === 47 ? previousPath : "/" + previousPath;
          if (originalPath.indexOf(goBack) === -1) {
            var pathDiff = originalPath.slice(0, originalPathLength - pathLen);
            previousPath = pathDiff.slice(pathDiff.lastIndexOf("/") + 1, pathDiff.length) + path2;
          }
          idxInOriginalPath = idxInOriginalPath - (previousPath.length - path2.length);
          path2 = previousPath;
          pathLen = previousPath.length;
          len = prefixLen;
        }
        var kind = node.kind;
        if (kind === NODE_TYPES.STATIC) {
          if (currentNode.wildcardChild !== null) {
            wildcardNode = currentNode.wildcardChild;
            pathLenWildcard = pathLen;
          }
          currentNode = node;
          continue;
        }
        if (len !== prefixLen) {
          return this._getWildcardNode(wildcardNode, originalPath, pathLenWildcard, derivedConstraints, params);
        }
        if (currentNode.wildcardChild !== null) {
          wildcardNode = currentNode.wildcardChild;
          pathLenWildcard = pathLen;
        }
        if (kind === NODE_TYPES.PARAM) {
          currentNode = node;
          i2 = path2.indexOf("/");
          if (i2 === -1)
            i2 = pathLen;
          if (i2 > maxParamLength)
            return null;
          decoded = fastDecode(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i2));
          if (decoded === null) {
            return this.onBadUrl !== null ? this._onBadUrl(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i2)) : null;
          }
          params || (params = []);
          params[pindex++] = decoded;
          path2 = path2.slice(i2);
          idxInOriginalPath += i2;
          continue;
        }
        if (kind === NODE_TYPES.MATCH_ALL) {
          decoded = fastDecode(originalPath.slice(idxInOriginalPath));
          if (decoded === null) {
            return this.onBadUrl !== null ? this._onBadUrl(originalPath.slice(idxInOriginalPath)) : null;
          }
          params || (params = []);
          params[pindex] = decoded;
          currentNode = node;
          path2 = "";
          continue;
        }
        if (kind === NODE_TYPES.REGEX) {
          currentNode = node;
          i2 = path2.indexOf("/");
          if (i2 === -1)
            i2 = pathLen;
          if (i2 > maxParamLength)
            return null;
          decoded = fastDecode(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i2));
          if (decoded === null) {
            return this.onBadUrl !== null ? this._onBadUrl(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i2)) : null;
          }
          if (!node.regex.test(decoded))
            return null;
          params || (params = []);
          params[pindex++] = decoded;
          path2 = path2.slice(i2);
          idxInOriginalPath += i2;
          continue;
        }
        if (kind === NODE_TYPES.MULTI_PARAM) {
          currentNode = node;
          i2 = 0;
          if (node.regex !== null) {
            var matchedParameter = path2.match(node.regex);
            if (matchedParameter === null)
              return null;
            i2 = matchedParameter[1].length;
          } else {
            while (i2 < pathLen && path2.charCodeAt(i2) !== 47 && path2.charCodeAt(i2) !== 45 && path2.charCodeAt(i2) !== 46)
              i2++;
            if (i2 > maxParamLength)
              return null;
          }
          decoded = fastDecode(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i2));
          if (decoded === null) {
            return this.onBadUrl !== null ? this._onBadUrl(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i2)) : null;
          }
          params || (params = []);
          params[pindex++] = decoded;
          path2 = path2.slice(i2);
          idxInOriginalPath += i2;
          continue;
        }
        wildcardNode = null;
      }
    };
    Router.prototype._getWildcardNode = function(node, path2, len, derivedConstraints, params) {
      if (node === null)
        return null;
      var decoded = fastDecode(path2.slice(-len));
      if (decoded === null) {
        return this.onBadUrl !== null ? this._onBadUrl(path2.slice(-len)) : null;
      }
      var handle = derivedConstraints !== void 0 ? node.getMatchingHandler(derivedConstraints) : node.unconstrainedHandler;
      if (handle !== null && handle !== void 0) {
        var paramsObj = {};
        if (handle.paramsLength > 0 && params !== null) {
          var paramNames = handle.params;
          for (i = 0; i < handle.paramsLength; i++) {
            paramsObj[paramNames[i]] = params[i];
          }
        }
        paramsObj["*"] = decoded;
        return {
          handler: handle.handler,
          params: paramsObj,
          store: handle.store
        };
      }
      return null;
    };
    Router.prototype._defaultRoute = function(req, res, ctx) {
      if (this.defaultRoute !== null) {
        return ctx === void 0 ? this.defaultRoute(req, res) : this.defaultRoute.call(ctx, req, res);
      } else {
        res.statusCode = 404;
        res.end();
      }
    };
    Router.prototype._onBadUrl = function(path2) {
      const onBadUrl = this.onBadUrl;
      return {
        handler: (req, res, ctx) => onBadUrl(path2, req, res),
        params: {},
        store: null
      };
    };
    Router.prototype.prettyPrint = function(opts = {}) {
      opts.commonPrefix = opts.commonPrefix === void 0 ? true : opts.commonPrefix;
      if (!opts.commonPrefix)
        return prettyPrintRoutesArray.call(this, this.routes, opts);
      const root = {
        prefix: "/",
        nodes: [],
        children: {}
      };
      for (const node of Object.values(this.trees)) {
        if (node) {
          flattenNode(root, node);
        }
      }
      compressFlattenedNode(root);
      return prettyPrintFlattenedNode.call(this, root, "", true, opts);
    };
    for (i in http.METHODS) {
      if (!http.METHODS.hasOwnProperty(i))
        continue;
      const m = http.METHODS[i];
      const methodName = m.toLowerCase();
      if (Router.prototype[methodName])
        throw new Error("Method already exists: " + methodName);
      Router.prototype[methodName] = function(path2, handler, store) {
        return this.on(m, path2, handler, store);
      };
    }
    var i;
    Router.prototype.all = function(path2, handler, store) {
      this.on(httpMethods, path2, handler, store);
    };
    module2.exports = Router;
    function sanitizeUrl(url) {
      for (var i2 = 0, len = url.length; i2 < len; i2++) {
        var charCode = url.charCodeAt(i2);
        if (charCode === 63 || charCode === 59 || charCode === 35) {
          return url.slice(0, i2);
        }
      }
      return url;
    }
    function getClosingParenthensePosition(path2, idx) {
      var parentheses = 1;
      while (idx < path2.length) {
        idx++;
        if (path2[idx] === "\\") {
          idx++;
          continue;
        }
        if (path2[idx] === ")") {
          parentheses--;
        } else if (path2[idx] === "(") {
          parentheses++;
        }
        if (!parentheses)
          return idx;
      }
      throw new TypeError('Invalid regexp expression in "' + path2 + '"');
    }
    function defaultBuildPrettyMeta(route) {
      if (!route)
        return {};
      if (!route.store)
        return {};
      return Object.assign({}, route.store);
    }
  }
});

// packages/platform-fastify/node_modules/fastify/lib/context.js
var require_context = __commonJS({
  "packages/platform-fastify/node_modules/fastify/lib/context.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var { kFourOhFourContext, kReplySerializerDefault } = require_symbols();
    function Context(schema, handler, Reply2, Request2, contentTypeParser, config, errorHandler, bodyLimit, logLevel, logSerializers, attachValidation, replySerializer, schemaErrorFormatter) {
      this.schema = schema;
      this.handler = handler;
      this.Reply = Reply2;
      this.Request = Request2;
      this.contentTypeParser = contentTypeParser;
      this.onRequest = null;
      this.onSend = null;
      this.onError = null;
      this.onTimeout = null;
      this.preHandler = null;
      this.onResponse = null;
      this.config = config;
      this.errorHandler = errorHandler;
      this._middie = null;
      this._parserOptions = { limit: bodyLimit || null };
      this.logLevel = logLevel;
      this.logSerializers = logSerializers;
      this[kFourOhFourContext] = null;
      this.attachValidation = attachValidation;
      this[kReplySerializerDefault] = replySerializer;
      this.schemaErrorFormatter = schemaErrorFormatter || defaultSchemaErrorFormatter;
    }
    function defaultSchemaErrorFormatter(errors, dataVar) {
      let text = "";
      const separator = ", ";
      for (var i = 0; i !== errors.length; ++i) {
        const e = errors[i];
        text += dataVar + (e.dataPath || "") + " " + e.message + separator;
      }
      return new Error(text.slice(0, -separator.length));
    }
    module2.exports = Context;
  }
});

// packages/platform-fastify/node_modules/fastify/lib/headRoute.js
var require_headRoute = __commonJS({
  "packages/platform-fastify/node_modules/fastify/lib/headRoute.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    function headRouteOnSendHandler(req, reply, payload, done) {
      if (payload === void 0) {
        reply.header("content-length", "0");
        return done(null, null);
      }
      if (typeof payload.resume === "function") {
        payload.on("error", (err) => {
          reply.log.error({ err }, "Error on Stream found for HEAD route");
        });
        payload.resume();
        return done(null, null);
      }
      const size = "" + Buffer.byteLength(payload);
      reply.header("content-length", size);
      done(null, null);
    }
    function parseHeadOnSendHandlers(onSendHandlers) {
      if (onSendHandlers == null)
        return headRouteOnSendHandler;
      return Array.isArray(onSendHandlers) ? [...onSendHandlers, headRouteOnSendHandler] : [onSendHandlers, headRouteOnSendHandler];
    }
    module2.exports = {
      parseHeadOnSendHandlers
    };
  }
});

// packages/platform-fastify/node_modules/fastify/lib/route.js
var require_route = __commonJS({
  "packages/platform-fastify/node_modules/fastify/lib/route.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var FindMyWay = require_find_my_way();
    var Context = require_context();
    var handleRequest = require_handleRequest();
    var { hookRunner, hookIterator, lifecycleHooks } = require_hooks();
    var supportedMethods = ["DELETE", "GET", "HEAD", "PATCH", "POST", "PUT", "OPTIONS"];
    var { normalizeSchema } = require_schemas();
    var { parseHeadOnSendHandlers } = require_headRoute();
    var warning = require_warnings();
    var { kRequestAcceptVersion } = require_symbols();
    var {
      compileSchemasForValidation,
      compileSchemasForSerialization
    } = require_validation();
    var {
      FST_ERR_SCH_VALIDATION_BUILD,
      FST_ERR_SCH_SERIALIZATION_BUILD,
      FST_ERR_DEFAULT_ROUTE_INVALID_TYPE,
      FST_ERR_INVALID_URL
    } = require_errors();
    var {
      kRoutePrefix,
      kLogLevel,
      kLogSerializers,
      kHooks,
      kHooksDeprecatedPreParsing,
      kSchemaController,
      kOptions,
      kContentTypeParser,
      kReply,
      kReplySerializerDefault,
      kReplyIsError,
      kRequest,
      kRequestPayloadStream,
      kDisableRequestLogging,
      kSchemaErrorFormatter,
      kErrorHandler
    } = require_symbols();
    function buildRouting(options) {
      const { keepAliveConnections } = options;
      const router = FindMyWay(options.config);
      let avvio;
      let fourOhFour;
      let requestIdHeader;
      let querystringParser;
      let requestIdLogLabel;
      let logger2;
      let hasLogger;
      let setupResponseListeners;
      let throwIfAlreadyStarted;
      let genReqId;
      let disableRequestLogging;
      let ignoreTrailingSlash;
      let return503OnClosing;
      let globalExposeHeadRoutes;
      let closing = false;
      return {
        setup(options2, fastifyArgs) {
          avvio = fastifyArgs.avvio;
          fourOhFour = fastifyArgs.fourOhFour;
          logger2 = fastifyArgs.logger;
          hasLogger = fastifyArgs.hasLogger;
          setupResponseListeners = fastifyArgs.setupResponseListeners;
          throwIfAlreadyStarted = fastifyArgs.throwIfAlreadyStarted;
          globalExposeHeadRoutes = options2.exposeHeadRoutes;
          requestIdHeader = options2.requestIdHeader;
          querystringParser = options2.querystringParser;
          requestIdLogLabel = options2.requestIdLogLabel;
          genReqId = options2.genReqId;
          disableRequestLogging = options2.disableRequestLogging;
          ignoreTrailingSlash = options2.ignoreTrailingSlash;
          return503OnClosing = Object.prototype.hasOwnProperty.call(options2, "return503OnClosing") ? options2.return503OnClosing : true;
        },
        routing: router.lookup.bind(router),
        route,
        prepareRoute,
        getDefaultRoute: function() {
          return router.defaultRoute;
        },
        setDefaultRoute: function(defaultRoute) {
          if (typeof defaultRoute !== "function") {
            throw new FST_ERR_DEFAULT_ROUTE_INVALID_TYPE();
          }
          router.defaultRoute = defaultRoute;
        },
        routeHandler,
        closeRoutes: () => {
          closing = true;
        },
        printRoutes: router.prettyPrint.bind(router)
      };
      function prepareRoute(method, url, options2, handler) {
        if (typeof url !== "string") {
          throw new FST_ERR_INVALID_URL(typeof url);
        }
        if (!handler && typeof options2 === "function") {
          handler = options2;
          options2 = {};
        } else if (handler && typeof handler === "function") {
          if (Object.prototype.toString.call(options2) !== "[object Object]") {
            throw new Error(`Options for ${method}:${url} route must be an object`);
          } else if (options2.handler) {
            if (typeof options2.handler === "function") {
              throw new Error(`Duplicate handler for ${method}:${url} route is not allowed!`);
            } else {
              throw new Error(`Handler for ${method}:${url} route must be a function`);
            }
          }
        }
        options2 = Object.assign({}, options2, {
          method,
          url,
          path: url,
          handler: handler || options2 && options2.handler
        });
        return route.call(this, options2);
      }
      function route(options2) {
        const opts = __spreadValues({}, options2);
        throwIfAlreadyStarted("Cannot add route when fastify instance is already started!");
        if (Array.isArray(opts.method)) {
          for (var i = 0; i < opts.method.length; ++i) {
            const method = opts.method[i];
            if (supportedMethods.indexOf(method) === -1) {
              throw new Error(`${method} method is not supported!`);
            }
          }
        } else {
          if (supportedMethods.indexOf(opts.method) === -1) {
            throw new Error(`${opts.method} method is not supported!`);
          }
        }
        const path2 = opts.url || opts.path;
        if (!opts.handler) {
          throw new Error(`Missing handler function for ${opts.method}:${path2} route.`);
        }
        if (opts.errorHandler !== void 0 && typeof opts.errorHandler !== "function") {
          throw new Error(`Error Handler for ${opts.method}:${path2} route, if defined, must be a function`);
        }
        validateBodyLimitOption(opts.bodyLimit);
        const prefix = this[kRoutePrefix];
        this.after((notHandledErr, done) => {
          if (path2 === "/" && prefix.length && opts.method !== "HEAD") {
            switch (opts.prefixTrailingSlash) {
              case "slash":
                afterRouteAdded.call(this, { path: path2 }, notHandledErr, done);
                break;
              case "no-slash":
                afterRouteAdded.call(this, { path: "" }, notHandledErr, done);
                break;
              case "both":
              default:
                afterRouteAdded.call(this, { path: "" }, notHandledErr, done);
                if (ignoreTrailingSlash !== true) {
                  afterRouteAdded.call(this, { path: path2, prefixing: true }, notHandledErr, done);
                }
            }
          } else if (path2 && path2[0] === "/" && prefix.endsWith("/")) {
            afterRouteAdded.call(this, { path: path2.slice(1) }, notHandledErr, done);
          } else {
            afterRouteAdded.call(this, { path: path2 }, notHandledErr, done);
          }
        });
        return this;
        function afterRouteAdded({ path: path3, prefixing = false }, notHandledErr, done) {
          const url = prefix + path3;
          opts.url = url;
          opts.path = url;
          opts.routePath = path3;
          opts.prefix = prefix;
          opts.logLevel = opts.logLevel || this[kLogLevel];
          if (this[kLogSerializers] || opts.logSerializers) {
            opts.logSerializers = Object.assign(Object.create(this[kLogSerializers]), opts.logSerializers);
          }
          if (opts.attachValidation == null) {
            opts.attachValidation = false;
          }
          if (prefixing === false) {
            for (const hook of this[kHooks].onRoute) {
              try {
                hook.call(this, opts);
              } catch (error) {
                done(error);
                return;
              }
            }
          }
          const config = __spreadProps(__spreadValues({}, opts.config), {
            url,
            method: opts.method
          });
          const constraints = opts.constraints || {};
          if (opts.version) {
            warning.emit("FSTDEP008");
            constraints.version = opts.version;
          }
          const context = new Context(opts.schema, opts.handler.bind(this), this[kReply], this[kRequest], this[kContentTypeParser], config, opts.errorHandler || this[kErrorHandler], opts.bodyLimit, opts.logLevel, opts.logSerializers, opts.attachValidation, this[kReplySerializerDefault], opts.schemaErrorFormatter || this[kSchemaErrorFormatter]);
          const headRouteExists = router.find("HEAD", url, constraints) != null;
          try {
            router.on(opts.method, opts.url, { constraints }, routeHandler, context);
          } catch (err) {
            done(err);
            return;
          }
          const { exposeHeadRoute } = opts;
          const hasRouteExposeHeadRouteFlag = exposeHeadRoute != null;
          const shouldExposeHead = hasRouteExposeHeadRouteFlag ? exposeHeadRoute : globalExposeHeadRoutes;
          if (shouldExposeHead && options2.method === "GET" && !headRouteExists) {
            const onSendHandlers = parseHeadOnSendHandlers(opts.onSend);
            prepareRoute.call(this, "HEAD", path3, __spreadProps(__spreadValues({}, opts), { onSend: onSendHandlers }));
          } else if (headRouteExists && exposeHeadRoute) {
            warning.emit("FSTDEP007");
          }
          avvio.once("preReady", () => {
            for (const hook of lifecycleHooks) {
              const toSet = this[kHooks][hook].concat(opts[hook] || []).map((h) => {
                const bound = h.bind(this);
                if (hook === "preParsing") {
                  if (h.length === (h.constructor.name === "AsyncFunction" ? 2 : 3)) {
                    warning.emit("FSTDEP004");
                    bound[kHooksDeprecatedPreParsing] = true;
                  }
                }
                return bound;
              });
              context[hook] = toSet.length ? toSet : null;
            }
            fourOhFour.setContext(this, context);
            if (opts.schema) {
              context.schema = normalizeSchema(context.schema, this.initialConfig);
              const schemaController = this[kSchemaController];
              if (!opts.validatorCompiler && (opts.schema.body || opts.schema.headers || opts.schema.querystring || opts.schema.params)) {
                schemaController.setupValidator(this[kOptions]);
              }
              try {
                compileSchemasForValidation(context, opts.validatorCompiler || schemaController.validatorCompiler);
              } catch (error) {
                throw new FST_ERR_SCH_VALIDATION_BUILD(opts.method, url, error.message);
              }
              if (opts.schema.response && !opts.serializerCompiler) {
                schemaController.setupSerializer(this[kOptions]);
              }
              try {
                compileSchemasForSerialization(context, opts.serializerCompiler || schemaController.serializerCompiler);
              } catch (error) {
                throw new FST_ERR_SCH_SERIALIZATION_BUILD(opts.method, url, error.message);
              }
            }
          });
          done(notHandledErr);
        }
      }
      function routeHandler(req, res, params, context) {
        if (closing === true) {
          if (req.httpVersionMajor !== 2) {
            res.once("finish", () => req.destroy());
            res.setHeader("Connection", "close");
          }
          if (return503OnClosing) {
            const headers = {
              "Content-Type": "application/json",
              "Content-Length": "80"
            };
            res.writeHead(503, headers);
            res.end('{"error":"Service Unavailable","message":"Service Unavailable","statusCode":503}');
            return;
          }
        }
        const connHeader = String.prototype.toLowerCase.call(req.headers.connection || "");
        if (connHeader === "keep-alive") {
          if (keepAliveConnections.has(req.socket) === false) {
            keepAliveConnections.add(req.socket);
            req.socket.on("close", removeTrackedSocket.bind({ keepAliveConnections, socket: req.socket }));
          }
        }
        if (req.headers[kRequestAcceptVersion] !== void 0) {
          req.headers["accept-version"] = req.headers[kRequestAcceptVersion];
          req.headers[kRequestAcceptVersion] = void 0;
        }
        const id = req.headers[requestIdHeader] || genReqId(req);
        const loggerBinding = {
          [requestIdLogLabel]: id
        };
        const loggerOpts = {
          level: context.logLevel
        };
        if (context.logSerializers) {
          loggerOpts.serializers = context.logSerializers;
        }
        const childLogger = logger2.child(loggerBinding, loggerOpts);
        childLogger[kDisableRequestLogging] = disableRequestLogging;
        const queryPrefix = req.url.indexOf("?");
        const query = querystringParser(queryPrefix > -1 ? req.url.slice(queryPrefix + 1) : "");
        const request = new context.Request(id, params, req, query, childLogger, context);
        const reply = new context.Reply(res, request, childLogger);
        if (disableRequestLogging === false) {
          childLogger.info({ req: request }, "incoming request");
        }
        if (hasLogger === true || context.onResponse !== null) {
          setupResponseListeners(reply);
        }
        if (context.onRequest !== null) {
          hookRunner(context.onRequest, hookIterator, request, reply, runPreParsing);
        } else {
          runPreParsing(null, request, reply);
        }
        if (context.onTimeout !== null) {
          if (!request.raw.socket._meta) {
            request.raw.socket.on("timeout", handleTimeout);
          }
          request.raw.socket._meta = { context, request, reply };
        }
      }
    }
    function handleTimeout() {
      const { context, request, reply } = this._meta;
      hookRunner(context.onTimeout, hookIterator, request, reply, noop);
    }
    function validateBodyLimitOption(bodyLimit) {
      if (bodyLimit === void 0)
        return;
      if (!Number.isInteger(bodyLimit) || bodyLimit <= 0) {
        throw new TypeError(`'bodyLimit' option must be an integer > 0. Got '${bodyLimit}'`);
      }
    }
    function runPreParsing(err, request, reply) {
      if (reply.sent === true)
        return;
      if (err != null) {
        reply.send(err);
        return;
      }
      request[kRequestPayloadStream] = request.raw;
      if (reply.context.preParsing !== null) {
        preParsingHookRunner(reply.context.preParsing, request, reply, handleRequest);
      } else {
        handleRequest(null, request, reply);
      }
    }
    function preParsingHookRunner(functions, request, reply, cb) {
      let i = 0;
      function next(err, stream) {
        if (reply.sent) {
          return;
        }
        if (typeof stream !== "undefined") {
          request[kRequestPayloadStream] = stream;
        }
        if (err || i === functions.length) {
          if (err && !(err instanceof Error)) {
            reply[kReplyIsError] = true;
          }
          cb(err, request, reply);
          return;
        }
        const fn2 = functions[i++];
        let result;
        try {
          if (fn2[kHooksDeprecatedPreParsing]) {
            result = fn2(request, reply, next);
          } else {
            result = fn2(request, reply, request[kRequestPayloadStream], next);
          }
        } catch (error) {
          next(error);
          return;
        }
        if (result && typeof result.then === "function") {
          result.then(handleResolve, handleReject);
        }
      }
      function handleResolve(stream) {
        next(null, stream);
      }
      function handleReject(err) {
        next(err);
      }
      next(null, request[kRequestPayloadStream]);
    }
    function removeTrackedSocket() {
      this.keepAliveConnections.delete(this.socket);
    }
    function noop() {
    }
    module2.exports = { buildRouting, validateBodyLimitOption };
  }
});

// packages/platform-fastify/node_modules/fastify/lib/fourOhFour.js
var require_fourOhFour = __commonJS({
  "packages/platform-fastify/node_modules/fastify/lib/fourOhFour.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var FindMyWay = require_find_my_way();
    var Reply2 = require_reply();
    var Request2 = require_request();
    var Context = require_context();
    var {
      kRoutePrefix,
      kCanSetNotFoundHandler,
      kFourOhFourLevelInstance,
      kReply,
      kRequest,
      kContentTypeParser,
      kBodyLimit,
      kLogLevel,
      kFourOhFourContext,
      kHooks,
      kErrorHandler
    } = require_symbols();
    var { lifecycleHooks } = require_hooks();
    var fourOhFourContext = {
      config: {},
      onSend: [],
      onError: []
    };
    function fourOhFour(options) {
      const { logger: logger2, genReqId } = options;
      const router = FindMyWay({ defaultRoute: fourOhFourFallBack });
      return { router, setNotFoundHandler, setContext, arrange404 };
      function arrange404(instance) {
        instance[kFourOhFourLevelInstance] = instance;
        instance[kCanSetNotFoundHandler] = true;
      }
      function basic404(request, reply) {
        const { url, method } = request.raw;
        const message2 = `Route ${method}:${url} not found`;
        request.log.info(message2);
        reply.code(404).send({
          message: message2,
          error: "Not Found",
          statusCode: 404
        });
      }
      function setContext(instance, context) {
        const _404Context = Object.assign({}, instance[kFourOhFourContext]);
        _404Context.onSend = context.onSend;
        context[kFourOhFourContext] = _404Context;
      }
      function setNotFoundHandler(opts, handler, avvio, routeHandler) {
        if (this[kCanSetNotFoundHandler] === void 0) {
          this[kCanSetNotFoundHandler] = true;
        }
        if (this[kFourOhFourContext] === void 0) {
          this[kFourOhFourContext] = null;
        }
        const _fastify = this;
        const prefix = this[kRoutePrefix] || "/";
        if (this[kCanSetNotFoundHandler] === false) {
          throw new Error(`Not found handler already set for Fastify instance with prefix: '${prefix}'`);
        }
        if (typeof opts === "object") {
          if (opts.preHandler) {
            if (Array.isArray(opts.preHandler)) {
              opts.preHandler = opts.preHandler.map((hook) => hook.bind(_fastify));
            } else {
              opts.preHandler = opts.preHandler.bind(_fastify);
            }
          }
          if (opts.preValidation) {
            if (Array.isArray(opts.preValidation)) {
              opts.preValidation = opts.preValidation.map((hook) => hook.bind(_fastify));
            } else {
              opts.preValidation = opts.preValidation.bind(_fastify);
            }
          }
        }
        if (typeof opts === "function") {
          handler = opts;
          opts = void 0;
        }
        opts = opts || {};
        if (handler) {
          this[kFourOhFourLevelInstance][kCanSetNotFoundHandler] = false;
          handler = handler.bind(this);
        } else {
          handler = basic404;
        }
        this.after((notHandledErr, done) => {
          _setNotFoundHandler.call(this, prefix, opts, handler, avvio, routeHandler);
          done(notHandledErr);
        });
      }
      function _setNotFoundHandler(prefix, opts, handler, avvio, routeHandler) {
        const context = new Context(opts.schema, handler, this[kReply], this[kRequest], this[kContentTypeParser], opts.config || {}, this[kErrorHandler], this[kBodyLimit], this[kLogLevel]);
        avvio.once("preReady", () => {
          const context2 = this[kFourOhFourContext];
          for (const hook of lifecycleHooks) {
            const toSet = this[kHooks][hook].concat(opts[hook] || []).map((h) => h.bind(this));
            context2[hook] = toSet.length ? toSet : null;
          }
        });
        if (this[kFourOhFourContext] !== null && prefix === "/") {
          Object.assign(this[kFourOhFourContext], context);
          return;
        }
        this[kFourOhFourLevelInstance][kFourOhFourContext] = context;
        router.all(prefix + (prefix.endsWith("/") ? "*" : "/*"), routeHandler, context);
        router.all(prefix, routeHandler, context);
      }
      function fourOhFourFallBack(req, res) {
        const id = genReqId(req);
        const childLogger = logger2.child({ reqId: id });
        childLogger.info({ req }, "incoming request");
        const request = new Request2(id, null, req, null, childLogger, fourOhFourContext);
        const reply = new Reply2(res, request, childLogger);
        request.log.warn("the default handler for 404 did not catch this, this is likely a fastify bug, please report it");
        request.log.warn(router.prettyPrint());
        reply.code(404).send(new Error("Not Found"));
      }
    }
    module2.exports = fourOhFour;
  }
});

// packages/platform-fastify/node_modules/fastify/lib/configValidator.js
var require_configValidator = __commonJS({
  "packages/platform-fastify/node_modules/fastify/lib/configValidator.js"(exports2, module2) {
    init_esm_shims();
    var self = {};
    var validate = function() {
      var refVal = [];
      return function validate2(data, dataPath, parentData, parentDataProperty, rootData) {
        "use strict";
        var vErrors = null;
        var errors = 0;
        if (rootData === void 0)
          rootData = data;
        if (data && typeof data === "object" && !Array.isArray(data)) {
          if (data.connectionTimeout === void 0)
            data.connectionTimeout = 0;
          if (data.keepAliveTimeout === void 0)
            data.keepAliveTimeout = 5e3;
          if (data.maxRequestsPerSocket === void 0)
            data.maxRequestsPerSocket = 0;
          if (data.requestTimeout === void 0)
            data.requestTimeout = 0;
          if (data.bodyLimit === void 0)
            data.bodyLimit = 1048576;
          if (data.caseSensitive === void 0)
            data.caseSensitive = true;
          if (data.ignoreTrailingSlash === void 0)
            data.ignoreTrailingSlash = false;
          if (data.disableRequestLogging === void 0)
            data.disableRequestLogging = false;
          if (data.jsonShorthand === void 0)
            data.jsonShorthand = true;
          if (data.maxParamLength === void 0)
            data.maxParamLength = 100;
          if (data.onProtoPoisoning === void 0)
            data.onProtoPoisoning = "error";
          if (data.onConstructorPoisoning === void 0)
            data.onConstructorPoisoning = "error";
          if (data.pluginTimeout === void 0)
            data.pluginTimeout = 1e4;
          if (data.requestIdHeader === void 0)
            data.requestIdHeader = "request-id";
          if (data.requestIdLogLabel === void 0)
            data.requestIdLogLabel = "reqId";
          if (data.http2SessionTimeout === void 0)
            data.http2SessionTimeout = 5e3;
          var errs__0 = errors;
          var valid1 = true;
          for (var key0 in data) {
            var isAdditional0 = !validate2.schema.properties.hasOwnProperty(key0);
            if (isAdditional0) {
              delete data[key0];
            }
          }
          if (valid1) {
            var data1 = data.connectionTimeout;
            var errs_1 = errors;
            if (typeof data1 !== "number" || data1 % 1 || data1 !== data1) {
              var dataType1 = typeof data1;
              var coerced1 = void 0;
              if (coerced1 !== void 0)
                ;
              else if (dataType1 == "boolean" || data1 === null || dataType1 == "string" && data1 && data1 == +data1 && !(data1 % 1))
                coerced1 = +data1;
              else {
                validate2.errors = [{
                  keyword: "type",
                  dataPath: (dataPath || "") + ".connectionTimeout",
                  schemaPath: "#/properties/connectionTimeout/type",
                  params: {
                    type: "integer"
                  },
                  message: "should be integer"
                }];
                return false;
              }
              if (coerced1 !== void 0) {
                data1 = coerced1;
                data["connectionTimeout"] = coerced1;
              }
            }
            var valid1 = errors === errs_1;
            if (valid1) {
              var data1 = data.keepAliveTimeout;
              var errs_1 = errors;
              if (typeof data1 !== "number" || data1 % 1 || data1 !== data1) {
                var dataType1 = typeof data1;
                var coerced1 = void 0;
                if (coerced1 !== void 0)
                  ;
                else if (dataType1 == "boolean" || data1 === null || dataType1 == "string" && data1 && data1 == +data1 && !(data1 % 1))
                  coerced1 = +data1;
                else {
                  validate2.errors = [{
                    keyword: "type",
                    dataPath: (dataPath || "") + ".keepAliveTimeout",
                    schemaPath: "#/properties/keepAliveTimeout/type",
                    params: {
                      type: "integer"
                    },
                    message: "should be integer"
                  }];
                  return false;
                }
                if (coerced1 !== void 0) {
                  data1 = coerced1;
                  data["keepAliveTimeout"] = coerced1;
                }
              }
              var valid1 = errors === errs_1;
              if (valid1) {
                var data1 = data.maxRequestsPerSocket;
                var errs_1 = errors;
                if (typeof data1 !== "number" || data1 % 1 || data1 !== data1) {
                  var dataType1 = typeof data1;
                  var coerced1 = void 0;
                  if (coerced1 !== void 0)
                    ;
                  else if (dataType1 == "boolean" || data1 === null || dataType1 == "string" && data1 && data1 == +data1 && !(data1 % 1))
                    coerced1 = +data1;
                  else {
                    validate2.errors = [{
                      keyword: "type",
                      dataPath: (dataPath || "") + ".maxRequestsPerSocket",
                      schemaPath: "#/properties/maxRequestsPerSocket/type",
                      params: {
                        type: "integer"
                      },
                      message: "should be integer"
                    }];
                    return false;
                  }
                  if (coerced1 !== void 0) {
                    data1 = coerced1;
                    data["maxRequestsPerSocket"] = coerced1;
                  }
                }
                var valid1 = errors === errs_1;
                if (valid1) {
                  var data1 = data.requestTimeout;
                  var errs_1 = errors;
                  if (typeof data1 !== "number" || data1 % 1 || data1 !== data1) {
                    var dataType1 = typeof data1;
                    var coerced1 = void 0;
                    if (coerced1 !== void 0)
                      ;
                    else if (dataType1 == "boolean" || data1 === null || dataType1 == "string" && data1 && data1 == +data1 && !(data1 % 1))
                      coerced1 = +data1;
                    else {
                      validate2.errors = [{
                        keyword: "type",
                        dataPath: (dataPath || "") + ".requestTimeout",
                        schemaPath: "#/properties/requestTimeout/type",
                        params: {
                          type: "integer"
                        },
                        message: "should be integer"
                      }];
                      return false;
                    }
                    if (coerced1 !== void 0) {
                      data1 = coerced1;
                      data["requestTimeout"] = coerced1;
                    }
                  }
                  var valid1 = errors === errs_1;
                  if (valid1) {
                    var data1 = data.bodyLimit;
                    var errs_1 = errors;
                    if (typeof data1 !== "number" || data1 % 1 || data1 !== data1) {
                      var dataType1 = typeof data1;
                      var coerced1 = void 0;
                      if (coerced1 !== void 0)
                        ;
                      else if (dataType1 == "boolean" || data1 === null || dataType1 == "string" && data1 && data1 == +data1 && !(data1 % 1))
                        coerced1 = +data1;
                      else {
                        validate2.errors = [{
                          keyword: "type",
                          dataPath: (dataPath || "") + ".bodyLimit",
                          schemaPath: "#/properties/bodyLimit/type",
                          params: {
                            type: "integer"
                          },
                          message: "should be integer"
                        }];
                        return false;
                      }
                      if (coerced1 !== void 0) {
                        data1 = coerced1;
                        data["bodyLimit"] = coerced1;
                      }
                    }
                    var valid1 = errors === errs_1;
                    if (valid1) {
                      var data1 = data.caseSensitive;
                      var errs_1 = errors;
                      if (typeof data1 !== "boolean") {
                        var dataType1 = typeof data1;
                        var coerced1 = void 0;
                        if (coerced1 !== void 0)
                          ;
                        else if (data1 === "false" || data1 === 0 || data1 === null)
                          coerced1 = false;
                        else if (data1 === "true" || data1 === 1)
                          coerced1 = true;
                        else {
                          validate2.errors = [{
                            keyword: "type",
                            dataPath: (dataPath || "") + ".caseSensitive",
                            schemaPath: "#/properties/caseSensitive/type",
                            params: {
                              type: "boolean"
                            },
                            message: "should be boolean"
                          }];
                          return false;
                        }
                        if (coerced1 !== void 0) {
                          data1 = coerced1;
                          data["caseSensitive"] = coerced1;
                        }
                      }
                      var valid1 = errors === errs_1;
                      if (valid1) {
                        var data1 = data.http2;
                        if (data1 === void 0) {
                          valid1 = true;
                        } else {
                          var errs_1 = errors;
                          if (typeof data1 !== "boolean") {
                            var dataType1 = typeof data1;
                            var coerced1 = void 0;
                            if (coerced1 !== void 0)
                              ;
                            else if (data1 === "false" || data1 === 0 || data1 === null)
                              coerced1 = false;
                            else if (data1 === "true" || data1 === 1)
                              coerced1 = true;
                            else {
                              validate2.errors = [{
                                keyword: "type",
                                dataPath: (dataPath || "") + ".http2",
                                schemaPath: "#/properties/http2/type",
                                params: {
                                  type: "boolean"
                                },
                                message: "should be boolean"
                              }];
                              return false;
                            }
                            if (coerced1 !== void 0) {
                              data1 = coerced1;
                              data["http2"] = coerced1;
                            }
                          }
                          var valid1 = errors === errs_1;
                        }
                        if (valid1) {
                          var data1 = data.https;
                          if (data1 === void 0) {
                            valid1 = true;
                          } else {
                            var errs_1 = errors;
                            var errs__1 = errors;
                            var valid1 = true;
                            var errs_2 = errors;
                            var errs__2 = errors;
                            var errs_3 = errors;
                            var errs__3 = errors, prevValid3 = false, valid3 = false, passingSchemas3 = null;
                            var errs_4 = errors;
                            if (typeof data1 !== "boolean") {
                              var dataType4 = typeof data1;
                              var coerced4 = void 0;
                              if (coerced4 !== void 0)
                                ;
                              else if (data1 === "false" || data1 === 0 || data1 === null)
                                coerced4 = false;
                              else if (data1 === "true" || data1 === 1)
                                coerced4 = true;
                              else {
                                var err = {};
                                if (vErrors === null)
                                  vErrors = [err];
                                else
                                  vErrors.push(err);
                                errors++;
                              }
                              if (coerced4 !== void 0) {
                                data1 = coerced4;
                                data["https"] = coerced4;
                              }
                            }
                            var valid4 = errors === errs_4;
                            if (valid4) {
                              valid3 = prevValid3 = true;
                              passingSchemas3 = 0;
                            }
                            var errs_4 = errors;
                            if (data1 !== null) {
                              var dataType4 = typeof data1;
                              var coerced4 = void 0;
                              if (coerced4 !== void 0)
                                ;
                              else if (data1 === "" || data1 === 0 || data1 === false)
                                coerced4 = null;
                              else {
                                var err = {};
                                if (vErrors === null)
                                  vErrors = [err];
                                else
                                  vErrors.push(err);
                                errors++;
                              }
                              if (coerced4 !== void 0) {
                                data1 = coerced4;
                                data["https"] = coerced4;
                              }
                            }
                            var valid4 = errors === errs_4;
                            if (valid4 && prevValid3) {
                              valid3 = false;
                              passingSchemas3 = [passingSchemas3, 1];
                            } else {
                              if (valid4) {
                                valid3 = prevValid3 = true;
                                passingSchemas3 = 1;
                              }
                              var errs_4 = errors;
                              if (data1 && typeof data1 === "object" && !Array.isArray(data1)) {
                                if (true) {
                                  var errs__4 = errors;
                                  var valid5 = true;
                                  for (var key4 in data1) {
                                    var isAdditional4 = !(key4 == "allowHTTP1");
                                    if (isAdditional4) {
                                      delete data1[key4];
                                    }
                                  }
                                  if (valid5) {
                                    var data2 = data1.allowHTTP1;
                                    if (data2 === void 0) {
                                      valid5 = false;
                                      var err = {};
                                      if (vErrors === null)
                                        vErrors = [err];
                                      else
                                        vErrors.push(err);
                                      errors++;
                                    } else {
                                      var errs_5 = errors;
                                      if (typeof data2 !== "boolean") {
                                        var dataType5 = typeof data2;
                                        var coerced5 = void 0;
                                        if (coerced5 !== void 0)
                                          ;
                                        else if (data2 === "false" || data2 === 0 || data2 === null)
                                          coerced5 = false;
                                        else if (data2 === "true" || data2 === 1)
                                          coerced5 = true;
                                        else {
                                          var err = {};
                                          if (vErrors === null)
                                            vErrors = [err];
                                          else
                                            vErrors.push(err);
                                          errors++;
                                        }
                                        if (coerced5 !== void 0) {
                                          data2 = coerced5;
                                          data1["allowHTTP1"] = coerced5;
                                        }
                                      }
                                      var valid5 = errors === errs_5;
                                    }
                                    if (valid5) {
                                    }
                                  }
                                  if (errs__4 == errors) {
                                  }
                                }
                              } else {
                                var err = {};
                                if (vErrors === null)
                                  vErrors = [err];
                                else
                                  vErrors.push(err);
                                errors++;
                              }
                              if (errors === errs_4) {
                              }
                              var valid4 = errors === errs_4;
                              if (valid4 && prevValid3) {
                                valid3 = false;
                                passingSchemas3 = [passingSchemas3, 2];
                              } else {
                                if (valid4) {
                                  valid3 = prevValid3 = true;
                                  passingSchemas3 = 2;
                                }
                              }
                            }
                            if (!valid3) {
                              var err = {};
                              if (vErrors === null)
                                vErrors = [err];
                              else
                                vErrors.push(err);
                              errors++;
                            } else {
                              errors = errs__3;
                              if (vErrors !== null) {
                                if (errs__3)
                                  vErrors.length = errs__3;
                                else
                                  vErrors = null;
                              }
                            }
                            if (errors === errs_3) {
                            }
                            var valid3 = errors === errs_3;
                            if (valid3) {
                              var err = {};
                              if (vErrors === null)
                                vErrors = [err];
                              else
                                vErrors.push(err);
                              errors++;
                            } else {
                              errors = errs__2;
                              if (vErrors !== null) {
                                if (errs__2)
                                  vErrors.length = errs__2;
                                else
                                  vErrors = null;
                              }
                            }
                            if (errors === errs_2) {
                            }
                            var valid2 = errors === errs_2;
                            errors = errs__1;
                            if (vErrors !== null) {
                              if (errs__1)
                                vErrors.length = errs__1;
                              else
                                vErrors = null;
                            }
                            if (valid2) {
                              var errs_2 = errors;
                              customRule0.errors = null;
                              var errs__2 = errors;
                              var valid2;
                              valid2 = customRule0.call(self, validate2.schema.properties.https.then.setDefaultValue, data1, validate2.schema.properties.https.then, (dataPath || "") + ".https", data, "https", rootData);
                              if (data)
                                data1 = data["https"];
                              if (!valid2) {
                                validate2.errors = [{
                                  keyword: "setDefaultValue",
                                  dataPath: (dataPath || "") + ".https",
                                  schemaPath: "#/properties/https/then/setDefaultValue",
                                  params: {
                                    keyword: "setDefaultValue"
                                  },
                                  message: 'should pass "setDefaultValue" keyword validation'
                                }];
                                return false;
                              } else {
                              }
                              if (errors === errs_2) {
                              }
                              var valid2 = errors === errs_2;
                              valid1 = valid2;
                            }
                            if (!valid1) {
                              var err = {
                                keyword: "if",
                                dataPath: (dataPath || "") + ".https",
                                schemaPath: "#/properties/https/if",
                                params: {
                                  failingKeyword: "then"
                                },
                                message: 'should match "then" schema'
                              };
                              if (vErrors === null)
                                vErrors = [err];
                              else
                                vErrors.push(err);
                              errors++;
                              validate2.errors = vErrors;
                              return false;
                            } else {
                            }
                            if (errors === errs_1) {
                            }
                            var valid1 = errors === errs_1;
                          }
                          if (valid1) {
                            var data1 = data.ignoreTrailingSlash;
                            var errs_1 = errors;
                            if (typeof data1 !== "boolean") {
                              var dataType1 = typeof data1;
                              var coerced1 = void 0;
                              if (coerced1 !== void 0)
                                ;
                              else if (data1 === "false" || data1 === 0 || data1 === null)
                                coerced1 = false;
                              else if (data1 === "true" || data1 === 1)
                                coerced1 = true;
                              else {
                                validate2.errors = [{
                                  keyword: "type",
                                  dataPath: (dataPath || "") + ".ignoreTrailingSlash",
                                  schemaPath: "#/properties/ignoreTrailingSlash/type",
                                  params: {
                                    type: "boolean"
                                  },
                                  message: "should be boolean"
                                }];
                                return false;
                              }
                              if (coerced1 !== void 0) {
                                data1 = coerced1;
                                data["ignoreTrailingSlash"] = coerced1;
                              }
                            }
                            var valid1 = errors === errs_1;
                            if (valid1) {
                              var data1 = data.disableRequestLogging;
                              var errs_1 = errors;
                              if (typeof data1 !== "boolean") {
                                var dataType1 = typeof data1;
                                var coerced1 = void 0;
                                if (coerced1 !== void 0)
                                  ;
                                else if (data1 === "false" || data1 === 0 || data1 === null)
                                  coerced1 = false;
                                else if (data1 === "true" || data1 === 1)
                                  coerced1 = true;
                                else {
                                  validate2.errors = [{
                                    keyword: "type",
                                    dataPath: (dataPath || "") + ".disableRequestLogging",
                                    schemaPath: "#/properties/disableRequestLogging/type",
                                    params: {
                                      type: "boolean"
                                    },
                                    message: "should be boolean"
                                  }];
                                  return false;
                                }
                                if (coerced1 !== void 0) {
                                  data1 = coerced1;
                                  data["disableRequestLogging"] = coerced1;
                                }
                              }
                              var valid1 = errors === errs_1;
                              if (valid1) {
                                var data1 = data.jsonShorthand;
                                var errs_1 = errors;
                                if (typeof data1 !== "boolean") {
                                  var dataType1 = typeof data1;
                                  var coerced1 = void 0;
                                  if (coerced1 !== void 0)
                                    ;
                                  else if (data1 === "false" || data1 === 0 || data1 === null)
                                    coerced1 = false;
                                  else if (data1 === "true" || data1 === 1)
                                    coerced1 = true;
                                  else {
                                    validate2.errors = [{
                                      keyword: "type",
                                      dataPath: (dataPath || "") + ".jsonShorthand",
                                      schemaPath: "#/properties/jsonShorthand/type",
                                      params: {
                                        type: "boolean"
                                      },
                                      message: "should be boolean"
                                    }];
                                    return false;
                                  }
                                  if (coerced1 !== void 0) {
                                    data1 = coerced1;
                                    data["jsonShorthand"] = coerced1;
                                  }
                                }
                                var valid1 = errors === errs_1;
                                if (valid1) {
                                  var data1 = data.maxParamLength;
                                  var errs_1 = errors;
                                  if (typeof data1 !== "number" || data1 % 1 || data1 !== data1) {
                                    var dataType1 = typeof data1;
                                    var coerced1 = void 0;
                                    if (coerced1 !== void 0)
                                      ;
                                    else if (dataType1 == "boolean" || data1 === null || dataType1 == "string" && data1 && data1 == +data1 && !(data1 % 1))
                                      coerced1 = +data1;
                                    else {
                                      validate2.errors = [{
                                        keyword: "type",
                                        dataPath: (dataPath || "") + ".maxParamLength",
                                        schemaPath: "#/properties/maxParamLength/type",
                                        params: {
                                          type: "integer"
                                        },
                                        message: "should be integer"
                                      }];
                                      return false;
                                    }
                                    if (coerced1 !== void 0) {
                                      data1 = coerced1;
                                      data["maxParamLength"] = coerced1;
                                    }
                                  }
                                  var valid1 = errors === errs_1;
                                  if (valid1) {
                                    var data1 = data.onProtoPoisoning;
                                    var errs_1 = errors;
                                    if (typeof data1 !== "string") {
                                      var dataType1 = typeof data1;
                                      var coerced1 = void 0;
                                      if (coerced1 !== void 0)
                                        ;
                                      else if (dataType1 == "number" || dataType1 == "boolean")
                                        coerced1 = "" + data1;
                                      else if (data1 === null)
                                        coerced1 = "";
                                      else {
                                        validate2.errors = [{
                                          keyword: "type",
                                          dataPath: (dataPath || "") + ".onProtoPoisoning",
                                          schemaPath: "#/properties/onProtoPoisoning/type",
                                          params: {
                                            type: "string"
                                          },
                                          message: "should be string"
                                        }];
                                        return false;
                                      }
                                      if (coerced1 !== void 0) {
                                        data1 = coerced1;
                                        data["onProtoPoisoning"] = coerced1;
                                      }
                                    }
                                    var valid1 = errors === errs_1;
                                    if (valid1) {
                                      var data1 = data.onConstructorPoisoning;
                                      var errs_1 = errors;
                                      if (typeof data1 !== "string") {
                                        var dataType1 = typeof data1;
                                        var coerced1 = void 0;
                                        if (coerced1 !== void 0)
                                          ;
                                        else if (dataType1 == "number" || dataType1 == "boolean")
                                          coerced1 = "" + data1;
                                        else if (data1 === null)
                                          coerced1 = "";
                                        else {
                                          validate2.errors = [{
                                            keyword: "type",
                                            dataPath: (dataPath || "") + ".onConstructorPoisoning",
                                            schemaPath: "#/properties/onConstructorPoisoning/type",
                                            params: {
                                              type: "string"
                                            },
                                            message: "should be string"
                                          }];
                                          return false;
                                        }
                                        if (coerced1 !== void 0) {
                                          data1 = coerced1;
                                          data["onConstructorPoisoning"] = coerced1;
                                        }
                                      }
                                      var valid1 = errors === errs_1;
                                      if (valid1) {
                                        var data1 = data.pluginTimeout;
                                        var errs_1 = errors;
                                        if (typeof data1 !== "number" || data1 % 1 || data1 !== data1) {
                                          var dataType1 = typeof data1;
                                          var coerced1 = void 0;
                                          if (coerced1 !== void 0)
                                            ;
                                          else if (dataType1 == "boolean" || data1 === null || dataType1 == "string" && data1 && data1 == +data1 && !(data1 % 1))
                                            coerced1 = +data1;
                                          else {
                                            validate2.errors = [{
                                              keyword: "type",
                                              dataPath: (dataPath || "") + ".pluginTimeout",
                                              schemaPath: "#/properties/pluginTimeout/type",
                                              params: {
                                                type: "integer"
                                              },
                                              message: "should be integer"
                                            }];
                                            return false;
                                          }
                                          if (coerced1 !== void 0) {
                                            data1 = coerced1;
                                            data["pluginTimeout"] = coerced1;
                                          }
                                        }
                                        var valid1 = errors === errs_1;
                                        if (valid1) {
                                          var data1 = data.requestIdHeader;
                                          var errs_1 = errors;
                                          if (typeof data1 !== "string") {
                                            var dataType1 = typeof data1;
                                            var coerced1 = void 0;
                                            if (coerced1 !== void 0)
                                              ;
                                            else if (dataType1 == "number" || dataType1 == "boolean")
                                              coerced1 = "" + data1;
                                            else if (data1 === null)
                                              coerced1 = "";
                                            else {
                                              validate2.errors = [{
                                                keyword: "type",
                                                dataPath: (dataPath || "") + ".requestIdHeader",
                                                schemaPath: "#/properties/requestIdHeader/type",
                                                params: {
                                                  type: "string"
                                                },
                                                message: "should be string"
                                              }];
                                              return false;
                                            }
                                            if (coerced1 !== void 0) {
                                              data1 = coerced1;
                                              data["requestIdHeader"] = coerced1;
                                            }
                                          }
                                          var valid1 = errors === errs_1;
                                          if (valid1) {
                                            var data1 = data.requestIdLogLabel;
                                            var errs_1 = errors;
                                            if (typeof data1 !== "string") {
                                              var dataType1 = typeof data1;
                                              var coerced1 = void 0;
                                              if (coerced1 !== void 0)
                                                ;
                                              else if (dataType1 == "number" || dataType1 == "boolean")
                                                coerced1 = "" + data1;
                                              else if (data1 === null)
                                                coerced1 = "";
                                              else {
                                                validate2.errors = [{
                                                  keyword: "type",
                                                  dataPath: (dataPath || "") + ".requestIdLogLabel",
                                                  schemaPath: "#/properties/requestIdLogLabel/type",
                                                  params: {
                                                    type: "string"
                                                  },
                                                  message: "should be string"
                                                }];
                                                return false;
                                              }
                                              if (coerced1 !== void 0) {
                                                data1 = coerced1;
                                                data["requestIdLogLabel"] = coerced1;
                                              }
                                            }
                                            var valid1 = errors === errs_1;
                                            if (valid1) {
                                              var data1 = data.http2SessionTimeout;
                                              var errs_1 = errors;
                                              if (typeof data1 !== "number" || data1 % 1 || data1 !== data1) {
                                                var dataType1 = typeof data1;
                                                var coerced1 = void 0;
                                                if (coerced1 !== void 0)
                                                  ;
                                                else if (dataType1 == "boolean" || data1 === null || dataType1 == "string" && data1 && data1 == +data1 && !(data1 % 1))
                                                  coerced1 = +data1;
                                                else {
                                                  validate2.errors = [{
                                                    keyword: "type",
                                                    dataPath: (dataPath || "") + ".http2SessionTimeout",
                                                    schemaPath: "#/properties/http2SessionTimeout/type",
                                                    params: {
                                                      type: "integer"
                                                    },
                                                    message: "should be integer"
                                                  }];
                                                  return false;
                                                }
                                                if (coerced1 !== void 0) {
                                                  data1 = coerced1;
                                                  data["http2SessionTimeout"] = coerced1;
                                                }
                                              }
                                              var valid1 = errors === errs_1;
                                              if (valid1) {
                                                var data1 = data.versioning;
                                                if (data1 === void 0) {
                                                  valid1 = true;
                                                } else {
                                                  var errs_1 = errors;
                                                  if (data1 && typeof data1 === "object" && !Array.isArray(data1)) {
                                                    var missing1;
                                                    if (data1.storage === void 0 && (missing1 = ".storage") || data1.deriveVersion === void 0 && (missing1 = ".deriveVersion")) {
                                                      validate2.errors = [{
                                                        keyword: "required",
                                                        dataPath: (dataPath || "") + ".versioning",
                                                        schemaPath: "#/properties/versioning/required",
                                                        params: {
                                                          missingProperty: "" + missing1
                                                        },
                                                        message: "should have required property '" + missing1 + "'"
                                                      }];
                                                      return false;
                                                    } else {
                                                      var errs__1 = errors;
                                                      var valid2 = true;
                                                      for (var key1 in data1) {
                                                        var isAdditional1 = !(key1 == "storage" || key1 == "deriveVersion");
                                                        if (isAdditional1) {
                                                        }
                                                      }
                                                      if (valid2) {
                                                        if (valid2) {
                                                          if (valid2) {
                                                          }
                                                        }
                                                      }
                                                      if (errs__1 == errors) {
                                                      }
                                                    }
                                                  } else {
                                                    validate2.errors = [{
                                                      keyword: "type",
                                                      dataPath: (dataPath || "") + ".versioning",
                                                      schemaPath: "#/properties/versioning/type",
                                                      params: {
                                                        type: "object"
                                                      },
                                                      message: "should be object"
                                                    }];
                                                    return false;
                                                  }
                                                  if (errors === errs_1) {
                                                  }
                                                  var valid1 = errors === errs_1;
                                                }
                                                if (valid1) {
                                                  var data1 = data.constraints;
                                                  if (data1 === void 0) {
                                                    valid1 = true;
                                                  } else {
                                                    var errs_1 = errors;
                                                    if (data1 && typeof data1 === "object" && !Array.isArray(data1)) {
                                                      var errs__1 = errors;
                                                      var valid2 = true;
                                                      for (var key1 in data1) {
                                                        var data2 = data1[key1];
                                                        var errs_2 = errors;
                                                        if (data2 && typeof data2 === "object" && !Array.isArray(data2)) {
                                                          var missing2;
                                                          if (data2.storage === void 0 && (missing2 = ".storage") || data2.validate === void 0 && (missing2 = ".validate") || data2.deriveConstraint === void 0 && (missing2 = ".deriveConstraint")) {
                                                            validate2.errors = [{
                                                              keyword: "required",
                                                              dataPath: (dataPath || "") + ".constraints['" + key1 + "']",
                                                              schemaPath: "#/properties/constraints/additionalProperties/required",
                                                              params: {
                                                                missingProperty: "" + missing2
                                                              },
                                                              message: "should have required property '" + missing2 + "'"
                                                            }];
                                                            return false;
                                                          } else {
                                                            var errs__2 = errors;
                                                            var valid3 = true;
                                                            for (var key2 in data2) {
                                                              var isAdditional2 = !(key2 == "name" || key2 == "storage" || key2 == "validate" || key2 == "deriveConstraint");
                                                              if (isAdditional2) {
                                                              }
                                                            }
                                                            if (valid3) {
                                                              var data3 = data2.name;
                                                              if (data3 === void 0) {
                                                                valid3 = false;
                                                                validate2.errors = [{
                                                                  keyword: "required",
                                                                  dataPath: (dataPath || "") + ".constraints['" + key1 + "']",
                                                                  schemaPath: "#/properties/constraints/additionalProperties/required",
                                                                  params: {
                                                                    missingProperty: "name"
                                                                  },
                                                                  message: "should have required property 'name'"
                                                                }];
                                                                return false;
                                                              } else {
                                                                var errs_3 = errors;
                                                                if (typeof data3 !== "string") {
                                                                  var dataType3 = typeof data3;
                                                                  var coerced3 = void 0;
                                                                  if (coerced3 !== void 0)
                                                                    ;
                                                                  else if (dataType3 == "number" || dataType3 == "boolean")
                                                                    coerced3 = "" + data3;
                                                                  else if (data3 === null)
                                                                    coerced3 = "";
                                                                  else {
                                                                    validate2.errors = [{
                                                                      keyword: "type",
                                                                      dataPath: (dataPath || "") + ".constraints['" + key1 + "'].name",
                                                                      schemaPath: "#/properties/constraints/additionalProperties/properties/name/type",
                                                                      params: {
                                                                        type: "string"
                                                                      },
                                                                      message: "should be string"
                                                                    }];
                                                                    return false;
                                                                  }
                                                                  if (coerced3 !== void 0) {
                                                                    data3 = coerced3;
                                                                    data2["name"] = coerced3;
                                                                  }
                                                                }
                                                                var valid3 = errors === errs_3;
                                                              }
                                                              if (valid3) {
                                                                if (valid3) {
                                                                  if (valid3) {
                                                                    if (valid3) {
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                            if (errs__2 == errors) {
                                                            }
                                                          }
                                                        } else {
                                                          validate2.errors = [{
                                                            keyword: "type",
                                                            dataPath: (dataPath || "") + ".constraints['" + key1 + "']",
                                                            schemaPath: "#/properties/constraints/additionalProperties/type",
                                                            params: {
                                                              type: "object"
                                                            },
                                                            message: "should be object"
                                                          }];
                                                          return false;
                                                        }
                                                        if (errors === errs_2) {
                                                        }
                                                        var valid2 = errors === errs_2;
                                                        if (!valid2)
                                                          break;
                                                      }
                                                      if (valid2) {
                                                      }
                                                      if (errs__1 == errors) {
                                                      }
                                                    } else {
                                                      validate2.errors = [{
                                                        keyword: "type",
                                                        dataPath: (dataPath || "") + ".constraints",
                                                        schemaPath: "#/properties/constraints/type",
                                                        params: {
                                                          type: "object"
                                                        },
                                                        message: "should be object"
                                                      }];
                                                      return false;
                                                    }
                                                    if (errors === errs_1) {
                                                    }
                                                    var valid1 = errors === errs_1;
                                                  }
                                                  if (valid1) {
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (errs__0 == errors) {
          }
        } else {
          validate2.errors = [{
            keyword: "type",
            dataPath: (dataPath || "") + "",
            schemaPath: "#/type",
            params: {
              type: "object"
            },
            message: "should be object"
          }];
          return false;
        }
        if (errors === 0) {
        }
        validate2.errors = vErrors;
        return errors === 0;
      };
    }();
    validate.schema = {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "connectionTimeout": {
          "type": "integer",
          "default": 0
        },
        "keepAliveTimeout": {
          "type": "integer",
          "default": 5e3
        },
        "maxRequestsPerSocket": {
          "type": "integer",
          "default": 0,
          "nullable": true
        },
        "requestTimeout": {
          "type": "integer",
          "default": 0
        },
        "bodyLimit": {
          "type": "integer",
          "default": 1048576
        },
        "caseSensitive": {
          "type": "boolean",
          "default": true
        },
        "http2": {
          "type": "boolean"
        },
        "https": {
          "if": {
            "not": {
              "oneOf": [{
                "type": "boolean"
              }, {
                "type": "null"
              }, {
                "type": "object",
                "additionalProperties": false,
                "required": ["allowHTTP1"],
                "properties": {
                  "allowHTTP1": {
                    "type": "boolean"
                  }
                }
              }]
            }
          },
          "then": {
            "setDefaultValue": true
          }
        },
        "ignoreTrailingSlash": {
          "type": "boolean",
          "default": false
        },
        "disableRequestLogging": {
          "type": "boolean",
          "default": false
        },
        "jsonShorthand": {
          "type": "boolean",
          "default": true
        },
        "maxParamLength": {
          "type": "integer",
          "default": 100
        },
        "onProtoPoisoning": {
          "type": "string",
          "default": "error"
        },
        "onConstructorPoisoning": {
          "type": "string",
          "default": "error"
        },
        "pluginTimeout": {
          "type": "integer",
          "default": 1e4
        },
        "requestIdHeader": {
          "type": "string",
          "default": "request-id"
        },
        "requestIdLogLabel": {
          "type": "string",
          "default": "reqId"
        },
        "http2SessionTimeout": {
          "type": "integer",
          "default": 5e3
        },
        "versioning": {
          "type": "object",
          "additionalProperties": true,
          "required": ["storage", "deriveVersion"],
          "properties": {
            "storage": {},
            "deriveVersion": {}
          }
        },
        "constraints": {
          "type": "object",
          "additionalProperties": {
            "type": "object",
            "required": ["name", "storage", "validate", "deriveConstraint"],
            "additionalProperties": true,
            "properties": {
              "name": {
                "type": "string"
              },
              "storage": {},
              "validate": {},
              "deriveConstraint": {}
            }
          }
        }
      }
    };
    validate.errors = null;
    module2.exports = validate;
    function customRule0(schemaParamValue, validatedParamValue, validationSchemaObject, currentDataPath, validatedParamObject, validatedParam) {
      validatedParamObject[validatedParam] = schemaParamValue;
      return true;
    }
    module2.exports.defaultInitOptions = { "connectionTimeout": 0, "keepAliveTimeout": 5e3, "maxRequestsPerSocket": 0, "requestTimeout": 0, "bodyLimit": 1048576, "caseSensitive": true, "disableRequestLogging": false, "jsonShorthand": true, "ignoreTrailingSlash": false, "maxParamLength": 100, "onProtoPoisoning": "error", "onConstructorPoisoning": "error", "pluginTimeout": 1e4, "requestIdHeader": "request-id", "requestIdLogLabel": "reqId", "http2SessionTimeout": 5e3 };
  }
});

// packages/platform-fastify/node_modules/fastify/lib/initialConfigValidation.js
var require_initialConfigValidation = __commonJS({
  "packages/platform-fastify/node_modules/fastify/lib/initialConfigValidation.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var validate = require_configValidator();
    var deepClone = require_rfdc()({ circles: true, proto: false });
    var { FST_ERR_INIT_OPTS_INVALID } = require_errors();
    function validateInitialConfig(options) {
      const opts = deepClone(options);
      if (!validate(opts)) {
        const error = new FST_ERR_INIT_OPTS_INVALID(JSON.stringify(validate.errors.map((e) => e.message)));
        error.errors = validate.errors;
        throw error;
      }
      return deepFreezeObject(opts);
    }
    function deepFreezeObject(object) {
      const properties = Object.getOwnPropertyNames(object);
      for (const name of properties) {
        const value = object[name];
        if (ArrayBuffer.isView(value) && !(value instanceof DataView)) {
          continue;
        }
        object[name] = value && typeof value === "object" ? deepFreezeObject(value) : value;
      }
      return Object.freeze(object);
    }
    module2.exports = validateInitialConfig;
    module2.exports.defaultInitOptions = validate.defaultInitOptions;
    module2.exports.utils = { deepFreezeObject };
  }
});

// packages/platform-fastify/node_modules/fastify/lib/pluginOverride.js
var require_pluginOverride = __commonJS({
  "packages/platform-fastify/node_modules/fastify/lib/pluginOverride.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var {
      kAvvioBoot,
      kChildren,
      kRoutePrefix,
      kLogLevel,
      kLogSerializers,
      kHooks,
      kSchemaController,
      kContentTypeParser,
      kReply,
      kRequest,
      kFourOhFour,
      kPluginNameChain
    } = require_symbols();
    var Reply2 = require_reply();
    var Request2 = require_request();
    var SchemaController = require_schema_controller();
    var ContentTypeParser = require_contentTypeParser();
    var { buildHooks } = require_hooks();
    var pluginUtils = require_pluginUtils();
    module2.exports = function override(old, fn2, opts) {
      const shouldSkipOverride = pluginUtils.registerPlugin.call(old, fn2);
      if (shouldSkipOverride) {
        old[kPluginNameChain].push(pluginUtils.getDisplayName(fn2));
        return old;
      }
      const instance = Object.create(old);
      old[kChildren].push(instance);
      instance.ready = old[kAvvioBoot].bind(instance);
      instance[kChildren] = [];
      instance[kReply] = Reply2.buildReply(instance[kReply]);
      instance[kReply].prototype.server = instance;
      instance[kRequest] = Request2.buildRequest(instance[kRequest]);
      instance[kRequest].prototype.server = instance;
      instance[kContentTypeParser] = ContentTypeParser.helpers.buildContentTypeParser(instance[kContentTypeParser]);
      instance[kHooks] = buildHooks(instance[kHooks]);
      instance[kRoutePrefix] = buildRoutePrefix(instance[kRoutePrefix], opts.prefix);
      instance[kLogLevel] = opts.logLevel || instance[kLogLevel];
      instance[kSchemaController] = SchemaController.buildSchemaController(old[kSchemaController]);
      instance.getSchema = instance[kSchemaController].getSchema.bind(instance[kSchemaController]);
      instance.getSchemas = instance[kSchemaController].getSchemas.bind(instance[kSchemaController]);
      instance[pluginUtils.registeredPlugins] = Object.create(instance[pluginUtils.registeredPlugins]);
      instance[kPluginNameChain] = [pluginUtils.getPluginName(fn2) || pluginUtils.getFuncPreview(fn2)];
      if (instance[kLogSerializers] || opts.logSerializers) {
        instance[kLogSerializers] = Object.assign(Object.create(instance[kLogSerializers]), opts.logSerializers);
      }
      if (opts.prefix) {
        instance[kFourOhFour].arrange404(instance);
      }
      for (const hook of instance[kHooks].onRegister)
        hook.call(this, instance, opts);
      return instance;
    };
    function buildRoutePrefix(instancePrefix, pluginPrefix) {
      if (!pluginPrefix) {
        return instancePrefix;
      }
      if (instancePrefix.endsWith("/") && pluginPrefix[0] === "/") {
        pluginPrefix = pluginPrefix.slice(1);
      } else if (pluginPrefix[0] !== "/") {
        pluginPrefix = "/" + pluginPrefix;
      }
      return instancePrefix + pluginPrefix;
    }
  }
});

// packages/platform-fastify/node_modules/fastify/lib/noop-set.js
var require_noop_set = __commonJS({
  "packages/platform-fastify/node_modules/fastify/lib/noop-set.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = function noopSet() {
      return {
        [Symbol.iterator]: function* () {
        },
        add() {
        },
        delete() {
        },
        has() {
          return true;
        }
      };
    };
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/code.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.regexpCode = exports2.getEsmExportName = exports2.getProperty = exports2.safeStringify = exports2.stringify = exports2.strConcat = exports2.addCodeArg = exports2.str = exports2._ = exports2.nil = exports2._Code = exports2.Name = exports2.IDENTIFIER = exports2._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports2._CodeOrName = _CodeOrName;
    exports2.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s2) {
        super();
        if (!exports2.IDENTIFIER.test(s2))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s2;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports2.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a;
        return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s2, c) => `${s2}${c}`, "");
      }
      get names() {
        var _a;
        return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names, c) => {
          if (c instanceof Name)
            names[c.str] = (names[c.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports2._Code = _Code;
    exports2.nil = new _Code("");
    function _(strs, ...args2) {
      const code = [strs[0]];
      let i = 0;
      while (i < args2.length) {
        addCodeArg(code, args2[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports2._ = _;
    var plus = new _Code("+");
    function str(strs, ...args2) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args2.length) {
        expr.push(plus);
        addCodeArg(expr, args2[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports2.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    exports2.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports2.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports2.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports2.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports2.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports2.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports2.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports2.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports2.regexpCode = regexpCode;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/scope.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValueScope = exports2.ValueScopeName = exports2.Scope = exports2.varKinds = exports2.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState = exports2.UsedValueState || (exports2.UsedValueState = {}));
    exports2.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope2 = class {
      constructor({ prefixes, parent: parent2 } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent2;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a, _b;
        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports2.Scope = Scope2;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports2.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope2 {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = __spreadProps(__spreadValues({}, opts), { _n: opts.lines ? line : code_1.nil });
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s2 = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s2.length;
        s2[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              const def = this.opts.es5 ? exports2.varKinds.var : exports2.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports2.ValueScope = ValueScope;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/codegen/index.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.or = exports2.and = exports2.not = exports2.CodeGen = exports2.operators = exports2.varKinds = exports2.ValueScopeName = exports2.ValueScope = exports2.Scope = exports2.Name = exports2.regexpCode = exports2.stringify = exports2.getProperty = exports2.nil = exports2.strConcat = exports2.str = exports2._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports2, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports2, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports2, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports2, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports2, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports2, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports2, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports2.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : __spreadValues({}, this.lhs.names);
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names, constants))
            continue;
          subtractNames(names, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false)
            return e instanceof If ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new If(not(cond), e instanceof If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a;
        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args2, async) {
        super();
        this.name = name;
        this.args = args2;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a, _b;
        super.optimizeNodes();
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a, _b;
        super.optimizeNames(names, constants);
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = __spreadProps(__spreadValues({}, opts), { _n: opts.lines ? "\n" : "" });
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      name(prefix) {
        return this._scope.name(prefix);
      }
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant2) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant2)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports2.operators.ADD, rhs));
      }
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      else() {
        return this._elseNode(new Else());
      }
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      endFor() {
        return this._endBlockNode(For);
      }
      label(label) {
        return this._leafNode(new Label(label));
      }
      break(label) {
        return this._leafNode(new Break(label));
      }
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      func(name, args2 = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args2, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports2.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items.push(...c._items);
        else
          items.push(c);
        return items;
      }, []));
      function replaceName(n) {
        const c = constants[n.str];
        if (c === void 0 || names[n.str] !== 1)
          return n;
        delete names[n.str];
        return c;
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports2.not = not;
    var andCode = mappend(exports2.operators.AND);
    function and(...args2) {
      return args2.reduce(andCode);
    }
    exports2.and = and;
    var orCode = mappend(exports2.operators.OR);
    function or(...args2) {
      return args2.reduce(orCode);
    }
    exports2.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/util.js
var require_util3 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/util.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkStrictMode = exports2.getErrorPath = exports2.Type = exports2.useFunc = exports2.setEvaluated = exports2.evaluatedPropsToName = exports2.mergeEvaluated = exports2.eachItem = exports2.unescapeJsonPointer = exports2.escapeJsonPointer = exports2.escapeFragment = exports2.unescapeFragment = exports2.schemaRefOrVal = exports2.schemaHasRulesButRef = exports2.schemaHasRules = exports2.checkUnknownRules = exports2.alwaysValidSchema = exports2.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    exports2.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    exports2.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self.RULES.keywords;
      for (const key in schema) {
        if (!rules[key])
          checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    exports2.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules[key])
          return true;
      return false;
    }
    exports2.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports2.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports2.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports2.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports2.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports2.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports2.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    exports2.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports2.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : __spreadValues(__spreadValues({}, from), to),
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    exports2.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
    }
    exports2.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports2.useFunc = useFunc;
    var Type2;
    (function(Type3) {
      Type3[Type3["Num"] = 0] = "Num";
      Type3[Type3["Str"] = 1] = "Str";
    })(Type2 = exports2.Type || (exports2.Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber2 = dataPropType === Type2.Num;
        return jsPropertySyntax ? isNumber2 ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber2 ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports2.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    exports2.checkStrictMode = checkStrictMode;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/names.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      data: new codegen_1.Name("data"),
      valCxt: new codegen_1.Name("valCxt"),
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      vErrors: new codegen_1.Name("vErrors"),
      errors: new codegen_1.Name("errors"),
      this: new codegen_1.Name("this"),
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports2.default = names;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/errors.js
var require_errors2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/errors.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendErrors = exports2.resetErrorsCount = exports2.reportExtraError = exports2.reportError = exports2.keyword$DataError = exports2.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var names_1 = require_names();
    exports2.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports2.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports2.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports2.reportError = reportError;
    function reportExtraError(cxt, error = exports2.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports2.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports2.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports2.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message: message2 }, keyValues) {
      const { keyword, data, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message2 == "function" ? message2(cxt) : message2]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/validate/boolSchema.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.boolOrEmptySchema = exports2.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports2.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema } = it;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    exports2.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/rules.js
var require_rules2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/rules.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRules = exports2.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports2.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: __spreadProps(__spreadValues({}, groups), { integer: true, boolean: true, null: true }),
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports2.getRules = getRules;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/validate/applicability.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shouldUseRule = exports2.shouldUseGroup = exports2.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self }, type) {
      const group = self.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports2.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports2.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a;
      return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
    }
    exports2.shouldUseRule = shouldUseRule;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/validate/dataType.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reportTypeError = exports2.checkDataTypes = exports2.checkDataType = exports2.coerceAndCheckDataType = exports2.getJSONTypes = exports2.getSchemaTypes = exports2.DataType = void 0;
    var rules_1 = require_rules2();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors2();
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType = exports2.DataType || (exports2.DataType = {}));
    function getSchemaTypes(schema) {
      const types2 = getJSONTypes(schema.type);
      const hasNull = types2.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types2.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types2.push("null");
      }
      return types2;
    }
    exports2.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types2.every(rules_1.isJSONType))
        return types2;
      throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
    }
    exports2.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types2) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types2, opts.coerceTypes);
      const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types2[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types2, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types2, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports2.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types2, coerceTypes) {
      return coerceTypes ? types2.filter((t2) => COERCIBLE.has(t2) || coerceTypes === "array" && t2 === "array") : [];
    }
    function coerceData(it, types2, coerceTo) {
      const { gen, data, opts } = it;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types2, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t2 of coerceTo) {
        if (COERCIBLE.has(t2) || t2 === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t2);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t2) {
        switch (t2) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports2.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types2 = (0, util_1.toHash)(dataTypes);
      if (types2.array && types2.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types2.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types2.null;
        delete types2.array;
        delete types2.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types2.number)
        delete types2.integer;
      for (const t2 in types2)
        cond = (0, codegen_1.and)(cond, checkDataType(t2, data, strictNums, correct));
      return cond;
    }
    exports2.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports2.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/validate/defaults.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    function assignDefaults(it, ty) {
      const { properties, items } = it.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    exports2.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/code.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateUnion = exports2.validateArray = exports2.usePattern = exports2.callValidateCode = exports2.schemaProperties = exports2.allSchemaProperties = exports2.noPropertyInData = exports2.propertyInData = exports2.isOwnProperty = exports2.hasPropFunc = exports2.reportMissingProp = exports2.checkMissingProp = exports2.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var names_1 = require_names();
    var util_2 = require_util3();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports2.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports2.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports2.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports2.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports2.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports2.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports2.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports2.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports2.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args2 = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args2})` : (0, codegen_1._)`${func}(${args2})`;
    }
    exports2.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports2.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports2.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports2.validateUnion = validateUnion;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/validate/keyword.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateKeywordUsage = exports2.validSchemaType = exports2.funcKeywordCode = exports2.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors2();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports2.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a;
      const { gen, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
      const validateRef = useKeyword(gen, keyword, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a2;
        gen.if((0, codegen_1.not)((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors);
      }
    }
    exports2.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    exports2.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports2.validateKeywordUsage = validateKeywordUsage;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/validate/subschema.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendSubschemaMode = exports2.extendSubschemaData = exports2.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports2.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports2.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports2.extendSubschemaMode = extendSubschemaMode;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/json-schema-traverse/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var traverse = module2.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/resolve.js
var require_resolve2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/resolve.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSchemaRefs = exports2.resolveUrl = exports2.normalizeId = exports2._getFullPath = exports2.getFullPath = exports2.inlineRef = void 0;
    var util_1 = require_util3();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse2();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    exports2.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      const p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports2.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    exports2._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports2.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    exports2.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let baseId2 = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          baseId2 = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = baseId2;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(baseId2 ? _resolve(baseId2, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports2.getSchemaRefs = getSchemaRefs;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/validate/index.js
var require_validate2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/validate/index.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getData = exports2.KeywordCxt = exports2.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword2();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve2();
    var util_1 = require_util3();
    var errors_1 = require_errors2();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports2.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen, opts } = it;
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types2 = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types2);
      schemaKeywords(it, types2, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self } = it;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName, ValidationError: ValidationError2, opts } = it;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError2}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types2, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self } = it;
      const { RULES } = self;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types2);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it, group);
          if (types2.length === 1 && types2[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen, schema, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types2) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types2);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types2);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types2) {
      if (!types2.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types2;
        return;
      }
      types2.forEach((t2) => {
        if (!includesType(it.dataTypes, t2)) {
          strictTypesError(it, `type "${t2}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      it.dataTypes = it.dataTypes.filter((t2) => includesType(types2, t2));
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t2) => hasApplicableType(ts, t2))) {
            strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t2) {
      return ts.includes(t2) || t2 === "integer" && ts.includes("number");
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = __spreadProps(__spreadValues(__spreadValues({}, this.it), subschema), { items: void 0, props: void 0 });
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports2.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports2.getData = getData;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/runtime/validation_error.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ValidationError2 = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports2.default = ValidationError2;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/ref_error.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var resolve_1 = require_resolve2();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports2.default = MissingRefError;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/index.js
var require_compile2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/compile/index.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveSchema = exports2.getCompilingSchema = exports2.resolveRef = exports2.compileSchema = exports2.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve2();
    var util_1 = require_util3();
    var validate_1 = require_validate2();
    var SchemaEnv = class {
      constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports2.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
          validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports2.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports2.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports2.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    exports2.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a;
      if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/refs/data.json
var require_data3 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/refs/data.json"(exports2, module2) {
    module2.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/runtime/uri.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var uri = require_uri_all();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports2.default = uri;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/core.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
    var validate_1 = require_validate2();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules2();
    var compile_1 = require_compile2();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve2();
    var dataType_1 = require_dataType();
    var util_1 = require_util3();
    var $dataRefSchema = require_data3();
    var uri_1 = require_uri();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s2 = o.strict;
      const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s2) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s2) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s2) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s2) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s2) !== null && _p !== void 0 ? _p : false,
        code: o.code ? __spreadProps(__spreadValues({}, o.code), { optimize, regExp }) : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = __spreadValues(__spreadValues({}, opts), requiredOptions(opts));
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = __spreadValues({}, $dataRefSchema);
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            checkLoaded.call(this, e);
            await loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref) {
          const _schema = await _loadSchema.call(this, ref);
          if (!this.refs[ref])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref])
            this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
          const p = this._loading[ref];
          if (p)
            return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id = schema[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message2 = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message2);
          else
            throw new Error(message2);
        }
        return valid;
      }
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = __spreadProps(__spreadValues({}, def), {
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        });
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t2) => addRule.call(this, k, definition, t2)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      addFormat(name, format) {
        if (typeof format == "string")
          format = new RegExp(format);
        this.formats[name] = format;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    exports2.default = Ajv;
    Ajv.ValidationError = validation_error_1.default;
    Ajv.MissingRefError = ref_error_1.default;
    function checkOptions(checkOpts, options, msg, log3 = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log3](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format)
          this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = __spreadValues({}, this.opts);
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger2) {
      if (logger2 === false)
        return noLogs;
      if (logger2 === void 0)
        return console;
      if (logger2.log && logger2.warn && logger2.error)
        return logger2;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t2 }) => t2 === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: __spreadProps(__spreadValues({}, definition), {
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        })
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/core/id.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/core/ref.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.callRef = exports2.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile2();
    var util_1 = require_util3();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports2.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
        }
      }
    }
    exports2.callRef = callRef;
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/core/index.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref2();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports2.default = core;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/runtime/ucs2length.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports2.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var ucs2length_1 = require_ucs2length2();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/required.js
var require_required2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/required.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/runtime/equal.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports2.default = equal;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var equal_1 = require_equal();
    var error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t2) => t2 === "object" || t2 === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/const.js
var require_const2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/const.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/enum.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        const eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${eql}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${eql}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/validation/index.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf2();
    var limitLength_1 = require_limitLength2();
    var pattern_1 = require_pattern2();
    var limitProperties_1 = require_limitProperties2();
    var required_1 = require_required2();
    var limitItems_1 = require_limitItems2();
    var uniqueItems_1 = require_uniqueItems2();
    var const_1 = require_const2();
    var enum_1 = require_enum2();
    var validation = [
      limitNumber_1.default,
      multipleOf_1.default,
      limitLength_1.default,
      pattern_1.default,
      limitProperties_1.default,
      required_1.default,
      limitItems_1.default,
      uniqueItems_1.default,
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports2.default = validation;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports2.validateAdditionalItems = validateAdditionalItems;
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/items.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports2.validateTuple = validateTuple;
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var items_1 = require_items2();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateSchemaDeps = exports2.validatePropertyDeps = exports2.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var code_1 = require_code2();
    exports2.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports2.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports2.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {
          const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
          cxt.mergeValidEvaluated(schCxt, valid);
        }, () => gen.var(valid, true));
        cxt.ok(valid);
      }
    }
    exports2.validateSchemaDeps = validateSchemaDeps;
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util3();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var validate_1 = require_validate2();
    var code_1 = require_code2();
    var util_1 = require_util3();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var util_2 = require_util3();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/not.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util3();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util3();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/if.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util3();
    var error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      const schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util3();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/applicator/index.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items2();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains2();
    var dependencies_1 = require_dependencies2();
    var propertyNames_1 = require_propertyNames2();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties2();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not2();
    var anyOf_1 = require_anyOf2();
    var oneOf_1 = require_oneOf2();
    var allOf_1 = require_allOf2();
    var if_1 = require_if2();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports2.default = getApplicator;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/format/format.js
var require_format2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/format/format.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/format/index.js
var require_format3 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/format/index.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var format_1 = require_format2();
    var format = [format_1.default];
    exports2.default = format;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/metadata.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.contentVocabulary = exports2.metadataVocabulary = void 0;
    exports2.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports2.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/draft7.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation2();
    var applicator_1 = require_applicator();
    var format_1 = require_format3();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports2.default = draft7Vocabularies;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError = exports2.DiscrError || (exports2.DiscrError = {}));
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types2();
    var compile_1 = require_compile2();
    var util_1 = require_util3();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
            }
            const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_072 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports2, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/ajv.js
var require_ajv2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/node_modules/ajv/dist/ajv.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_072();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    module2.exports = exports2 = Ajv;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = Ajv;
    var validate_1 = require_validate2();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
  }
});

// packages/platform-fastify/node_modules/cookie/index.js
var require_cookie = __commonJS({
  "packages/platform-fastify/node_modules/cookie/index.js"(exports2) {
    "use strict";
    init_esm_shims();
    exports2.parse = parse;
    exports2.serialize = serialize;
    var decode = decodeURIComponent;
    var encode = encodeURIComponent;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse(str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options || {};
      var pairs = str.split(";");
      var dec = opt.decode || decode;
      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i];
        var index2 = pair.indexOf("=");
        if (index2 < 0) {
          continue;
        }
        var key = pair.substring(0, index2).trim();
        if (obj[key] == void 0) {
          var val = pair.substring(index2 + 1, pair.length).trim();
          if (val[0] === '"') {
            val = val.slice(1, -1);
          }
          obj[key] = tryDecode(val, dec);
        }
      }
      return obj;
    }
    function serialize(name, val, options) {
      var opt = options || {};
      var enc = opt.encode || encode;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name + "=" + value;
      if (opt.maxAge != null) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        if (typeof opt.expires.toUTCString !== "function") {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + opt.expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function tryDecode(str, decode2) {
      try {
        return decode2(str);
      } catch (e) {
        return str;
      }
    }
  }
});

// packages/platform-fastify/node_modules/light-my-request/lib/parseURL.js
var require_parseURL = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/lib/parseURL.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var { URL: URL2 } = __require("url");
    var BASE_URL = "http://localhost";
    module2.exports = function parseURL(url, query) {
      if ((typeof url === "string" || Object.prototype.toString.call(url) === "[object String]") && url.startsWith("//")) {
        url = BASE_URL + url;
      }
      const result = typeof url === "object" ? Object.assign(new URL2(BASE_URL), url) : new URL2(url, BASE_URL);
      const merged = Object.assign({}, url.query, query);
      for (const key in merged) {
        const value = merged[key];
        if (Array.isArray(value)) {
          result.searchParams.delete(key);
          for (const param of value) {
            result.searchParams.append(key, param);
          }
        } else {
          result.searchParams.set(key, value);
        }
      }
      return result;
    };
  }
});

// packages/platform-fastify/node_modules/light-my-request/lib/request.js
var require_request2 = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/lib/request.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var { Readable: Readable2 } = __require("stream");
    var util = __require("util");
    var cookie = require_cookie();
    var assert = __require("assert");
    var warning = require_process_warning()();
    var parseURL = require_parseURL();
    var { EventEmitter } = __require("events");
    warning.create("FastifyDeprecationLightMyRequest", "FST_LIGHTMYREQUEST_DEP01", 'You are accessing "request.connection", use "request.socket" instead.');
    function hostHeaderFromURL(parsedURL) {
      return parsedURL.port ? parsedURL.host : parsedURL.hostname + (parsedURL.protocol === "https:" ? ":443" : ":80");
    }
    var MockSocket = class extends EventEmitter {
      constructor(remoteAddress) {
        super();
        this.remoteAddress = remoteAddress;
      }
    };
    function Request2(options) {
      Readable2.call(this, {
        autoDestroy: false
      });
      const parsedURL = parseURL(options.url || options.path, options.query);
      this.url = parsedURL.pathname + parsedURL.search;
      this.httpVersion = "1.1";
      this.method = options.method ? options.method.toUpperCase() : "GET";
      this.headers = {};
      this.rawHeaders = [];
      const headers = options.headers || {};
      for (const field in headers) {
        const value = headers[field];
        assert(value !== void 0, 'invalid value "undefined" for header ' + field);
        this.headers[field.toLowerCase()] = "" + value;
      }
      this.headers["user-agent"] = this.headers["user-agent"] || "lightMyRequest";
      this.headers.host = this.headers.host || options.authority || hostHeaderFromURL(parsedURL);
      if (options.cookies) {
        const { cookies } = options;
        const cookieValues = Object.keys(cookies).map((key) => cookie.serialize(key, cookies[key]));
        if (this.headers.cookie) {
          cookieValues.unshift(this.headers.cookie);
        }
        this.headers.cookie = cookieValues.join("; ");
      }
      this.socket = new MockSocket(options.remoteAddress || "127.0.0.1");
      Object.defineProperty(this, "connection", {
        get() {
          warning.emit("FST_LIGHTMYREQUEST_DEP01");
          return this.socket;
        },
        configurable: true
      });
      let payload = options.payload || options.body || null;
      const payloadResume = payload && typeof payload.resume === "function";
      if (payload && typeof payload !== "string" && !payloadResume && !Buffer.isBuffer(payload)) {
        payload = JSON.stringify(payload);
        this.headers["content-type"] = this.headers["content-type"] || "application/json";
      }
      if (payload && !payloadResume && !this.headers.hasOwnProperty("content-length")) {
        this.headers["content-length"] = (Buffer.isBuffer(payload) ? payload.length : Buffer.byteLength(payload)).toString();
      }
      for (const header of Object.keys(this.headers)) {
        this.rawHeaders.push(header, this.headers[header]);
      }
      this._lightMyRequest = {
        payload,
        isDone: false,
        simulate: options.simulate || {}
      };
      return this;
    }
    util.inherits(Request2, Readable2);
    Request2.prototype.prepare = function(next) {
      const payload = this._lightMyRequest.payload;
      if (!payload || typeof payload.resume !== "function") {
        return next();
      }
      const chunks = [];
      payload.on("data", (chunk) => chunks.push(Buffer.from(chunk)));
      payload.on("end", () => {
        const payload2 = Buffer.concat(chunks);
        this.headers["content-length"] = this.headers["content-length"] || "" + payload2.length;
        this._lightMyRequest.payload = payload2;
        return next();
      });
      payload.resume();
    };
    Request2.prototype._read = function(size) {
      setImmediate(() => {
        if (this._lightMyRequest.isDone) {
          if (this._lightMyRequest.simulate.end !== false) {
            this.push(null);
          }
          return;
        }
        this._lightMyRequest.isDone = true;
        if (this._lightMyRequest.payload) {
          if (this._lightMyRequest.simulate.split) {
            this.push(this._lightMyRequest.payload.slice(0, 1));
            this.push(this._lightMyRequest.payload.slice(1));
          } else {
            this.push(this._lightMyRequest.payload);
          }
        }
        if (this._lightMyRequest.simulate.error) {
          this.emit("error", new Error("Simulated"));
        }
        if (this._lightMyRequest.simulate.close) {
          this.emit("close");
        }
        if (this._lightMyRequest.simulate.end !== false) {
          this.push(null);
        }
      });
    };
    Request2.prototype.destroy = function(error) {
      if (this.destroyed)
        return;
      this.destroyed = true;
      if (error) {
        this._error = true;
        process.nextTick(() => this.emit("error", error));
      }
      process.nextTick(() => this.emit("close"));
    };
    module2.exports = Request2;
  }
});

// packages/platform-fastify/node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
  "packages/platform-fastify/node_modules/set-cookie-parser/lib/set-cookie.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var defaultParseOptions = {
      decodeValues: true,
      map: false,
      silent: false
    };
    function isNonEmptyString(str) {
      return typeof str === "string" && !!str.trim();
    }
    function parseString(setCookieValue, options) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString);
      var nameValue = parts.shift().split("=");
      var name = nameValue.shift();
      var value = nameValue.join("=");
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      try {
        value = options.decodeValues ? decodeURIComponent(value) : value;
      } catch (e) {
        console.error("set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.", e);
      }
      var cookie = {
        name,
        value
      };
      parts.forEach(function(part) {
        var sides = part.split("=");
        var key = sides.shift().trimLeft().toLowerCase();
        var value2 = sides.join("=");
        if (key === "expires") {
          cookie.expires = new Date(value2);
        } else if (key === "max-age") {
          cookie.maxAge = parseInt(value2, 10);
        } else if (key === "secure") {
          cookie.secure = true;
        } else if (key === "httponly") {
          cookie.httpOnly = true;
        } else if (key === "samesite") {
          cookie.sameSite = value2;
        } else {
          cookie[key] = value2;
        }
      });
      return cookie;
    }
    function parse(input, options) {
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      if (!input) {
        if (!options.map) {
          return [];
        } else {
          return {};
        }
      }
      if (input.headers && input.headers["set-cookie"]) {
        input = input.headers["set-cookie"];
      } else if (input.headers) {
        var sch = input.headers[Object.keys(input.headers).find(function(key) {
          return key.toLowerCase() === "set-cookie";
        })];
        if (!sch && input.headers.cookie && !options.silent) {
          console.warn("Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.");
        }
        input = sch;
      }
      if (!Array.isArray(input)) {
        input = [input];
      }
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      if (!options.map) {
        return input.filter(isNonEmptyString).map(function(str) {
          return parseString(str, options);
        });
      } else {
        var cookies = {};
        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
          var cookie = parseString(str, options);
          cookies2[cookie.name] = cookie;
          return cookies2;
        }, cookies);
      }
    }
    function splitCookiesString(cookiesString) {
      if (Array.isArray(cookiesString)) {
        return cookiesString;
      }
      if (typeof cookiesString !== "string") {
        return [];
      }
      var cookiesStrings = [];
      var pos = 0;
      var start;
      var ch;
      var lastComma;
      var nextStart;
      var cookiesSeparatorFound;
      function skipWhitespace() {
        while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
          pos += 1;
        }
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
      }
      while (pos < cookiesString.length) {
        start = pos;
        cookiesSeparatorFound = false;
        while (skipWhitespace()) {
          ch = cookiesString.charAt(pos);
          if (ch === ",") {
            lastComma = pos;
            pos += 1;
            skipWhitespace();
            nextStart = pos;
            while (pos < cookiesString.length && notSpecialChar()) {
              pos += 1;
            }
            if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
              cookiesSeparatorFound = true;
              pos = nextStart;
              cookiesStrings.push(cookiesString.substring(start, lastComma));
              start = pos;
            } else {
              pos = lastComma + 1;
            }
          } else {
            pos += 1;
          }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
      }
      return cookiesStrings;
    }
    module2.exports = parse;
    module2.exports.parse = parse;
    module2.exports.parseString = parseString;
    module2.exports.splitCookiesString = splitCookiesString;
  }
});

// packages/platform-fastify/node_modules/light-my-request/lib/response.js
var require_response = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/lib/response.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var http = __require("http");
    var { Writable } = __require("stream");
    var util = __require("util");
    var setCookie = require_set_cookie();
    function Response(req, onEnd, reject2) {
      http.ServerResponse.call(this, {
        method: req.method,
        httpVersionMajor: 1,
        httpVersionMinor: 1
      });
      this._lightMyRequest = { headers: null, trailers: {}, payloadChunks: [] };
      this.setHeader("foo", "bar");
      this.removeHeader("foo");
      this.assignSocket(getNullSocket());
      this._promiseCallback = typeof reject2 === "function";
      let called = false;
      const onEndSuccess = (payload) => {
        called = true;
        if (this._promiseCallback) {
          return process.nextTick(() => onEnd(payload));
        }
        process.nextTick(() => onEnd(null, payload));
      };
      const onEndFailure = (err) => {
        if (called)
          return;
        called = true;
        if (this._promiseCallback) {
          return process.nextTick(() => reject2(err));
        }
        process.nextTick(() => onEnd(err, null));
      };
      this.once("finish", () => {
        const res = generatePayload(this);
        res.raw.req = req;
        onEndSuccess(res);
      });
      this.connection.once("error", onEndFailure);
      this.once("error", onEndFailure);
      this.once("close", onEndFailure);
    }
    util.inherits(Response, http.ServerResponse);
    Response.prototype.setTimeout = function(msecs, callback) {
      this.timeoutHandle = setTimeout(() => {
        this.emit("timeout");
      }, msecs);
      this.on("timeout", callback);
      return this;
    };
    Response.prototype.writeHead = function() {
      const result = http.ServerResponse.prototype.writeHead.apply(this, arguments);
      copyHeaders(this);
      return result;
    };
    Response.prototype.write = function(data, encoding, callback) {
      if (this.timeoutHandle) {
        clearTimeout(this.timeoutHandle);
      }
      http.ServerResponse.prototype.write.call(this, data, encoding, callback);
      this._lightMyRequest.payloadChunks.push(Buffer.from(data, encoding));
      return true;
    };
    Response.prototype.end = function(data, encoding, callback) {
      if (data) {
        this.write(data, encoding);
      }
      http.ServerResponse.prototype.end.call(this, callback);
      this.emit("finish");
      this.destroy();
    };
    Response.prototype.destroy = function(error) {
      if (this.destroyed)
        return;
      this.destroyed = true;
      if (error) {
        process.nextTick(() => this.emit("error", error));
      }
      process.nextTick(() => this.emit("close"));
    };
    Response.prototype.addTrailers = function(trailers) {
      for (const key in trailers) {
        this._lightMyRequest.trailers[key.toLowerCase().trim()] = trailers[key].toString().trim();
      }
    };
    function generatePayload(response) {
      if (response._lightMyRequest.headers === null) {
        copyHeaders(response);
      }
      const res = {
        raw: {
          res: response
        },
        headers: response._lightMyRequest.headers,
        statusCode: response.statusCode,
        statusMessage: response.statusMessage,
        trailers: {},
        get cookies() {
          return setCookie.parse(this);
        }
      };
      const rawBuffer = Buffer.concat(response._lightMyRequest.payloadChunks);
      res.rawPayload = rawBuffer;
      res.payload = rawBuffer.toString();
      res.body = res.payload;
      res.trailers = response._lightMyRequest.trailers;
      res.json = function parseJsonPayload() {
        if (res.headers["content-type"].indexOf("application/json") < 0) {
          throw new Error("The content-type of the response is not application/json");
        }
        return JSON.parse(this.payload);
      };
      return res;
    }
    function getNullSocket() {
      return new Writable({
        write(chunk, encoding, callback) {
          setImmediate(callback);
        }
      });
    }
    function copyHeaders(response) {
      response._lightMyRequest.headers = Object.assign({}, response.getHeaders());
      ["Date", "Connection", "Transfer-Encoding"].forEach((name) => {
        const regex = new RegExp("\\r\\n" + name + ": ([^\\r]*)\\r\\n");
        const field = response._header.match(regex);
        if (field) {
          response._lightMyRequest.headers[name.toLowerCase()] = field[1];
        }
      });
    }
    module2.exports = Response;
  }
});

// packages/platform-fastify/node_modules/light-my-request/index.js
var require_light_my_request = __commonJS({
  "packages/platform-fastify/node_modules/light-my-request/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var assert = __require("assert");
    var http = __require("http");
    var Ajv = require_ajv2();
    var Request2 = require_request2();
    var Response = require_response();
    var errorMessage = "The dispatch function has already been invoked";
    var urlSchema = {
      oneOf: [
        { type: "string" },
        {
          type: "object",
          properties: {
            protocol: { type: "string" },
            hostname: { type: "string" },
            pathname: { type: "string" }
          },
          additionalProperties: true,
          required: ["pathname"]
        }
      ]
    };
    var ajv = new Ajv();
    var schema = {
      type: "object",
      properties: {
        url: urlSchema,
        path: urlSchema,
        cookies: {
          type: "object",
          additionalProperties: true
        },
        headers: {
          type: "object",
          additionalProperties: true
        },
        query: {
          type: "object",
          additionalProperties: true
        },
        simulate: {
          type: "object",
          properties: {
            end: { type: "boolean" },
            split: { type: "boolean" },
            error: { type: "boolean" },
            close: { type: "boolean" }
          }
        },
        authority: { type: "string" },
        remoteAddress: { type: "string" },
        method: { type: "string", enum: http.METHODS.concat(http.METHODS.map(toLowerCase)) },
        validate: { type: "boolean" }
      },
      additionalProperties: true,
      oneOf: [
        { required: ["url"] },
        { required: ["path"] }
      ]
    };
    var optsValidator = ajv.compile(schema);
    function inject(dispatchFunc, options, callback) {
      if (typeof callback === "undefined") {
        return new Chain(dispatchFunc, options);
      } else {
        return doInject(dispatchFunc, options, callback);
      }
    }
    function makeRequest(dispatchFunc, server, req, res) {
      req.once("error", function(err) {
        if (this.destroyed)
          res.destroy(err);
      });
      req.once("close", function() {
        if (this.destroyed && !this._error)
          res.destroy();
      });
      return req.prepare(() => dispatchFunc.call(server, req, res));
    }
    function doInject(dispatchFunc, options, callback) {
      options = typeof options === "string" ? { url: options } : options;
      if (options.validate !== false) {
        assert(typeof dispatchFunc === "function", "dispatchFunc should be a function");
        const isOptionValid = optsValidator(options);
        if (!isOptionValid) {
          throw new Error(optsValidator.errors.map((e) => e.message));
        }
      }
      const server = options.server || {};
      if (typeof callback === "function") {
        const req = new Request2(options);
        const res = new Response(req, callback);
        return makeRequest(dispatchFunc, server, req, res);
      } else {
        return new Promise((resolve, reject2) => {
          const req = new Request2(options);
          const res = new Response(req, resolve, reject2);
          makeRequest(dispatchFunc, server, req, res);
        });
      }
    }
    function Chain(dispatch, option) {
      if (typeof option === "string") {
        this.option = { url: option };
      } else {
        this.option = Object.assign({}, option);
      }
      this.dispatch = dispatch;
      this._hasInvoked = false;
      this._promise = null;
      if (this.option.autoStart !== false) {
        process.nextTick(() => {
          if (!this._hasInvoked) {
            this.end();
          }
        });
      }
    }
    var httpMethods = [
      "delete",
      "get",
      "head",
      "options",
      "patch",
      "post",
      "put",
      "trace"
    ];
    httpMethods.forEach((method) => {
      Chain.prototype[method] = function(url) {
        if (this._hasInvoked === true || this._promise) {
          throw new Error(errorMessage);
        }
        this.option.url = url;
        this.option.method = method.toUpperCase();
        return this;
      };
    });
    var chainMethods = [
      "body",
      "cookies",
      "headers",
      "payload",
      "query"
    ];
    chainMethods.forEach((method) => {
      Chain.prototype[method] = function(value) {
        if (this._hasInvoked === true || this._promise) {
          throw new Error(errorMessage);
        }
        this.option[method] = value;
        return this;
      };
    });
    Chain.prototype.end = function(callback) {
      if (this._hasInvoked === true || this._promise) {
        throw new Error(errorMessage);
      }
      this._hasInvoked = true;
      if (typeof callback === "function") {
        doInject(this.dispatch, this.option, callback);
      } else {
        this._promise = doInject(this.dispatch, this.option);
        return this._promise;
      }
    };
    Object.getOwnPropertyNames(Promise.prototype).forEach((method) => {
      if (method === "constructor")
        return;
      Chain.prototype[method] = function(...args2) {
        if (!this._promise) {
          if (this._hasInvoked === true) {
            throw new Error(errorMessage);
          }
          this._hasInvoked = true;
          this._promise = doInject(this.dispatch, this.option);
        }
        return this._promise[method](...args2);
      };
    });
    function isInjection(obj) {
      return obj instanceof Request2 || obj instanceof Response;
    }
    function toLowerCase(m) {
      return m.toLowerCase();
    }
    module2.exports = inject;
    module2.exports.inject = inject;
    module2.exports.isInjection = isInjection;
  }
});

// packages/platform-fastify/node_modules/fastify/fastify.js
var require_fastify = __commonJS({
  "packages/platform-fastify/node_modules/fastify/fastify.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var VERSION = "3.27.4";
    var Avvio = require_boot();
    var http = __require("http");
    var querystring = __require("querystring");
    var lightMyRequest;
    var {
      kAvvioBoot,
      kChildren,
      kBodyLimit,
      kRoutePrefix,
      kLogLevel,
      kLogSerializers,
      kHooks,
      kSchemaController,
      kRequestAcceptVersion,
      kReplySerializerDefault,
      kContentTypeParser,
      kReply,
      kRequest,
      kFourOhFour,
      kState,
      kOptions,
      kPluginNameChain,
      kSchemaErrorFormatter,
      kErrorHandler,
      kKeepAliveConnections,
      kFourOhFourContext
    } = require_symbols();
    var { createServer } = require_server();
    var Reply2 = require_reply();
    var Request2 = require_request();
    var supportedMethods = ["DELETE", "GET", "HEAD", "PATCH", "POST", "PUT", "OPTIONS"];
    var decorator = require_decorate();
    var ContentTypeParser = require_contentTypeParser();
    var SchemaController = require_schema_controller();
    var { Hooks, hookRunnerApplication, supportedHooks } = require_hooks();
    var { createLogger } = require_logger();
    var pluginUtils = require_pluginUtils();
    var reqIdGenFactory = require_reqIdGenFactory();
    var { buildRouting, validateBodyLimitOption } = require_route();
    var build404 = require_fourOhFour();
    var getSecuredInitialConfig = require_initialConfigValidation();
    var override = require_pluginOverride();
    var warning = require_warnings();
    var noopSet = require_noop_set();
    var { defaultInitOptions } = getSecuredInitialConfig;
    var {
      FST_ERR_BAD_URL,
      FST_ERR_MISSING_MIDDLEWARE
    } = require_errors();
    var onBadUrlContext = {
      config: {},
      onSend: [],
      onError: [],
      [kFourOhFourContext]: null
    };
    function defaultBuildPrettyMeta(route) {
      const cleanKeys = {};
      const allowedProps = ["errorHandler", "logLevel", "logSerializers"];
      allowedProps.concat(supportedHooks).forEach((k) => {
        cleanKeys[k] = route.store[k];
      });
      return Object.assign({}, cleanKeys);
    }
    function defaultErrorHandler(error, request, reply) {
      if (reply.statusCode < 500) {
        reply.log.info({ res: reply, err: error }, error && error.message);
      } else {
        reply.log.error({ req: request, res: reply, err: error }, error && error.message);
      }
      reply.send(error);
    }
    function fastify2(options) {
      options = options || {};
      if (typeof options !== "object") {
        throw new TypeError("Options must be an object");
      }
      if (options.querystringParser && typeof options.querystringParser !== "function") {
        throw new Error(`querystringParser option should be a function, instead got '${typeof options.querystringParser}'`);
      }
      if (options.schemaController && options.schemaController.bucket && typeof options.schemaController.bucket !== "function") {
        throw new Error(`schemaController.bucket option should be a function, instead got '${typeof options.schemaController.bucket}'`);
      }
      validateBodyLimitOption(options.bodyLimit);
      const requestIdHeader = options.requestIdHeader || defaultInitOptions.requestIdHeader;
      const querystringParser = options.querystringParser || querystring.parse;
      const genReqId = options.genReqId || reqIdGenFactory();
      const requestIdLogLabel = options.requestIdLogLabel || "reqId";
      const bodyLimit = options.bodyLimit || defaultInitOptions.bodyLimit;
      const disableRequestLogging = options.disableRequestLogging || false;
      const exposeHeadRoutes = options.exposeHeadRoutes != null ? options.exposeHeadRoutes : false;
      const ajvOptions = Object.assign({
        customOptions: {},
        plugins: []
      }, options.ajv);
      const frameworkErrors = options.frameworkErrors;
      if (!ajvOptions.customOptions || Object.prototype.toString.call(ajvOptions.customOptions) !== "[object Object]") {
        throw new Error(`ajv.customOptions option should be an object, instead got '${typeof ajvOptions.customOptions}'`);
      }
      if (!ajvOptions.plugins || !Array.isArray(ajvOptions.plugins)) {
        throw new Error(`ajv.plugins option should be an array, instead got '${typeof ajvOptions.plugins}'`);
      }
      const { logger: logger2, hasLogger } = createLogger(options);
      options.connectionTimeout = options.connectionTimeout || defaultInitOptions.connectionTimeout;
      options.keepAliveTimeout = options.keepAliveTimeout || defaultInitOptions.keepAliveTimeout;
      options.forceCloseConnections = typeof options.forceCloseConnections === "boolean" ? options.forceCloseConnections : defaultInitOptions.forceCloseConnections;
      options.maxRequestsPerSocket = options.maxRequestsPerSocket || defaultInitOptions.maxRequestsPerSocket;
      options.requestTimeout = options.requestTimeout || defaultInitOptions.requestTimeout;
      options.logger = logger2;
      options.genReqId = genReqId;
      options.requestIdHeader = requestIdHeader;
      options.querystringParser = querystringParser;
      options.requestIdLogLabel = requestIdLogLabel;
      options.disableRequestLogging = disableRequestLogging;
      options.ajv = ajvOptions;
      options.clientErrorHandler = options.clientErrorHandler || defaultClientErrorHandler;
      options.exposeHeadRoutes = exposeHeadRoutes;
      const initialConfig = getSecuredInitialConfig(options);
      const keepAliveConnections = options.forceCloseConnections === true ? /* @__PURE__ */ new Set() : noopSet();
      let constraints = options.constraints;
      if (options.versioning) {
        warning.emit("FSTDEP009");
        constraints = __spreadProps(__spreadValues({}, constraints), {
          version: {
            name: "version",
            mustMatchWhenDerived: true,
            storage: options.versioning.storage,
            deriveConstraint: options.versioning.deriveVersion,
            validate(value) {
              if (typeof value !== "string") {
                throw new Error("Version constraint should be a string.");
              }
            }
          }
        });
      }
      const router = buildRouting({
        config: {
          defaultRoute,
          onBadUrl,
          constraints,
          ignoreTrailingSlash: options.ignoreTrailingSlash || defaultInitOptions.ignoreTrailingSlash,
          maxParamLength: options.maxParamLength || defaultInitOptions.maxParamLength,
          caseSensitive: options.caseSensitive,
          buildPrettyMeta: defaultBuildPrettyMeta
        },
        keepAliveConnections
      });
      const fourOhFour = build404(options);
      const httpHandler = wrapRouting(router.routing, options);
      options.http2SessionTimeout = initialConfig.http2SessionTimeout;
      const { server, listen } = createServer(options, httpHandler);
      const setupResponseListeners = Reply2.setupResponseListeners;
      const schemaController = SchemaController.buildSchemaController(null, options.schemaController);
      const fastify3 = {
        [kState]: {
          listening: false,
          closing: false,
          started: false
        },
        [kKeepAliveConnections]: keepAliveConnections,
        [kOptions]: options,
        [kChildren]: [],
        [kBodyLimit]: bodyLimit,
        [kRoutePrefix]: "",
        [kLogLevel]: "",
        [kLogSerializers]: null,
        [kHooks]: new Hooks(),
        [kSchemaController]: schemaController,
        [kSchemaErrorFormatter]: null,
        [kErrorHandler]: defaultErrorHandler,
        [kReplySerializerDefault]: null,
        [kContentTypeParser]: new ContentTypeParser(bodyLimit, options.onProtoPoisoning || defaultInitOptions.onProtoPoisoning, options.onConstructorPoisoning || defaultInitOptions.onConstructorPoisoning),
        [kReply]: Reply2.buildReply(Reply2),
        [kRequest]: Request2.buildRequest(Request2, options.trustProxy),
        [kFourOhFour]: fourOhFour,
        [pluginUtils.registeredPlugins]: [],
        [kPluginNameChain]: [],
        [kAvvioBoot]: null,
        routing: httpHandler,
        getDefaultRoute: router.getDefaultRoute.bind(router),
        setDefaultRoute: router.setDefaultRoute.bind(router),
        delete: function _delete(url, opts, handler) {
          return router.prepareRoute.call(this, "DELETE", url, opts, handler);
        },
        get: function _get(url, opts, handler) {
          return router.prepareRoute.call(this, "GET", url, opts, handler);
        },
        head: function _head(url, opts, handler) {
          return router.prepareRoute.call(this, "HEAD", url, opts, handler);
        },
        patch: function _patch(url, opts, handler) {
          return router.prepareRoute.call(this, "PATCH", url, opts, handler);
        },
        post: function _post(url, opts, handler) {
          return router.prepareRoute.call(this, "POST", url, opts, handler);
        },
        put: function _put(url, opts, handler) {
          return router.prepareRoute.call(this, "PUT", url, opts, handler);
        },
        options: function _options(url, opts, handler) {
          return router.prepareRoute.call(this, "OPTIONS", url, opts, handler);
        },
        all: function _all(url, opts, handler) {
          return router.prepareRoute.call(this, supportedMethods, url, opts, handler);
        },
        route: function _route(opts) {
          return router.route.call(this, opts);
        },
        log: logger2,
        addHook,
        addSchema,
        getSchema: schemaController.getSchema.bind(schemaController),
        getSchemas: schemaController.getSchemas.bind(schemaController),
        setValidatorCompiler,
        setSerializerCompiler,
        setSchemaController,
        setReplySerializer,
        setSchemaErrorFormatter,
        addContentTypeParser: ContentTypeParser.helpers.addContentTypeParser,
        hasContentTypeParser: ContentTypeParser.helpers.hasContentTypeParser,
        getDefaultJsonParser: ContentTypeParser.defaultParsers.getDefaultJsonParser,
        defaultTextParser: ContentTypeParser.defaultParsers.defaultTextParser,
        removeContentTypeParser: ContentTypeParser.helpers.removeContentTypeParser,
        removeAllContentTypeParsers: ContentTypeParser.helpers.removeAllContentTypeParsers,
        register: null,
        after: null,
        ready: null,
        onClose: null,
        close: null,
        printPlugins: null,
        listen,
        server,
        decorate: decorator.add,
        hasDecorator: decorator.exist,
        decorateReply: decorator.decorateReply,
        decorateRequest: decorator.decorateRequest,
        hasRequestDecorator: decorator.existRequest,
        hasReplyDecorator: decorator.existReply,
        inject,
        printRoutes,
        setNotFoundHandler,
        setErrorHandler,
        initialConfig
      };
      fastify3[kReply].prototype.server = fastify3;
      fastify3[kRequest].prototype.server = fastify3;
      Object.defineProperties(fastify3, {
        pluginName: {
          get() {
            if (this[kPluginNameChain].length > 1) {
              return this[kPluginNameChain].join(" -> ");
            }
            return this[kPluginNameChain][0];
          }
        },
        prefix: {
          get() {
            return this[kRoutePrefix];
          }
        },
        validatorCompiler: {
          get() {
            return this[kSchemaController].getValidatorCompiler();
          }
        },
        serializerCompiler: {
          get() {
            return this[kSchemaController].getSerializerCompiler();
          }
        },
        version: {
          get() {
            return VERSION;
          }
        },
        errorHandler: {
          get() {
            return this[kErrorHandler];
          }
        }
      });
      Object.setPrototypeOf(fastify3, { use });
      if (options.schemaErrorFormatter) {
        validateSchemaErrorFormatter(options.schemaErrorFormatter);
        fastify3[kSchemaErrorFormatter] = options.schemaErrorFormatter.bind(fastify3);
      }
      const avvio = Avvio(fastify3, {
        autostart: false,
        timeout: Number(options.pluginTimeout) || defaultInitOptions.pluginTimeout,
        expose: {
          use: "register"
        }
      });
      avvio.override = override;
      avvio.on("start", () => fastify3[kState].started = true);
      fastify3[kAvvioBoot] = fastify3.ready;
      fastify3.ready = ready;
      fastify3.printPlugins = avvio.prettyPrint.bind(avvio);
      avvio.once("preReady", () => {
        fastify3.onClose((instance, done) => {
          fastify3[kState].closing = true;
          router.closeRoutes();
          if (fastify3[kState].listening) {
            instance.server.close(done);
            for (const conn of fastify3[kKeepAliveConnections]) {
              conn.destroy();
              fastify3[kKeepAliveConnections].delete(conn);
            }
          } else {
            done(null);
          }
        });
      });
      fastify3.setNotFoundHandler();
      fourOhFour.arrange404(fastify3);
      router.setup(options, {
        avvio,
        fourOhFour,
        logger: logger2,
        hasLogger,
        setupResponseListeners,
        throwIfAlreadyStarted
      });
      server.on("clientError", options.clientErrorHandler.bind(fastify3));
      try {
        const dc = __require("diagnostics_channel");
        const initChannel = dc.channel("fastify.initialization");
        if (initChannel.hasSubscribers) {
          initChannel.publish({ fastify: fastify3 });
        }
      } catch (e) {
      }
      return fastify3;
      function throwIfAlreadyStarted(msg) {
        if (fastify3[kState].started)
          throw new Error(msg);
      }
      function inject(opts, cb) {
        if (lightMyRequest === void 0) {
          lightMyRequest = require_light_my_request();
        }
        if (fastify3[kState].started) {
          if (fastify3[kState].closing) {
            const error = new Error("Server is closed");
            if (cb) {
              cb(error);
              return;
            } else {
              return Promise.reject(error);
            }
          }
          return lightMyRequest(httpHandler, opts, cb);
        }
        if (cb) {
          this.ready((err) => {
            if (err)
              cb(err, null);
            else
              lightMyRequest(httpHandler, opts, cb);
          });
        } else {
          return lightMyRequest((req, res) => {
            this.ready(function(err) {
              if (err) {
                res.emit("error", err);
                return;
              }
              httpHandler(req, res);
            });
          }, opts);
        }
      }
      function ready(cb) {
        let resolveReady;
        let rejectReady;
        process.nextTick(runHooks);
        if (!cb) {
          return new Promise(function(resolve, reject2) {
            resolveReady = resolve;
            rejectReady = reject2;
          });
        }
        function runHooks() {
          fastify3[kAvvioBoot]((err, done) => {
            if (err || fastify3[kState].started) {
              manageErr(err);
            } else {
              hookRunnerApplication("onReady", fastify3[kAvvioBoot], fastify3, manageErr);
            }
            done();
          });
        }
        function manageErr(err) {
          if (cb) {
            if (err) {
              cb(err);
            } else {
              cb(void 0, fastify3);
            }
          } else {
            if (err) {
              return rejectReady(err);
            }
            resolveReady(fastify3);
          }
        }
      }
      function use() {
        throw new FST_ERR_MISSING_MIDDLEWARE();
      }
      function addHook(name, fn2) {
        throwIfAlreadyStarted('Cannot call "addHook" when fastify instance is already started!');
        if (name === "onSend" || name === "preSerialization" || name === "onError") {
          if (fn2.constructor.name === "AsyncFunction" && fn2.length === 4) {
            throw new Error("Async function has too many arguments. Async hooks should not use the 'done' argument.");
          }
        } else if (name === "onReady") {
          if (fn2.constructor.name === "AsyncFunction" && fn2.length !== 0) {
            throw new Error("Async function has too many arguments. Async hooks should not use the 'done' argument.");
          }
        } else if (name !== "preParsing") {
          if (fn2.constructor.name === "AsyncFunction" && fn2.length === 3) {
            throw new Error("Async function has too many arguments. Async hooks should not use the 'done' argument.");
          }
        }
        if (name === "onClose") {
          this.onClose(fn2);
        } else if (name === "onReady") {
          this[kHooks].add(name, fn2);
        } else {
          this.after((err, done) => {
            _addHook.call(this, name, fn2);
            done(err);
          });
        }
        return this;
        function _addHook(name2, fn3) {
          this[kHooks].add(name2, fn3);
          this[kChildren].forEach((child) => _addHook.call(child, name2, fn3));
        }
      }
      function addSchema(schema) {
        throwIfAlreadyStarted('Cannot call "addSchema" when fastify instance is already started!');
        this[kSchemaController].add(schema);
        this[kChildren].forEach((child) => child.addSchema(schema));
        return this;
      }
      function defaultClientErrorHandler(err, socket) {
        if (err.code === "ECONNRESET" || socket.destroyed) {
          return;
        }
        const body = JSON.stringify({
          error: http.STATUS_CODES["400"],
          message: "Client Error",
          statusCode: 400
        });
        this.log.trace({ err }, "client error");
        if (socket.writable && socket.bytesWritten === 0) {
          socket.write(`HTTP/1.1 400 Bad Request\r
Content-Length: ${body.length}\r
Content-Type: application/json\r
\r
${body}`);
        }
        socket.destroy(err);
      }
      function defaultRoute(req, res) {
        if (req.headers["accept-version"] !== void 0) {
          req.headers[kRequestAcceptVersion] = req.headers["accept-version"];
          req.headers["accept-version"] = void 0;
        }
        fourOhFour.router.lookup(req, res);
      }
      function onBadUrl(path2, req, res) {
        if (frameworkErrors) {
          const id = genReqId(req);
          const childLogger = logger2.child({ reqId: id });
          childLogger.info({ req }, "incoming request");
          const request = new Request2(id, null, req, null, childLogger, onBadUrlContext);
          const reply = new Reply2(res, request, childLogger);
          return frameworkErrors(new FST_ERR_BAD_URL(path2), request, reply);
        }
        const body = `{"error":"Bad Request","message":"'${path2}' is not a valid url component","statusCode":400}`;
        res.writeHead(400, {
          "Content-Type": "application/json",
          "Content-Length": body.length
        });
        res.end(body);
      }
      function setNotFoundHandler(opts, handler) {
        throwIfAlreadyStarted('Cannot call "setNotFoundHandler" when fastify instance is already started!');
        fourOhFour.setNotFoundHandler.call(this, opts, handler, avvio, router.routeHandler);
        return this;
      }
      function setValidatorCompiler(validatorCompiler) {
        throwIfAlreadyStarted('Cannot call "setValidatorCompiler" when fastify instance is already started!');
        this[kSchemaController].setValidatorCompiler(validatorCompiler);
        return this;
      }
      function setSchemaErrorFormatter(errorFormatter) {
        throwIfAlreadyStarted('Cannot call "setSchemaErrorFormatter" when fastify instance is already started!');
        validateSchemaErrorFormatter(errorFormatter);
        this[kSchemaErrorFormatter] = errorFormatter.bind(this);
        return this;
      }
      function setSerializerCompiler(serializerCompiler) {
        throwIfAlreadyStarted('Cannot call "setSerializerCompiler" when fastify instance is already started!');
        this[kSchemaController].setSerializerCompiler(serializerCompiler);
        return this;
      }
      function setSchemaController(schemaControllerOpts) {
        throwIfAlreadyStarted('Cannot call "setSchemaController" when fastify instance is already started!');
        const old = this[kSchemaController];
        const schemaController2 = SchemaController.buildSchemaController(old, Object.assign({}, old.opts, schemaControllerOpts));
        this[kSchemaController] = schemaController2;
        this.getSchema = schemaController2.getSchema.bind(schemaController2);
        this.getSchemas = schemaController2.getSchemas.bind(schemaController2);
        return this;
      }
      function setReplySerializer(replySerializer) {
        throwIfAlreadyStarted('Cannot call "setReplySerializer" when fastify instance is already started!');
        this[kReplySerializerDefault] = replySerializer;
        return this;
      }
      function setErrorHandler(func) {
        throwIfAlreadyStarted('Cannot call "setErrorHandler" when fastify instance is already started!');
        this[kErrorHandler] = func.bind(this);
        return this;
      }
      function printRoutes(opts = {}) {
        opts.includeMeta = opts.includeHooks ? opts.includeMeta ? supportedHooks.concat(opts.includeMeta) : supportedHooks : opts.includeMeta;
        return router.printRoutes(opts);
      }
    }
    function validateSchemaErrorFormatter(schemaErrorFormatter) {
      if (typeof schemaErrorFormatter !== "function") {
        throw new Error(`schemaErrorFormatter option should be a function, instead got ${typeof schemaErrorFormatter}`);
      } else if (schemaErrorFormatter.constructor.name === "AsyncFunction") {
        throw new Error("schemaErrorFormatter option should not be an async function");
      }
    }
    function wrapRouting(httpHandler, { rewriteUrl, logger: logger2 }) {
      if (!rewriteUrl) {
        return httpHandler;
      }
      return function preRouting(req, res) {
        const originalUrl = req.url;
        const url = rewriteUrl(req);
        if (originalUrl !== url) {
          logger2.debug({ originalUrl, url }, "rewrite url");
          if (typeof url === "string") {
            req.url = url;
          } else {
            req.destroy(new Error(`Rewrite url for "${req.url}" needs to be of type "string" but received "${typeof url}"`));
          }
        }
        httpHandler(req, res);
      };
    }
    module2.exports = fastify2;
    module2.exports.fastify = fastify2;
    module2.exports.default = fastify2;
  }
});

// node_modules/fastify-static/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "node_modules/fastify-static/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    init_esm_shims();
    module2.exports = __require("stream");
  }
});

// node_modules/fastify-static/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/fastify-static/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var _require = __require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = __require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s2) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) {
            ret += s2 + p.data;
          }
          return ret;
        }
      }, {
        key: "concat",
        value: function concat2(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread({}, options, {
            depth: 0,
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/fastify-static/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/fastify-static/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self, err) {
      emitErrorNT(self, err);
      emitCloseNT(self);
    }
    function emitCloseNT(self) {
      if (self._writableState && !self._writableState.emitClose)
        return;
      if (self._readableState && !self._readableState.emitClose)
        return;
      self.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self, err) {
      self.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/fastify-static/node_modules/readable-stream/errors.js
var require_errors3 = __commonJS({
  "node_modules/fastify-static/node_modules/readable-stream/errors.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var codes = {};
    function createErrorType(code, message2, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message2 === "string") {
          return message2;
        } else {
          return message2(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// node_modules/fastify-static/node_modules/readable-stream/lib/internal/streams/state.js
var require_state2 = __commonJS({
  "node_modules/fastify-static/node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var ERR_INVALID_OPT_VALUE = require_errors3().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    init_esm_shims();
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    init_esm_shims();
    try {
      util = __require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/util-deprecate/node.js
var require_node3 = __commonJS({
  "node_modules/util-deprecate/node.js"(exports2, module2) {
    init_esm_shims();
    module2.exports = __require("util").deprecate;
  }
});

// node_modules/fastify-static/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/fastify-static/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node3()
    };
    var Stream = require_stream();
    var Buffer2 = __require("buffer").Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state2();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors3().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/fastify-static/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/fastify-static/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var Readable2 = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits()(Duplex, Readable2);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable2.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self) {
      self.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/fastify-static/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/fastify-static/node_modules/safe-buffer/index.js"(exports2, module2) {
    init_esm_shims();
    var buffer = __require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/fastify-static/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/fastify-static/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    init_esm_shims();
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self.lastNeed = 0;
        return "\uFFFD";
      }
      if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self.lastNeed = 1;
          return "\uFFFD";
        }
        if (self.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/fastify-static/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/fastify-static/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var ERR_STREAM_PREMATURE_CLOSE = require_errors3().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once2(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) {
          args2[_key] = arguments[_key];
        }
        callback.apply(this, args2);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once2(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// node_modules/fastify-static/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/fastify-static/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject2) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject2);
        }, reject2);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject2) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject2(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject2) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject2(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject2) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject2;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject2 = iterator[kLastReject];
          if (reject2 !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject2(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/fastify-static/node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "node_modules/fastify-static/node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    function asyncGeneratorStep(gen, resolve, reject2, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject2(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn2) {
      return function() {
        var self = this, args2 = arguments;
        return new Promise(function(resolve, reject2) {
          var gen = fn2.apply(self, args2);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject2, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject2, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var ERR_INVALID_ARG_TYPE = require_errors3().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable2, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator])
        iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator])
        iterator = iterable[Symbol.iterator]();
      else
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable2(_objectSpread({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _ref = yield iterator.next(), value = _ref.value, done = _ref.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  }
});

// node_modules/fastify-static/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/fastify-static/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = Readable2;
    var Duplex;
    Readable2.ReadableState = ReadableState;
    var EE = __require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream();
    var Buffer2 = __require("buffer").Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = __require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state2();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors3().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable2, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn2) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn2);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn2);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn2);
      else
        emitter._events[event] = [fn2, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable2))
        return new Readable2(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable2.prototype, "destroyed", {
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable2.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable2.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        }
        return this;
      }
      var index2 = indexOf(state.pipes, dest);
      if (index2 === -1)
        return this;
      state.pipes.splice(index2, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn2) {
      var res = Stream.prototype.on.call(this, ev, fn2);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn2) {
      var res = Stream.prototype.removeListener.call(this, ev, fn2);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable2.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self) {
      var state = self._readableState;
      state.readableListening = self.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self.listenerCount("data") > 0) {
        self.resume();
      }
    }
    function nReadingNextTick(self) {
      debug("readable nexttick read 0");
      self.read(0);
    }
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
        ;
      }
    }
    Readable2.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable2.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableBuffer", {
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableFlowing", {
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable2._fromList = fromList;
    Object.defineProperty(Readable2.prototype, "readableLength", {
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable2.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from();
        }
        return from(Readable2, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/fastify-static/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/fastify-static/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = Transform;
    var _require$codes = require_errors3().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/fastify-static/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/fastify-static/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/fastify-static/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/fastify-static/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var eos;
    function once2(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors3().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once2(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn2) {
      fn2();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop;
      if (typeof streams[streams.length - 1] !== "function")
        return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// node_modules/fastify-static/node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/fastify-static/node_modules/readable-stream/readable.js"(exports2, module2) {
    init_esm_shims();
    var Stream = __require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
      exports2.finished = require_end_of_stream();
      exports2.pipeline = require_pipeline();
    }
  }
});

// node_modules/fs.realpath/old.js
var require_old = __commonJS({
  "node_modules/fs.realpath/old.js"(exports2) {
    init_esm_shims();
    var pathModule = __require("path");
    var isWindows = process.platform === "win32";
    var fs = __require("fs");
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb) {
      return typeof cb === "function" ? cb : rethrow();
    }
    var normalize = pathModule.normalize;
    if (isWindows) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    exports2.realpathSync = function realpathSync(p, cache) {
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs.lstatSync(base);
          knownHard[base] = true;
        }
      }
      while (pos < p.length) {
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          resolvedLink = cache[base];
        } else {
          var stat = fs.lstatSync(base);
          if (!stat.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache)
              cache[base] = base;
            continue;
          }
          var linkTarget = null;
          if (!isWindows) {
            var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs.statSync(base);
            linkTarget = fs.readlinkSync(base);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache)
            cache[base] = resolvedLink;
          if (!isWindows)
            seenLinks[id] = linkTarget;
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
      if (cache)
        cache[original] = p;
      return p;
    };
    exports2.realpath = function realpath(p, cache, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache);
        cache = null;
      }
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb.bind(null, null, cache[p]));
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs.lstat(base, function(err) {
            if (err)
              return cb(err);
            knownHard[base] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p.length) {
          if (cache)
            cache[original] = p;
          return cb(null, p);
        }
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          return gotResolvedLink(cache[base]);
        }
        return fs.lstat(base, gotStat);
      }
      function gotStat(err, stat) {
        if (err)
          return cb(err);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          return process.nextTick(LOOP);
        }
        if (!isWindows) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base);
          }
        }
        fs.stat(base, function(err2) {
          if (err2)
            return cb(err2);
          fs.readlink(base, function(err3, target) {
            if (!isWindows)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base2) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache)
          cache[base2] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
    };
  }
});

// node_modules/fs.realpath/index.js
var require_fs = __commonJS({
  "node_modules/fs.realpath/index.js"(exports2, module2) {
    init_esm_shims();
    module2.exports = realpath;
    realpath.realpath = realpath;
    realpath.sync = realpathSync;
    realpath.realpathSync = realpathSync;
    realpath.monkeypatch = monkeypatch;
    realpath.unmonkeypatch = unmonkeypatch;
    var fs = __require("fs");
    var origRealpath = fs.realpath;
    var origRealpathSync = fs.realpathSync;
    var version = process.version;
    var ok = /^v[0-5]\./.test(version);
    var old = require_old();
    function newError(er) {
      return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
    }
    function realpath(p, cache, cb) {
      if (ok) {
        return origRealpath(p, cache, cb);
      }
      if (typeof cache === "function") {
        cb = cache;
        cache = null;
      }
      origRealpath(p, cache, function(er, result) {
        if (newError(er)) {
          old.realpath(p, cache, cb);
        } else {
          cb(er, result);
        }
      });
    }
    function realpathSync(p, cache) {
      if (ok) {
        return origRealpathSync(p, cache);
      }
      try {
        return origRealpathSync(p, cache);
      } catch (er) {
        if (newError(er)) {
          return old.realpathSync(p, cache);
        } else {
          throw er;
        }
      }
    }
    function monkeypatch() {
      fs.realpath = realpath;
      fs.realpathSync = realpathSync;
    }
    function unmonkeypatch() {
      fs.realpath = origRealpath;
      fs.realpathSync = origRealpathSync;
    }
  }
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "node_modules/concat-map/index.js"(exports2, module2) {
    init_esm_shims();
    module2.exports = function(xs, fn2) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn2(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range2(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range2;
    function range2(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports2, module2) {
    init_esm_shims();
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/minimatch/minimatch.js"(exports2, module2) {
    init_esm_shims();
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path2 = { sep: "/" };
    try {
      path2 = __require("path");
    } catch (er) {
    }
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s2) {
      return s2.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter2;
    function filter2(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      a = a || {};
      b = b || {};
      var t2 = {};
      Object.keys(b).forEach(function(k) {
        t2[k] = b[k];
      });
      Object.keys(a).forEach(function(k) {
        t2[k] = a[k];
      });
      return t2;
    }
    minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return minimatch;
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig.minimatch(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return Minimatch;
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      if (pattern.trim() === "")
        return p === "";
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (path2.sep !== "/") {
        pattern = pattern.split(path2.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      if (this._made)
        return;
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = console.error;
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s2) {
        return s2.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s2, si, set2) {
        return s2.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s2) {
        return s2.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      if (typeof pattern === "undefined") {
        throw new TypeError("undefined pattern");
      }
      if (options.nobrace || !pattern.match(/\{.*\}/)) {
        return [pattern];
      }
      return expand(pattern);
    }
    Minimatch.prototype.parse = parse;
    var SUBPARSE = {};
    function parse(pattern, isSub) {
      if (pattern.length > 1024 * 64) {
        throw new TypeError("pattern is too long");
      }
      var options = this.options;
      if (!options.noglobstar && pattern === "**")
        return GLOBSTAR;
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/":
            return false;
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            if (inClass) {
              var cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                var sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t2 = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t2 + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case ".":
        case "[":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = match;
    function match(f, partial) {
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path2.sep !== "/") {
        f = f.split(path2.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    }
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug("matchOne", { "this": this, file, pattern });
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          if (options.nocase) {
            hit = f.toLowerCase() === p.toLowerCase();
          } else {
            hit = f === p;
          }
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        var emptyFileEnd = fi === fl - 1 && file[fi] === "";
        return emptyFileEnd;
      }
      throw new Error("wtf?");
    };
    function globUnescape(s2) {
      return s2.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s2) {
      return s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS({
  "node_modules/path-is-absolute/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    function posix(path2) {
      return path2.charAt(0) === "/";
    }
    function win32(path2) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result = splitDeviceRe.exec(path2);
      var device = result[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result[2] || isUnc);
    }
    module2.exports = process.platform === "win32" ? win32 : posix;
    module2.exports.posix = posix;
    module2.exports.win32 = win32;
  }
});

// node_modules/fastify-static/node_modules/glob/common.js
var require_common2 = __commonJS({
  "node_modules/fastify-static/node_modules/glob/common.js"(exports2) {
    init_esm_shims();
    exports2.setopts = setopts;
    exports2.ownProp = ownProp;
    exports2.makeAbs = makeAbs;
    exports2.finish = finish;
    exports2.mark = mark;
    exports2.isIgnored = isIgnored;
    exports2.childrenIgnored = childrenIgnored;
    function ownProp(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var fs = __require("fs");
    var path2 = __require("path");
    var minimatch = require_minimatch();
    var isAbsolute = require_path_is_absolute();
    var Minimatch = minimatch.Minimatch;
    function alphasort(a, b) {
      return a.localeCompare(b, "en");
    }
    function setupIgnores(self, options) {
      self.ignore = options.ignore || [];
      if (!Array.isArray(self.ignore))
        self.ignore = [self.ignore];
      if (self.ignore.length) {
        self.ignore = self.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher
      };
    }
    function setopts(self, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && pattern.indexOf("/") === -1) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self.silent = !!options.silent;
      self.pattern = pattern;
      self.strict = options.strict !== false;
      self.realpath = !!options.realpath;
      self.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
      self.follow = !!options.follow;
      self.dot = !!options.dot;
      self.mark = !!options.mark;
      self.nodir = !!options.nodir;
      if (self.nodir)
        self.mark = true;
      self.sync = !!options.sync;
      self.nounique = !!options.nounique;
      self.nonull = !!options.nonull;
      self.nosort = !!options.nosort;
      self.nocase = !!options.nocase;
      self.stat = !!options.stat;
      self.noprocess = !!options.noprocess;
      self.absolute = !!options.absolute;
      self.fs = options.fs || fs;
      self.maxLength = options.maxLength || Infinity;
      self.cache = options.cache || /* @__PURE__ */ Object.create(null);
      self.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
      self.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
      setupIgnores(self, options);
      self.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self.cwd = cwd;
      else {
        self.cwd = path2.resolve(options.cwd);
        self.changedCwd = self.cwd !== cwd;
      }
      self.root = options.root || path2.resolve(self.cwd, "/");
      self.root = path2.resolve(self.root);
      if (process.platform === "win32")
        self.root = self.root.replace(/\\/g, "/");
      self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd);
      if (process.platform === "win32")
        self.cwdAbs = self.cwdAbs.replace(/\\/g, "/");
      self.nomount = !!options.nomount;
      options.nonegate = true;
      options.nocomment = true;
      self.minimatch = new Minimatch(pattern, options);
      self.options = self.minimatch.options;
    }
    function finish(self) {
      var nou = self.nounique;
      var all = nou ? [] : /* @__PURE__ */ Object.create(null);
      for (var i = 0, l = self.matches.length; i < l; i++) {
        var matches = self.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self.nonull) {
            var literal = self.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self.nosort)
        all = all.sort(alphasort);
      if (self.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self._mark(all[i]);
        }
        if (self.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self.cache[e] || self.cache[makeAbs(self, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self, m2);
        });
      self.found = all;
    }
    function mark(self, p) {
      var abs = makeAbs(self, p);
      var c = self.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self, m);
          self.statCache[mabs] = self.statCache[abs];
          self.cache[mabs] = self.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self, f) {
      var abs = f;
      if (f.charAt(0) === "/") {
        abs = path2.join(self.root, f);
      } else if (isAbsolute(f) || f === "") {
        abs = f;
      } else if (self.changedCwd) {
        abs = path2.resolve(self.cwd, f);
      } else {
        abs = path2.resolve(f);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self, path3) {
      if (!self.ignore.length)
        return false;
      return self.ignore.some(function(item) {
        return item.matcher.match(path3) || !!(item.gmatcher && item.gmatcher.match(path3));
      });
    }
    function childrenIgnored(self, path3) {
      if (!self.ignore.length)
        return false;
      return self.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path3));
      });
    }
  }
});

// node_modules/fastify-static/node_modules/glob/sync.js
var require_sync = __commonJS({
  "node_modules/fastify-static/node_modules/glob/sync.js"(exports2, module2) {
    init_esm_shims();
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob().Glob;
    var util = __require("util");
    var path2 = __require("path");
    var assert = __require("assert");
    var isAbsolute = require_path_is_absolute();
    var common = require_common2();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options).found;
    }
    function GlobSync(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert(this instanceof GlobSync);
      if (this.realpath) {
        var self = this;
        this.matches.forEach(function(matchset, index2) {
          var set = self.matches[index2] = /* @__PURE__ */ Object.create(null);
          for (var p in matchset) {
            try {
              p = self._makeAbs(p);
              var real = rp.realpathSync(p, self.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index2, inGlobStar) {
      assert(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index2);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index2, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index2, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index2, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index2])
          this.matches[index2] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path2.join(this.root, e);
          }
          this._emitMatch(index2, e);
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index2, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index2, e) {
      if (isIgnored(this, e))
        return;
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute) {
        e = abs;
      }
      if (this.matches[index2][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index2][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, this.fs.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            throw error;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index2, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index2, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index2, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index2, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index2) {
      var exists = this._stat(prefix);
      if (!this.matches[index2])
        this.matches[index2] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path2.join(this.root, prefix);
        } else {
          prefix = path2.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index2, prefix);
    };
    GlobSync.prototype._stat = function(f) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat = this.statCache[abs];
      if (!stat) {
        var lstat;
        try {
          lstat = this.fs.lstatSync(abs);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat = this.fs.statSync(abs);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }
      this.statCache[abs] = stat;
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports2, module2) {
    init_esm_shims();
    module2.exports = wrappy;
    function wrappy(fn2, cb) {
      if (fn2 && cb)
        return wrappy(fn2)(cb);
      if (typeof fn2 !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn2).forEach(function(k) {
        wrapper[k] = fn2[k];
      });
      return wrapper;
      function wrapper() {
        var args2 = new Array(arguments.length);
        for (var i = 0; i < args2.length; i++) {
          args2[i] = arguments[i];
        }
        var ret = fn2.apply(this, args2);
        var cb2 = args2[args2.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports2, module2) {
    init_esm_shims();
    var wrappy = require_wrappy();
    module2.exports = wrappy(once2);
    module2.exports.strict = wrappy(onceStrict);
    once2.proto = once2(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once2(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once2(fn2) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn2.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn2) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn2.apply(this, arguments);
      };
      var name = fn2.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/inflight/inflight.js
var require_inflight = __commonJS({
  "node_modules/inflight/inflight.js"(exports2, module2) {
    init_esm_shims();
    var wrappy = require_wrappy();
    var reqs = /* @__PURE__ */ Object.create(null);
    var once2 = require_once();
    module2.exports = wrappy(inflight);
    function inflight(key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null;
      } else {
        reqs[key] = [cb];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once2(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args2 = slice(arguments);
        try {
          for (var i = 0; i < len; i++) {
            cbs[i].apply(null, args2);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args2);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice(args2) {
      var length = args2.length;
      var array = [];
      for (var i = 0; i < length; i++)
        array[i] = args2[i];
      return array;
    }
  }
});

// node_modules/fastify-static/node_modules/glob/glob.js
var require_glob = __commonJS({
  "node_modules/fastify-static/node_modules/glob/glob.js"(exports2, module2) {
    init_esm_shims();
    module2.exports = glob;
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var inherits = require_inherits();
    var EE = __require("events").EventEmitter;
    var path2 = __require("path");
    var assert = __require("assert");
    var isAbsolute = require_path_is_absolute();
    var globSync = require_sync();
    var common = require_common2();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util = __require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once2 = require_once();
    function glob(pattern, options, cb) {
      if (typeof options === "function")
        cb = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb);
    }
    glob.sync = globSync;
    var GlobSync = glob.GlobSync = globSync.GlobSync;
    glob.glob = glob;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    glob.hasMagic = function(pattern, options_) {
      var options = extend({}, options_);
      options.noprocess = true;
      var g = new Glob(pattern, options);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob.Glob = Glob;
    inherits(Glob, EE);
    function Glob(pattern, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once2(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync = true;
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync = false;
      function done() {
        --self._processing;
        if (self._processing <= 0) {
          if (sync) {
            process.nextTick(function() {
              self._finish();
            });
          } else {
            self._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self._finish();
      }
    };
    Glob.prototype._realpathSet = function(index2, cb) {
      var matchset = this.matches[index2];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index2] = /* @__PURE__ */ Object.create(null);
      found.forEach(function(p, i) {
        p = self._makeAbs(p);
        rp.realpath(p, self.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self.emit("error", er);
          if (--n === 0) {
            self.matches[index2] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index2, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index2, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index2, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index2, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs, remain, index2, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index2, inGlobStar, cb) {
      var self = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self._processReaddir2(prefix, read, abs, remain, index2, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index2, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index2])
          this.matches[index2] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path2.join(this.root, e);
          }
          this._emitMatch(index2, e);
        }
        return cb();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index2, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index2, e) {
      if (this.aborted)
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index2, e]);
        return;
      }
      var abs = isAbsolute(e) ? e : this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute)
        e = abs;
      if (this.matches[index2][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index2][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        self.fs.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self.cache[abs] = "FILE";
          cb();
        } else
          self._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self = this;
      self.fs.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self, abs, cb) {
      return function(er, entries) {
        if (er)
          self._readdirError(abs, er, cb);
        else
          self._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            this.emit("error", error);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index2, inGlobStar, cb) {
      var self = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self._processGlobStar2(prefix, read, abs, remain, index2, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index2, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index2, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index2, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index2, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index2, cb) {
      var self = this;
      this._stat(prefix, function(er, exists) {
        self._processSimple2(prefix, index2, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index2, er, exists, cb) {
      if (!this.matches[index2])
        this.matches[index2] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path2.join(this.root, prefix);
        } else {
          prefix = path2.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index2, prefix);
      cb();
    };
    Glob.prototype._stat = function(f, cb) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists;
      var stat = this.statCache[abs];
      if (stat !== void 0) {
        if (stat === false)
          return cb(null, stat);
        else {
          var type = stat.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat);
        }
      }
      var self = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        self.fs.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return self.fs.stat(abs, function(er2, stat2) {
            if (er2)
              self._stat2(f, abs, null, lstat, cb);
            else
              self._stat2(f, abs, er2, stat2, cb);
          });
        } else {
          self._stat2(f, abs, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f.slice(-1) === "/";
      this.statCache[abs] = stat;
      if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
        return cb(null, false, stat);
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return cb();
      return cb(null, c, stat);
    };
  }
});

// node_modules/depd/lib/compat/callsite-tostring.js
var require_callsite_tostring = __commonJS({
  "node_modules/depd/lib/compat/callsite-tostring.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = callSiteToString2;
    function callSiteFileLocation(callSite) {
      var fileName;
      var fileLocation = "";
      if (callSite.isNative()) {
        fileLocation = "native";
      } else if (callSite.isEval()) {
        fileName = callSite.getScriptNameOrSourceURL();
        if (!fileName) {
          fileLocation = callSite.getEvalOrigin();
        }
      } else {
        fileName = callSite.getFileName();
      }
      if (fileName) {
        fileLocation += fileName;
        var lineNumber = callSite.getLineNumber();
        if (lineNumber != null) {
          fileLocation += ":" + lineNumber;
          var columnNumber = callSite.getColumnNumber();
          if (columnNumber) {
            fileLocation += ":" + columnNumber;
          }
        }
      }
      return fileLocation || "unknown source";
    }
    function callSiteToString2(callSite) {
      var addSuffix = true;
      var fileLocation = callSiteFileLocation(callSite);
      var functionName = callSite.getFunctionName();
      var isConstructor = callSite.isConstructor();
      var isMethodCall = !(callSite.isToplevel() || isConstructor);
      var line = "";
      if (isMethodCall) {
        var methodName = callSite.getMethodName();
        var typeName = getConstructorName(callSite);
        if (functionName) {
          if (typeName && functionName.indexOf(typeName) !== 0) {
            line += typeName + ".";
          }
          line += functionName;
          if (methodName && functionName.lastIndexOf("." + methodName) !== functionName.length - methodName.length - 1) {
            line += " [as " + methodName + "]";
          }
        } else {
          line += typeName + "." + (methodName || "<anonymous>");
        }
      } else if (isConstructor) {
        line += "new " + (functionName || "<anonymous>");
      } else if (functionName) {
        line += functionName;
      } else {
        addSuffix = false;
        line += fileLocation;
      }
      if (addSuffix) {
        line += " (" + fileLocation + ")";
      }
      return line;
    }
    function getConstructorName(obj) {
      var receiver = obj.receiver;
      return receiver.constructor && receiver.constructor.name || null;
    }
  }
});

// node_modules/depd/lib/compat/event-listener-count.js
var require_event_listener_count = __commonJS({
  "node_modules/depd/lib/compat/event-listener-count.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = eventListenerCount2;
    function eventListenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    }
  }
});

// node_modules/depd/lib/compat/index.js
var require_compat = __commonJS({
  "node_modules/depd/lib/compat/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var EventEmitter = __require("events").EventEmitter;
    lazyProperty(module2.exports, "callSiteToString", function callSiteToString2() {
      var limit = Error.stackTraceLimit;
      var obj = {};
      var prep = Error.prepareStackTrace;
      function prepareObjectStackTrace2(obj2, stack3) {
        return stack3;
      }
      Error.prepareStackTrace = prepareObjectStackTrace2;
      Error.stackTraceLimit = 2;
      Error.captureStackTrace(obj);
      var stack2 = obj.stack.slice();
      Error.prepareStackTrace = prep;
      Error.stackTraceLimit = limit;
      return stack2[0].toString ? toString : require_callsite_tostring();
    });
    lazyProperty(module2.exports, "eventListenerCount", function eventListenerCount2() {
      return EventEmitter.listenerCount || require_event_listener_count();
    });
    function lazyProperty(obj, prop, getter) {
      function get() {
        var val = getter();
        Object.defineProperty(obj, prop, {
          configurable: true,
          enumerable: true,
          value: val
        });
        return val;
      }
      Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: true,
        get
      });
    }
    function toString(obj) {
      return obj.toString();
    }
  }
});

// node_modules/depd/index.js
var require_depd = __commonJS({
  "node_modules/depd/index.js"(exports, module) {
    init_esm_shims();
    var callSiteToString = require_compat().callSiteToString;
    var eventListenerCount = require_compat().eventListenerCount;
    var relative = __require("path").relative;
    module.exports = depd;
    var basePath = process.cwd();
    function containsNamespace(str, namespace) {
      var vals = str.split(/[ ,]+/);
      var ns = String(namespace).toLowerCase();
      for (var i = 0; i < vals.length; i++) {
        var val = vals[i];
        if (val && (val === "*" || val.toLowerCase() === ns)) {
          return true;
        }
      }
      return false;
    }
    function convertDataDescriptorToAccessor(obj, prop, message2) {
      var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
      var value = descriptor.value;
      descriptor.get = function getter() {
        return value;
      };
      if (descriptor.writable) {
        descriptor.set = function setter(val) {
          return value = val;
        };
      }
      delete descriptor.value;
      delete descriptor.writable;
      Object.defineProperty(obj, prop, descriptor);
      return descriptor;
    }
    function createArgumentsString(arity) {
      var str = "";
      for (var i = 0; i < arity; i++) {
        str += ", arg" + i;
      }
      return str.substr(2);
    }
    function createStackString(stack2) {
      var str = this.name + ": " + this.namespace;
      if (this.message) {
        str += " deprecated " + this.message;
      }
      for (var i = 0; i < stack2.length; i++) {
        str += "\n    at " + callSiteToString(stack2[i]);
      }
      return str;
    }
    function depd(namespace) {
      if (!namespace) {
        throw new TypeError("argument namespace is required");
      }
      var stack2 = getStack();
      var site2 = callSiteLocation(stack2[1]);
      var file = site2[0];
      function deprecate2(message2) {
        log.call(deprecate2, message2);
      }
      deprecate2._file = file;
      deprecate2._ignored = isignored(namespace);
      deprecate2._namespace = namespace;
      deprecate2._traced = istraced(namespace);
      deprecate2._warned = /* @__PURE__ */ Object.create(null);
      deprecate2.function = wrapfunction;
      deprecate2.property = wrapproperty;
      return deprecate2;
    }
    function isignored(namespace) {
      if (process.noDeprecation) {
        return true;
      }
      var str = process.env.NO_DEPRECATION || "";
      return containsNamespace(str, namespace);
    }
    function istraced(namespace) {
      if (process.traceDeprecation) {
        return true;
      }
      var str = process.env.TRACE_DEPRECATION || "";
      return containsNamespace(str, namespace);
    }
    function log(message2, site2) {
      var haslisteners = eventListenerCount(process, "deprecation") !== 0;
      if (!haslisteners && this._ignored) {
        return;
      }
      var caller;
      var callFile;
      var callSite;
      var depSite;
      var i = 0;
      var seen = false;
      var stack2 = getStack();
      var file = this._file;
      if (site2) {
        depSite = site2;
        callSite = callSiteLocation(stack2[1]);
        callSite.name = depSite.name;
        file = callSite[0];
      } else {
        i = 2;
        depSite = callSiteLocation(stack2[i]);
        callSite = depSite;
      }
      for (; i < stack2.length; i++) {
        caller = callSiteLocation(stack2[i]);
        callFile = caller[0];
        if (callFile === file) {
          seen = true;
        } else if (callFile === this._file) {
          file = this._file;
        } else if (seen) {
          break;
        }
      }
      var key = caller ? depSite.join(":") + "__" + caller.join(":") : void 0;
      if (key !== void 0 && key in this._warned) {
        return;
      }
      this._warned[key] = true;
      var msg = message2;
      if (!msg) {
        msg = callSite === depSite || !callSite.name ? defaultMessage(depSite) : defaultMessage(callSite);
      }
      if (haslisteners) {
        var err = DeprecationError(this._namespace, msg, stack2.slice(i));
        process.emit("deprecation", err);
        return;
      }
      var format = process.stderr.isTTY ? formatColor : formatPlain;
      var output = format.call(this, msg, caller, stack2.slice(i));
      process.stderr.write(output + "\n", "utf8");
    }
    function callSiteLocation(callSite) {
      var file = callSite.getFileName() || "<anonymous>";
      var line = callSite.getLineNumber();
      var colm = callSite.getColumnNumber();
      if (callSite.isEval()) {
        file = callSite.getEvalOrigin() + ", " + file;
      }
      var site2 = [file, line, colm];
      site2.callSite = callSite;
      site2.name = callSite.getFunctionName();
      return site2;
    }
    function defaultMessage(site2) {
      var callSite = site2.callSite;
      var funcName = site2.name;
      if (!funcName) {
        funcName = "<anonymous@" + formatLocation(site2) + ">";
      }
      var context = callSite.getThis();
      var typeName = context && callSite.getTypeName();
      if (typeName === "Object") {
        typeName = void 0;
      }
      if (typeName === "Function") {
        typeName = context.name || typeName;
      }
      return typeName && callSite.getMethodName() ? typeName + "." + funcName : funcName;
    }
    function formatPlain(msg, caller, stack2) {
      var timestamp = new Date().toUTCString();
      var formatted = timestamp + " " + this._namespace + " deprecated " + msg;
      if (this._traced) {
        for (var i = 0; i < stack2.length; i++) {
          formatted += "\n    at " + callSiteToString(stack2[i]);
        }
        return formatted;
      }
      if (caller) {
        formatted += " at " + formatLocation(caller);
      }
      return formatted;
    }
    function formatColor(msg, caller, stack2) {
      var formatted = "\x1B[36;1m" + this._namespace + "\x1B[22;39m \x1B[33;1mdeprecated\x1B[22;39m \x1B[0m" + msg + "\x1B[39m";
      if (this._traced) {
        for (var i = 0; i < stack2.length; i++) {
          formatted += "\n    \x1B[36mat " + callSiteToString(stack2[i]) + "\x1B[39m";
        }
        return formatted;
      }
      if (caller) {
        formatted += " \x1B[36m" + formatLocation(caller) + "\x1B[39m";
      }
      return formatted;
    }
    function formatLocation(callSite) {
      return relative(basePath, callSite[0]) + ":" + callSite[1] + ":" + callSite[2];
    }
    function getStack() {
      var limit = Error.stackTraceLimit;
      var obj = {};
      var prep = Error.prepareStackTrace;
      Error.prepareStackTrace = prepareObjectStackTrace;
      Error.stackTraceLimit = Math.max(10, limit);
      Error.captureStackTrace(obj);
      var stack2 = obj.stack.slice(1);
      Error.prepareStackTrace = prep;
      Error.stackTraceLimit = limit;
      return stack2;
    }
    function prepareObjectStackTrace(obj, stack2) {
      return stack2;
    }
    function wrapfunction(fn, message) {
      if (typeof fn !== "function") {
        throw new TypeError("argument fn must be a function");
      }
      var args = createArgumentsString(fn.length);
      var deprecate = this;
      var stack = getStack();
      var site = callSiteLocation(stack[1]);
      site.name = fn.name;
      var deprecatedfn = eval("(function (" + args + ') {\n"use strict"\nlog.call(deprecate, message, site)\nreturn fn.apply(this, arguments)\n})');
      return deprecatedfn;
    }
    function wrapproperty(obj, prop, message2) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new TypeError("argument obj must be object");
      }
      var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
      if (!descriptor) {
        throw new TypeError("must call property on owner object");
      }
      if (!descriptor.configurable) {
        throw new TypeError("property must be configurable");
      }
      var deprecate2 = this;
      var stack2 = getStack();
      var site2 = callSiteLocation(stack2[1]);
      site2.name = prop;
      if ("value" in descriptor) {
        descriptor = convertDataDescriptorToAccessor(obj, prop, message2);
      }
      var get = descriptor.get;
      var set = descriptor.set;
      if (typeof get === "function") {
        descriptor.get = function getter() {
          log.call(deprecate2, message2, site2);
          return get.apply(this, arguments);
        };
      }
      if (typeof set === "function") {
        descriptor.set = function setter() {
          log.call(deprecate2, message2, site2);
          return set.apply(this, arguments);
        };
      }
      Object.defineProperty(obj, prop, descriptor);
    }
    function DeprecationError(namespace, message2, stack2) {
      var error = new Error();
      var stackString;
      Object.defineProperty(error, "constructor", {
        value: DeprecationError
      });
      Object.defineProperty(error, "message", {
        configurable: true,
        enumerable: false,
        value: message2,
        writable: true
      });
      Object.defineProperty(error, "name", {
        enumerable: false,
        configurable: true,
        value: "DeprecationError",
        writable: true
      });
      Object.defineProperty(error, "namespace", {
        configurable: true,
        enumerable: false,
        value: namespace,
        writable: true
      });
      Object.defineProperty(error, "stack", {
        configurable: true,
        enumerable: false,
        get: function() {
          if (stackString !== void 0) {
            return stackString;
          }
          return stackString = createStackString.call(this, stack2);
        },
        set: function setter(val) {
          stackString = val;
        }
      });
      return error;
    }
  }
});

// node_modules/setprototypeof/index.js
var require_setprototypeof = __commonJS({
  "node_modules/setprototypeof/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
    function setProtoOf(obj, proto) {
      obj.__proto__ = proto;
      return obj;
    }
    function mixinProperties(obj, proto) {
      for (var prop in proto) {
        if (!obj.hasOwnProperty(prop)) {
          obj[prop] = proto[prop];
        }
      }
      return obj;
    }
  }
});

// node_modules/statuses/codes.json
var require_codes = __commonJS({
  "node_modules/statuses/codes.json"(exports2, module2) {
    module2.exports = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "306": "(Unused)",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Unordered Collection",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
  }
});

// node_modules/statuses/index.js
var require_statuses = __commonJS({
  "node_modules/statuses/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var codes = require_codes();
    module2.exports = status;
    status.STATUS_CODES = codes;
    status.codes = populateStatusesMap(status, codes);
    status.redirect = {
      300: true,
      301: true,
      302: true,
      303: true,
      305: true,
      307: true,
      308: true
    };
    status.empty = {
      204: true,
      205: true,
      304: true
    };
    status.retry = {
      502: true,
      503: true,
      504: true
    };
    function populateStatusesMap(statuses, codes2) {
      var arr = [];
      Object.keys(codes2).forEach(function forEachCode(code) {
        var message2 = codes2[code];
        var status2 = Number(code);
        statuses[status2] = message2;
        statuses[message2] = status2;
        statuses[message2.toLowerCase()] = status2;
        arr.push(status2);
      });
      return arr;
    }
    function status(code) {
      if (typeof code === "number") {
        if (!status[code])
          throw new Error("invalid status code: " + code);
        return code;
      }
      if (typeof code !== "string") {
        throw new TypeError("code must be a number or string");
      }
      var n = parseInt(code, 10);
      if (!isNaN(n)) {
        if (!status[n])
          throw new Error("invalid status code: " + n);
        return n;
      }
      n = status[code.toLowerCase()];
      if (!n)
        throw new Error('invalid status message: "' + code + '"');
      return n;
    }
  }
});

// node_modules/send/node_modules/inherits/inherits_browser.js
var require_inherits_browser2 = __commonJS({
  "node_modules/send/node_modules/inherits/inherits_browser.js"(exports2, module2) {
    init_esm_shims();
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/send/node_modules/inherits/inherits.js
var require_inherits2 = __commonJS({
  "node_modules/send/node_modules/inherits/inherits.js"(exports2, module2) {
    init_esm_shims();
    try {
      util = __require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser2();
    }
    var util;
  }
});

// node_modules/toidentifier/index.js
var require_toidentifier = __commonJS({
  "node_modules/toidentifier/index.js"(exports2, module2) {
    init_esm_shims();
    module2.exports = toIdentifier;
    function toIdentifier(str) {
      return str.split(" ").map(function(token) {
        return token.slice(0, 1).toUpperCase() + token.slice(1);
      }).join("").replace(/[^ _0-9a-z]/gi, "");
    }
  }
});

// node_modules/send/node_modules/http-errors/index.js
var require_http_errors = __commonJS({
  "node_modules/send/node_modules/http-errors/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var deprecate2 = require_depd()("http-errors");
    var setPrototypeOf = require_setprototypeof();
    var statuses = require_statuses();
    var inherits = require_inherits2();
    var toIdentifier = require_toidentifier();
    module2.exports = createError;
    module2.exports.HttpError = createHttpErrorConstructor();
    populateConstructorExports(module2.exports, statuses.codes, module2.exports.HttpError);
    function codeClass(status) {
      return Number(String(status).charAt(0) + "00");
    }
    function createError() {
      var err;
      var msg;
      var status = 500;
      var props = {};
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (arg instanceof Error) {
          err = arg;
          status = err.status || err.statusCode || status;
          continue;
        }
        switch (typeof arg) {
          case "string":
            msg = arg;
            break;
          case "number":
            status = arg;
            if (i !== 0) {
              deprecate2("non-first-argument status code; replace with createError(" + arg + ", ...)");
            }
            break;
          case "object":
            props = arg;
            break;
        }
      }
      if (typeof status === "number" && (status < 400 || status >= 600)) {
        deprecate2("non-error status code; use only 4xx or 5xx status codes");
      }
      if (typeof status !== "number" || !statuses[status] && (status < 400 || status >= 600)) {
        status = 500;
      }
      var HttpError = createError[status] || createError[codeClass(status)];
      if (!err) {
        err = HttpError ? new HttpError(msg) : new Error(msg || statuses[status]);
        Error.captureStackTrace(err, createError);
      }
      if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
        err.expose = status < 500;
        err.status = err.statusCode = status;
      }
      for (var key in props) {
        if (key !== "status" && key !== "statusCode") {
          err[key] = props[key];
        }
      }
      return err;
    }
    function createHttpErrorConstructor() {
      function HttpError() {
        throw new TypeError("cannot construct abstract class");
      }
      inherits(HttpError, Error);
      return HttpError;
    }
    function createClientErrorConstructor(HttpError, name, code) {
      var className = name.match(/Error$/) ? name : name + "Error";
      function ClientError(message2) {
        var msg = message2 != null ? message2 : statuses[code];
        var err = new Error(msg);
        Error.captureStackTrace(err, ClientError);
        setPrototypeOf(err, ClientError.prototype);
        Object.defineProperty(err, "message", {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });
        Object.defineProperty(err, "name", {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits(ClientError, HttpError);
      nameFunc(ClientError, className);
      ClientError.prototype.status = code;
      ClientError.prototype.statusCode = code;
      ClientError.prototype.expose = true;
      return ClientError;
    }
    function createServerErrorConstructor(HttpError, name, code) {
      var className = name.match(/Error$/) ? name : name + "Error";
      function ServerError(message2) {
        var msg = message2 != null ? message2 : statuses[code];
        var err = new Error(msg);
        Error.captureStackTrace(err, ServerError);
        setPrototypeOf(err, ServerError.prototype);
        Object.defineProperty(err, "message", {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });
        Object.defineProperty(err, "name", {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits(ServerError, HttpError);
      nameFunc(ServerError, className);
      ServerError.prototype.status = code;
      ServerError.prototype.statusCode = code;
      ServerError.prototype.expose = false;
      return ServerError;
    }
    function nameFunc(func, name) {
      var desc = Object.getOwnPropertyDescriptor(func, "name");
      if (desc && desc.configurable) {
        desc.value = name;
        Object.defineProperty(func, "name", desc);
      }
    }
    function populateConstructorExports(exports3, codes, HttpError) {
      codes.forEach(function forEachCode(code) {
        var CodeError;
        var name = toIdentifier(statuses[code]);
        switch (codeClass(code)) {
          case 400:
            CodeError = createClientErrorConstructor(HttpError, name, code);
            break;
          case 500:
            CodeError = createServerErrorConstructor(HttpError, name, code);
            break;
        }
        if (CodeError) {
          exports3[code] = CodeError;
          exports3[name] = CodeError;
        }
      });
      exports3["I'mateapot"] = deprecate2.function(exports3.ImATeapot, `"I'mateapot"; use "ImATeapot" instead`);
    }
  }
});

// node_modules/send/node_modules/debug/node_modules/ms/index.js
var require_ms2 = __commonJS({
  "node_modules/send/node_modules/debug/node_modules/ms/index.js"(exports2, module2) {
    init_esm_shims();
    var s2 = 1e3;
    var m = s2 * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s2) {
        return Math.round(ms / s2) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s2, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/send/node_modules/debug/src/debug.js
var require_debug2 = __commonJS({
  "node_modules/send/node_modules/debug/src/debug.js"(exports2, module2) {
    init_esm_shims();
    exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = require_ms2();
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports2.colors[Math.abs(hash) % exports2.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self = debug;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        var args2 = new Array(arguments.length);
        for (var i = 0; i < args2.length; i++) {
          args2[i] = arguments[i];
        }
        args2[0] = exports2.coerce(args2[0]);
        if (typeof args2[0] !== "string") {
          args2.unshift("%O");
        }
        var index2 = 0;
        args2[0] = args2[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%")
            return match;
          index2++;
          var formatter = exports2.formatters[format];
          if (typeof formatter === "function") {
            var val = args2[index2];
            match = formatter.call(self, val);
            args2.splice(index2, 1);
            index2--;
          }
          return match;
        });
        exports2.formatArgs.call(self, args2);
        var logFn = debug.log || exports2.log || console.log.bind(console);
        logFn.apply(self, args2);
      }
      debug.namespace = namespace;
      debug.enabled = exports2.enabled(namespace);
      debug.useColors = exports2.useColors();
      debug.color = selectColor(namespace);
      if (typeof exports2.init === "function") {
        exports2.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports2.skips.length; i < len; i++) {
        if (exports2.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports2.names.length; i < len; i++) {
        if (exports2.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// node_modules/send/node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/send/node_modules/debug/src/browser.js"(exports2, module2) {
    init_esm_shims();
    exports2 = module2.exports = require_debug2();
    exports2.log = log3;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
    exports2.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args2) {
      var useColors2 = this.useColors;
      args2[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args2[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args2.splice(1, 0, c, "color: inherit");
      var index2 = 0;
      var lastC = 0;
      args2[0].replace(/%[a-zA-Z%]/g, function(match) {
        if (match === "%%")
          return;
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args2.splice(lastC, 0, c);
    }
    function log3() {
      return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (namespaces == null) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports2.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// node_modules/send/node_modules/debug/src/node.js
var require_node4 = __commonJS({
  "node_modules/send/node_modules/debug/src/node.js"(exports2, module2) {
    init_esm_shims();
    var tty = __require("tty");
    var util = __require("util");
    exports2 = module2.exports = require_debug2();
    exports2.init = init;
    exports2.log = log3;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.colors = [6, 2, 3, 4, 5, 1];
    exports2.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val))
        val = true;
      else if (/^(no|off|false|disabled)$/i.test(val))
        val = false;
      else if (val === "null")
        val = null;
      else
        val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (fd !== 1 && fd !== 2) {
      util.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(fd);
    }
    exports2.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports2.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
    function formatArgs(args2) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var prefix = "  \x1B[3" + c + ";1m" + name + " \x1B[0m";
        args2[0] = prefix + args2[0].split("\n").join("\n" + prefix);
        args2.push("\x1B[3" + c + "m+" + exports2.humanize(this.diff) + "\x1B[0m");
      } else {
        args2[0] = new Date().toUTCString() + " " + name + " " + args2[0];
      }
    }
    function log3() {
      return stream.write(util.format.apply(util, arguments) + "\n");
    }
    function save(namespaces) {
      if (namespaces == null) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream2;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream2 = new tty.WriteStream(fd2);
          stream2._type = "tty";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        case "FILE":
          var fs = __require("fs");
          stream2 = new fs.SyncWriteStream(fd2, { autoClose: false });
          stream2._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net = __require("net");
          stream2 = new net.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream2.readable = false;
          stream2.read = null;
          stream2._type = "pipe";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream2.fd = fd2;
      stream2._isStdio = true;
      return stream2;
    }
    function init(debug) {
      debug.inspectOpts = {};
      var keys = Object.keys(exports2.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    exports2.enable(load());
  }
});

// node_modules/send/node_modules/debug/src/index.js
var require_src2 = __commonJS({
  "node_modules/send/node_modules/debug/src/index.js"(exports2, module2) {
    init_esm_shims();
    if (typeof process !== "undefined" && process.type === "renderer") {
      module2.exports = require_browser2();
    } else {
      module2.exports = require_node4();
    }
  }
});

// node_modules/destroy/index.js
var require_destroy2 = __commonJS({
  "node_modules/destroy/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var ReadStream = __require("fs").ReadStream;
    var Stream = __require("stream");
    module2.exports = destroy;
    function destroy(stream) {
      if (stream instanceof ReadStream) {
        return destroyReadStream(stream);
      }
      if (!(stream instanceof Stream)) {
        return stream;
      }
      if (typeof stream.destroy === "function") {
        stream.destroy();
      }
      return stream;
    }
    function destroyReadStream(stream) {
      stream.destroy();
      if (typeof stream.close === "function") {
        stream.on("open", onOpenClose);
      }
      return stream;
    }
    function onOpenClose() {
      if (typeof this.fd === "number") {
        this.close();
      }
    }
  }
});

// node_modules/encodeurl/index.js
var require_encodeurl = __commonJS({
  "node_modules/encodeurl/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = encodeUrl;
    var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
    var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
    var UNMATCHED_SURROGATE_PAIR_REPLACE = "$1\uFFFD$2";
    function encodeUrl(url) {
      return String(url).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
    }
  }
});

// node_modules/escape-html/index.js
var require_escape_html = __commonJS({
  "node_modules/escape-html/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var matchHtmlRegExp = /["'&<>]/;
    module2.exports = escapeHtml;
    function escapeHtml(string) {
      var str = "" + string;
      var match = matchHtmlRegExp.exec(str);
      if (!match) {
        return str;
      }
      var escape;
      var html = "";
      var index2 = 0;
      var lastIndex = 0;
      for (index2 = match.index; index2 < str.length; index2++) {
        switch (str.charCodeAt(index2)) {
          case 34:
            escape = "&quot;";
            break;
          case 38:
            escape = "&amp;";
            break;
          case 39:
            escape = "&#39;";
            break;
          case 60:
            escape = "&lt;";
            break;
          case 62:
            escape = "&gt;";
            break;
          default:
            continue;
        }
        if (lastIndex !== index2) {
          html += str.substring(lastIndex, index2);
        }
        lastIndex = index2 + 1;
        html += escape;
      }
      return lastIndex !== index2 ? html + str.substring(lastIndex, index2) : html;
    }
  }
});

// node_modules/etag/index.js
var require_etag = __commonJS({
  "node_modules/etag/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = etag;
    var crypto = __require("crypto");
    var Stats = __require("fs").Stats;
    var toString = Object.prototype.toString;
    function entitytag(entity) {
      if (entity.length === 0) {
        return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
      }
      var hash = crypto.createHash("sha1").update(entity, "utf8").digest("base64").substring(0, 27);
      var len = typeof entity === "string" ? Buffer.byteLength(entity, "utf8") : entity.length;
      return '"' + len.toString(16) + "-" + hash + '"';
    }
    function etag(entity, options) {
      if (entity == null) {
        throw new TypeError("argument entity is required");
      }
      var isStats = isstats(entity);
      var weak = options && typeof options.weak === "boolean" ? options.weak : isStats;
      if (!isStats && typeof entity !== "string" && !Buffer.isBuffer(entity)) {
        throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
      }
      var tag = isStats ? stattag(entity) : entitytag(entity);
      return weak ? "W/" + tag : tag;
    }
    function isstats(obj) {
      if (typeof Stats === "function" && obj instanceof Stats) {
        return true;
      }
      return obj && typeof obj === "object" && "ctime" in obj && toString.call(obj.ctime) === "[object Date]" && "mtime" in obj && toString.call(obj.mtime) === "[object Date]" && "ino" in obj && typeof obj.ino === "number" && "size" in obj && typeof obj.size === "number";
    }
    function stattag(stat) {
      var mtime = stat.mtime.getTime().toString(16);
      var size = stat.size.toString(16);
      return '"' + size + "-" + mtime + '"';
    }
  }
});

// node_modules/fresh/index.js
var require_fresh = __commonJS({
  "node_modules/fresh/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
    module2.exports = fresh;
    function fresh(reqHeaders, resHeaders) {
      var modifiedSince = reqHeaders["if-modified-since"];
      var noneMatch = reqHeaders["if-none-match"];
      if (!modifiedSince && !noneMatch) {
        return false;
      }
      var cacheControl = reqHeaders["cache-control"];
      if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
        return false;
      }
      if (noneMatch && noneMatch !== "*") {
        var etag = resHeaders["etag"];
        if (!etag) {
          return false;
        }
        var etagStale = true;
        var matches = parseTokenList(noneMatch);
        for (var i = 0; i < matches.length; i++) {
          var match = matches[i];
          if (match === etag || match === "W/" + etag || "W/" + match === etag) {
            etagStale = false;
            break;
          }
        }
        if (etagStale) {
          return false;
        }
      }
      if (modifiedSince) {
        var lastModified = resHeaders["last-modified"];
        var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince));
        if (modifiedStale) {
          return false;
        }
      }
      return true;
    }
    function parseHttpDate(date) {
      var timestamp = date && Date.parse(date);
      return typeof timestamp === "number" ? timestamp : NaN;
    }
    function parseTokenList(str) {
      var end = 0;
      var list = [];
      var start = 0;
      for (var i = 0, len = str.length; i < len; i++) {
        switch (str.charCodeAt(i)) {
          case 32:
            if (start === end) {
              start = end = i + 1;
            }
            break;
          case 44:
            list.push(str.substring(start, end));
            start = end = i + 1;
            break;
          default:
            end = i + 1;
            break;
        }
      }
      list.push(str.substring(start, end));
      return list;
    }
  }
});

// node_modules/send/node_modules/mime/types.json
var require_types3 = __commonJS({
  "node_modules/send/node_modules/mime/types.json"(exports2, module2) {
    module2.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomsvc+xml": ["atomsvc"], "application/bdoc": ["bdoc"], "application/ccxml+xml": ["ccxml"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["ecma"], "application/emma+xml": ["emma"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/font-tdpfr": ["pfr"], "application/font-woff": [], "application/font-woff2": [], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/prs.cww": ["cww"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": [], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": [], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": [], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": [], "application/x-msdownload": ["com", "bat"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["wmf", "emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": [], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "application/xaml+xml": ["xaml"], "application/xcap-diff+xml": ["xdf"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": [], "audio/adpcm": ["adp"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mp3": [], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/wav": ["wav"], "audio/wave": [], "audio/webm": ["weba"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": [], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": [], "audio/x-wav": [], "audio/xm": ["xm"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/apng": ["apng"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/ief": ["ief"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/ktx": ["ktx"], "image/png": ["png"], "image/prs.btif": ["btif"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/tiff": ["tiff", "tif"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": [], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/webp": ["webp"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": [], "image/x-pcx": ["pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/rfc822": ["eml", "mime"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.vtu": ["vtu"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["x3db", "x3dbz"], "model/x3d+vrml": ["x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/hjson": ["hjson"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/prs.lines.tag": ["dsc"], "text/richtext": ["rtx"], "text/rtf": [], "text/sgml": ["sgml", "sgm"], "text/slim": ["slim", "slm"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/vtt": ["vtt"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": [], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "text/xml": [], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/jpeg": ["jpgv"], "video/jpm": ["jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/webm": ["webm"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
  }
});

// node_modules/send/node_modules/mime/mime.js
var require_mime = __commonJS({
  "node_modules/send/node_modules/mime/mime.js"(exports2, module2) {
    init_esm_shims();
    var path2 = __require("path");
    var fs = __require("fs");
    function Mime() {
      this.types = /* @__PURE__ */ Object.create(null);
      this.extensions = /* @__PURE__ */ Object.create(null);
    }
    Mime.prototype.define = function(map3) {
      for (var type in map3) {
        var exts = map3[type];
        for (var i = 0; i < exts.length; i++) {
          if (process.env.DEBUG_MIME && this.types[exts[i]]) {
            console.warn((this._loading || "define()").replace(/.*\//, ""), 'changes "' + exts[i] + '" extension type from ' + this.types[exts[i]] + " to " + type);
          }
          this.types[exts[i]] = type;
        }
        if (!this.extensions[type]) {
          this.extensions[type] = exts[0];
        }
      }
    };
    Mime.prototype.load = function(file) {
      this._loading = file;
      var map3 = {}, content = fs.readFileSync(file, "ascii"), lines = content.split(/[\r\n]+/);
      lines.forEach(function(line) {
        var fields = line.replace(/\s*#.*|^\s*|\s*$/g, "").split(/\s+/);
        map3[fields.shift()] = fields;
      });
      this.define(map3);
      this._loading = null;
    };
    Mime.prototype.lookup = function(path3, fallback2) {
      var ext = path3.replace(/^.*[\.\/\\]/, "").toLowerCase();
      return this.types[ext] || fallback2 || this.default_type;
    };
    Mime.prototype.extension = function(mimeType) {
      var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
      return this.extensions[type];
    };
    var mime = new Mime();
    mime.define(require_types3());
    mime.default_type = mime.lookup("bin");
    mime.Mime = Mime;
    mime.charsets = {
      lookup: function(mimeType, fallback2) {
        return /^text\/|^application\/(javascript|json)/.test(mimeType) ? "UTF-8" : fallback2;
      }
    };
    module2.exports = mime;
  }
});

// node_modules/ms/index.js
var require_ms3 = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    init_esm_shims();
    var s2 = 1e3;
    var m = s2 * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms / s2) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms, msAbs, s2, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/ee-first/index.js
var require_ee_first = __commonJS({
  "node_modules/ee-first/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = first;
    function first(stuff, done) {
      if (!Array.isArray(stuff))
        throw new TypeError("arg must be an array of [ee, events...] arrays");
      var cleanups = [];
      for (var i = 0; i < stuff.length; i++) {
        var arr = stuff[i];
        if (!Array.isArray(arr) || arr.length < 2)
          throw new TypeError("each array member must be [ee, events...]");
        var ee = arr[0];
        for (var j = 1; j < arr.length; j++) {
          var event = arr[j];
          var fn2 = listener(event, callback);
          ee.on(event, fn2);
          cleanups.push({
            ee,
            event,
            fn: fn2
          });
        }
      }
      function callback() {
        cleanup();
        done.apply(null, arguments);
      }
      function cleanup() {
        var x;
        for (var i2 = 0; i2 < cleanups.length; i2++) {
          x = cleanups[i2];
          x.ee.removeListener(x.event, x.fn);
        }
      }
      function thunk(fn3) {
        done = fn3;
      }
      thunk.cancel = cleanup;
      return thunk;
    }
    function listener(event, done) {
      return function onevent(arg1) {
        var args2 = new Array(arguments.length);
        var ee = this;
        var err = event === "error" ? arg1 : null;
        for (var i = 0; i < args2.length; i++) {
          args2[i] = arguments[i];
        }
        done(err, ee, event, args2);
      };
    }
  }
});

// node_modules/on-finished/index.js
var require_on_finished = __commonJS({
  "node_modules/on-finished/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = onFinished;
    module2.exports.isFinished = isFinished;
    var first = require_ee_first();
    var defer = typeof setImmediate === "function" ? setImmediate : function(fn2) {
      process.nextTick(fn2.bind.apply(fn2, arguments));
    };
    function onFinished(msg, listener) {
      if (isFinished(msg) !== false) {
        defer(listener, null, msg);
        return msg;
      }
      attachListener(msg, listener);
      return msg;
    }
    function isFinished(msg) {
      var socket = msg.socket;
      if (typeof msg.finished === "boolean") {
        return Boolean(msg.finished || socket && !socket.writable);
      }
      if (typeof msg.complete === "boolean") {
        return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
      }
      return void 0;
    }
    function attachFinishedListener(msg, callback) {
      var eeMsg;
      var eeSocket;
      var finished = false;
      function onFinish(error) {
        eeMsg.cancel();
        eeSocket.cancel();
        finished = true;
        callback(error);
      }
      eeMsg = eeSocket = first([[msg, "end", "finish"]], onFinish);
      function onSocket(socket) {
        msg.removeListener("socket", onSocket);
        if (finished)
          return;
        if (eeMsg !== eeSocket)
          return;
        eeSocket = first([[socket, "error", "close"]], onFinish);
      }
      if (msg.socket) {
        onSocket(msg.socket);
        return;
      }
      msg.on("socket", onSocket);
      if (msg.socket === void 0) {
        patchAssignSocket(msg, onSocket);
      }
    }
    function attachListener(msg, listener) {
      var attached = msg.__onFinished;
      if (!attached || !attached.queue) {
        attached = msg.__onFinished = createListener(msg);
        attachFinishedListener(msg, attached);
      }
      attached.queue.push(listener);
    }
    function createListener(msg) {
      function listener(err) {
        if (msg.__onFinished === listener)
          msg.__onFinished = null;
        if (!listener.queue)
          return;
        var queue2 = listener.queue;
        listener.queue = null;
        for (var i = 0; i < queue2.length; i++) {
          queue2[i](err, msg);
        }
      }
      listener.queue = [];
      return listener;
    }
    function patchAssignSocket(res, callback) {
      var assignSocket = res.assignSocket;
      if (typeof assignSocket !== "function")
        return;
      res.assignSocket = function _assignSocket(socket) {
        assignSocket.call(this, socket);
        callback(socket);
      };
    }
  }
});

// node_modules/range-parser/index.js
var require_range_parser = __commonJS({
  "node_modules/range-parser/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = rangeParser;
    function rangeParser(size, str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var index2 = str.indexOf("=");
      if (index2 === -1) {
        return -2;
      }
      var arr = str.slice(index2 + 1).split(",");
      var ranges = [];
      ranges.type = str.slice(0, index2);
      for (var i = 0; i < arr.length; i++) {
        var range2 = arr[i].split("-");
        var start = parseInt(range2[0], 10);
        var end = parseInt(range2[1], 10);
        if (isNaN(start)) {
          start = size - end;
          end = size - 1;
        } else if (isNaN(end)) {
          end = size - 1;
        }
        if (end > size - 1) {
          end = size - 1;
        }
        if (isNaN(start) || isNaN(end) || start > end || start < 0) {
          continue;
        }
        ranges.push({
          start,
          end
        });
      }
      if (ranges.length < 1) {
        return -1;
      }
      return options && options.combine ? combineRanges(ranges) : ranges;
    }
    function combineRanges(ranges) {
      var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
      for (var j = 0, i = 1; i < ordered.length; i++) {
        var range2 = ordered[i];
        var current = ordered[j];
        if (range2.start > current.end + 1) {
          ordered[++j] = range2;
        } else if (range2.end > current.end) {
          current.end = range2.end;
          current.index = Math.min(current.index, range2.index);
        }
      }
      ordered.length = j + 1;
      var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
      combined.type = ranges.type;
      return combined;
    }
    function mapWithIndex(range2, index2) {
      return {
        start: range2.start,
        end: range2.end,
        index: index2
      };
    }
    function mapWithoutIndex(range2) {
      return {
        start: range2.start,
        end: range2.end
      };
    }
    function sortByRangeIndex(a, b) {
      return a.index - b.index;
    }
    function sortByRangeStart(a, b) {
      return a.start - b.start;
    }
  }
});

// node_modules/send/index.js
var require_send = __commonJS({
  "node_modules/send/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var createError = require_http_errors();
    var debug = require_src2()("send");
    var deprecate2 = require_depd()("send");
    var destroy = require_destroy2();
    var encodeUrl = require_encodeurl();
    var escapeHtml = require_escape_html();
    var etag = require_etag();
    var fresh = require_fresh();
    var fs = __require("fs");
    var mime = require_mime();
    var ms = require_ms3();
    var onFinished = require_on_finished();
    var parseRange = require_range_parser();
    var path2 = __require("path");
    var statuses = require_statuses();
    var Stream = __require("stream");
    var util = __require("util");
    var extname = path2.extname;
    var join = path2.join;
    var normalize = path2.normalize;
    var resolve = path2.resolve;
    var sep = path2.sep;
    var BYTES_RANGE_REGEXP = /^ *bytes=/;
    var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1e3;
    var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
    module2.exports = send;
    module2.exports.mime = mime;
    function send(req, path3, options) {
      return new SendStream(req, path3, options);
    }
    function SendStream(req, path3, options) {
      Stream.call(this);
      var opts = options || {};
      this.options = opts;
      this.path = path3;
      this.req = req;
      this._acceptRanges = opts.acceptRanges !== void 0 ? Boolean(opts.acceptRanges) : true;
      this._cacheControl = opts.cacheControl !== void 0 ? Boolean(opts.cacheControl) : true;
      this._etag = opts.etag !== void 0 ? Boolean(opts.etag) : true;
      this._dotfiles = opts.dotfiles !== void 0 ? opts.dotfiles : "ignore";
      if (this._dotfiles !== "ignore" && this._dotfiles !== "allow" && this._dotfiles !== "deny") {
        throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
      }
      this._hidden = Boolean(opts.hidden);
      if (opts.hidden !== void 0) {
        deprecate2("hidden: use dotfiles: '" + (this._hidden ? "allow" : "ignore") + "' instead");
      }
      if (opts.dotfiles === void 0) {
        this._dotfiles = void 0;
      }
      this._extensions = opts.extensions !== void 0 ? normalizeList(opts.extensions, "extensions option") : [];
      this._immutable = opts.immutable !== void 0 ? Boolean(opts.immutable) : false;
      this._index = opts.index !== void 0 ? normalizeList(opts.index, "index option") : ["index.html"];
      this._lastModified = opts.lastModified !== void 0 ? Boolean(opts.lastModified) : true;
      this._maxage = opts.maxAge || opts.maxage;
      this._maxage = typeof this._maxage === "string" ? ms(this._maxage) : Number(this._maxage);
      this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
      this._root = opts.root ? resolve(opts.root) : null;
      if (!this._root && opts.from) {
        this.from(opts.from);
      }
    }
    util.inherits(SendStream, Stream);
    SendStream.prototype.etag = deprecate2.function(function etag2(val) {
      this._etag = Boolean(val);
      debug("etag %s", this._etag);
      return this;
    }, "send.etag: pass etag as option");
    SendStream.prototype.hidden = deprecate2.function(function hidden(val) {
      this._hidden = Boolean(val);
      this._dotfiles = void 0;
      debug("hidden %s", this._hidden);
      return this;
    }, "send.hidden: use dotfiles option");
    SendStream.prototype.index = deprecate2.function(function index2(paths) {
      var index3 = !paths ? [] : normalizeList(paths, "paths argument");
      debug("index %o", paths);
      this._index = index3;
      return this;
    }, "send.index: pass index as option");
    SendStream.prototype.root = function root(path3) {
      this._root = resolve(String(path3));
      debug("root %s", this._root);
      return this;
    };
    SendStream.prototype.from = deprecate2.function(SendStream.prototype.root, "send.from: pass root as option");
    SendStream.prototype.root = deprecate2.function(SendStream.prototype.root, "send.root: pass root as option");
    SendStream.prototype.maxage = deprecate2.function(function maxage(maxAge) {
      this._maxage = typeof maxAge === "string" ? ms(maxAge) : Number(maxAge);
      this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
      debug("max-age %d", this._maxage);
      return this;
    }, "send.maxage: pass maxAge as option");
    SendStream.prototype.error = function error(status, err) {
      if (hasListeners(this, "error")) {
        return this.emit("error", createError(status, err, {
          expose: false
        }));
      }
      var res = this.res;
      var msg = statuses[status] || String(status);
      var doc = createHtmlDocument("Error", escapeHtml(msg));
      clearHeaders(res);
      if (err && err.headers) {
        setHeaders(res, err.headers);
      }
      res.statusCode = status;
      res.setHeader("Content-Type", "text/html; charset=UTF-8");
      res.setHeader("Content-Length", Buffer.byteLength(doc));
      res.setHeader("Content-Security-Policy", "default-src 'none'");
      res.setHeader("X-Content-Type-Options", "nosniff");
      res.end(doc);
    };
    SendStream.prototype.hasTrailingSlash = function hasTrailingSlash() {
      return this.path[this.path.length - 1] === "/";
    };
    SendStream.prototype.isConditionalGET = function isConditionalGET() {
      return this.req.headers["if-match"] || this.req.headers["if-unmodified-since"] || this.req.headers["if-none-match"] || this.req.headers["if-modified-since"];
    };
    SendStream.prototype.isPreconditionFailure = function isPreconditionFailure() {
      var req = this.req;
      var res = this.res;
      var match = req.headers["if-match"];
      if (match) {
        var etag2 = res.getHeader("ETag");
        return !etag2 || match !== "*" && parseTokenList(match).every(function(match2) {
          return match2 !== etag2 && match2 !== "W/" + etag2 && "W/" + match2 !== etag2;
        });
      }
      var unmodifiedSince = parseHttpDate(req.headers["if-unmodified-since"]);
      if (!isNaN(unmodifiedSince)) {
        var lastModified = parseHttpDate(res.getHeader("Last-Modified"));
        return isNaN(lastModified) || lastModified > unmodifiedSince;
      }
      return false;
    };
    SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields() {
      var res = this.res;
      var headers = getHeaderNames(res);
      for (var i = 0; i < headers.length; i++) {
        var header = headers[i];
        if (header.substr(0, 8) === "content-" && header !== "content-location") {
          res.removeHeader(header);
        }
      }
    };
    SendStream.prototype.notModified = function notModified() {
      var res = this.res;
      debug("not modified");
      this.removeContentHeaderFields();
      res.statusCode = 304;
      res.end();
    };
    SendStream.prototype.headersAlreadySent = function headersAlreadySent() {
      var err = new Error("Can't set headers after they are sent.");
      debug("headers already sent");
      this.error(500, err);
    };
    SendStream.prototype.isCachable = function isCachable() {
      var statusCode = this.res.statusCode;
      return statusCode >= 200 && statusCode < 300 || statusCode === 304;
    };
    SendStream.prototype.onStatError = function onStatError(error) {
      switch (error.code) {
        case "ENAMETOOLONG":
        case "ENOENT":
        case "ENOTDIR":
          this.error(404, error);
          break;
        default:
          this.error(500, error);
          break;
      }
    };
    SendStream.prototype.isFresh = function isFresh() {
      return fresh(this.req.headers, {
        "etag": this.res.getHeader("ETag"),
        "last-modified": this.res.getHeader("Last-Modified")
      });
    };
    SendStream.prototype.isRangeFresh = function isRangeFresh() {
      var ifRange = this.req.headers["if-range"];
      if (!ifRange) {
        return true;
      }
      if (ifRange.indexOf('"') !== -1) {
        var etag2 = this.res.getHeader("ETag");
        return Boolean(etag2 && ifRange.indexOf(etag2) !== -1);
      }
      var lastModified = this.res.getHeader("Last-Modified");
      return parseHttpDate(lastModified) <= parseHttpDate(ifRange);
    };
    SendStream.prototype.redirect = function redirect(path3) {
      var res = this.res;
      if (hasListeners(this, "directory")) {
        this.emit("directory", res, path3);
        return;
      }
      if (this.hasTrailingSlash()) {
        this.error(403);
        return;
      }
      var loc = encodeUrl(collapseLeadingSlashes(this.path + "/"));
      var doc = createHtmlDocument("Redirecting", 'Redirecting to <a href="' + escapeHtml(loc) + '">' + escapeHtml(loc) + "</a>");
      res.statusCode = 301;
      res.setHeader("Content-Type", "text/html; charset=UTF-8");
      res.setHeader("Content-Length", Buffer.byteLength(doc));
      res.setHeader("Content-Security-Policy", "default-src 'none'");
      res.setHeader("X-Content-Type-Options", "nosniff");
      res.setHeader("Location", loc);
      res.end(doc);
    };
    SendStream.prototype.pipe = function pipe(res) {
      var root = this._root;
      this.res = res;
      var path3 = decode(this.path);
      if (path3 === -1) {
        this.error(400);
        return res;
      }
      if (~path3.indexOf("\0")) {
        this.error(400);
        return res;
      }
      var parts;
      if (root !== null) {
        if (path3) {
          path3 = normalize("." + sep + path3);
        }
        if (UP_PATH_REGEXP.test(path3)) {
          debug('malicious path "%s"', path3);
          this.error(403);
          return res;
        }
        parts = path3.split(sep);
        path3 = normalize(join(root, path3));
      } else {
        if (UP_PATH_REGEXP.test(path3)) {
          debug('malicious path "%s"', path3);
          this.error(403);
          return res;
        }
        parts = normalize(path3).split(sep);
        path3 = resolve(path3);
      }
      if (containsDotFile(parts)) {
        var access = this._dotfiles;
        if (access === void 0) {
          access = parts[parts.length - 1][0] === "." ? this._hidden ? "allow" : "ignore" : "allow";
        }
        debug('%s dotfile "%s"', access, path3);
        switch (access) {
          case "allow":
            break;
          case "deny":
            this.error(403);
            return res;
          case "ignore":
          default:
            this.error(404);
            return res;
        }
      }
      if (this._index.length && this.hasTrailingSlash()) {
        this.sendIndex(path3);
        return res;
      }
      this.sendFile(path3);
      return res;
    };
    SendStream.prototype.send = function send2(path3, stat) {
      var len = stat.size;
      var options = this.options;
      var opts = {};
      var res = this.res;
      var req = this.req;
      var ranges = req.headers.range;
      var offset = options.start || 0;
      if (headersSent(res)) {
        this.headersAlreadySent();
        return;
      }
      debug('pipe "%s"', path3);
      this.setHeader(path3, stat);
      this.type(path3);
      if (this.isConditionalGET()) {
        if (this.isPreconditionFailure()) {
          this.error(412);
          return;
        }
        if (this.isCachable() && this.isFresh()) {
          this.notModified();
          return;
        }
      }
      len = Math.max(0, len - offset);
      if (options.end !== void 0) {
        var bytes = options.end - offset + 1;
        if (len > bytes)
          len = bytes;
      }
      if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
        ranges = parseRange(len, ranges, {
          combine: true
        });
        if (!this.isRangeFresh()) {
          debug("range stale");
          ranges = -2;
        }
        if (ranges === -1) {
          debug("range unsatisfiable");
          res.setHeader("Content-Range", contentRange("bytes", len));
          return this.error(416, {
            headers: { "Content-Range": res.getHeader("Content-Range") }
          });
        }
        if (ranges !== -2 && ranges.length === 1) {
          debug("range %j", ranges);
          res.statusCode = 206;
          res.setHeader("Content-Range", contentRange("bytes", len, ranges[0]));
          offset += ranges[0].start;
          len = ranges[0].end - ranges[0].start + 1;
        }
      }
      for (var prop in options) {
        opts[prop] = options[prop];
      }
      opts.start = offset;
      opts.end = Math.max(offset, offset + len - 1);
      res.setHeader("Content-Length", len);
      if (req.method === "HEAD") {
        res.end();
        return;
      }
      this.stream(path3, opts);
    };
    SendStream.prototype.sendFile = function sendFile(path3) {
      var i = 0;
      var self = this;
      debug('stat "%s"', path3);
      fs.stat(path3, function onstat(err, stat) {
        if (err && err.code === "ENOENT" && !extname(path3) && path3[path3.length - 1] !== sep) {
          return next(err);
        }
        if (err)
          return self.onStatError(err);
        if (stat.isDirectory())
          return self.redirect(path3);
        self.emit("file", path3, stat);
        self.send(path3, stat);
      });
      function next(err) {
        if (self._extensions.length <= i) {
          return err ? self.onStatError(err) : self.error(404);
        }
        var p = path3 + "." + self._extensions[i++];
        debug('stat "%s"', p);
        fs.stat(p, function(err2, stat) {
          if (err2)
            return next(err2);
          if (stat.isDirectory())
            return next();
          self.emit("file", p, stat);
          self.send(p, stat);
        });
      }
    };
    SendStream.prototype.sendIndex = function sendIndex(path3) {
      var i = -1;
      var self = this;
      function next(err) {
        if (++i >= self._index.length) {
          if (err)
            return self.onStatError(err);
          return self.error(404);
        }
        var p = join(path3, self._index[i]);
        debug('stat "%s"', p);
        fs.stat(p, function(err2, stat) {
          if (err2)
            return next(err2);
          if (stat.isDirectory())
            return next();
          self.emit("file", p, stat);
          self.send(p, stat);
        });
      }
      next();
    };
    SendStream.prototype.stream = function stream(path3, options) {
      var finished = false;
      var self = this;
      var res = this.res;
      var stream2 = fs.createReadStream(path3, options);
      this.emit("stream", stream2);
      stream2.pipe(res);
      onFinished(res, function onfinished() {
        finished = true;
        destroy(stream2);
      });
      stream2.on("error", function onerror(err) {
        if (finished)
          return;
        finished = true;
        destroy(stream2);
        self.onStatError(err);
      });
      stream2.on("end", function onend() {
        self.emit("end");
      });
    };
    SendStream.prototype.type = function type(path3) {
      var res = this.res;
      if (res.getHeader("Content-Type"))
        return;
      var type2 = mime.lookup(path3);
      if (!type2) {
        debug("no content-type");
        return;
      }
      var charset = mime.charsets.lookup(type2);
      debug("content-type %s", type2);
      res.setHeader("Content-Type", type2 + (charset ? "; charset=" + charset : ""));
    };
    SendStream.prototype.setHeader = function setHeader(path3, stat) {
      var res = this.res;
      this.emit("headers", res, path3, stat);
      if (this._acceptRanges && !res.getHeader("Accept-Ranges")) {
        debug("accept ranges");
        res.setHeader("Accept-Ranges", "bytes");
      }
      if (this._cacheControl && !res.getHeader("Cache-Control")) {
        var cacheControl = "public, max-age=" + Math.floor(this._maxage / 1e3);
        if (this._immutable) {
          cacheControl += ", immutable";
        }
        debug("cache-control %s", cacheControl);
        res.setHeader("Cache-Control", cacheControl);
      }
      if (this._lastModified && !res.getHeader("Last-Modified")) {
        var modified = stat.mtime.toUTCString();
        debug("modified %s", modified);
        res.setHeader("Last-Modified", modified);
      }
      if (this._etag && !res.getHeader("ETag")) {
        var val = etag(stat);
        debug("etag %s", val);
        res.setHeader("ETag", val);
      }
    };
    function clearHeaders(res) {
      var headers = getHeaderNames(res);
      for (var i = 0; i < headers.length; i++) {
        res.removeHeader(headers[i]);
      }
    }
    function collapseLeadingSlashes(str) {
      for (var i = 0; i < str.length; i++) {
        if (str[i] !== "/") {
          break;
        }
      }
      return i > 1 ? "/" + str.substr(i) : str;
    }
    function containsDotFile(parts) {
      for (var i = 0; i < parts.length; i++) {
        var part = parts[i];
        if (part.length > 1 && part[0] === ".") {
          return true;
        }
      }
      return false;
    }
    function contentRange(type, size, range2) {
      return type + " " + (range2 ? range2.start + "-" + range2.end : "*") + "/" + size;
    }
    function createHtmlDocument(title, body) {
      return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
    }
    function decode(path3) {
      try {
        return decodeURIComponent(path3);
      } catch (err) {
        return -1;
      }
    }
    function getHeaderNames(res) {
      return typeof res.getHeaderNames !== "function" ? Object.keys(res._headers || {}) : res.getHeaderNames();
    }
    function hasListeners(emitter, type) {
      var count = typeof emitter.listenerCount !== "function" ? emitter.listeners(type).length : emitter.listenerCount(type);
      return count > 0;
    }
    function headersSent(res) {
      return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
    }
    function normalizeList(val, name) {
      var list = [].concat(val || []);
      for (var i = 0; i < list.length; i++) {
        if (typeof list[i] !== "string") {
          throw new TypeError(name + " must be array of strings or false");
        }
      }
      return list;
    }
    function parseHttpDate(date) {
      var timestamp = date && Date.parse(date);
      return typeof timestamp === "number" ? timestamp : NaN;
    }
    function parseTokenList(str) {
      var end = 0;
      var list = [];
      var start = 0;
      for (var i = 0, len = str.length; i < len; i++) {
        switch (str.charCodeAt(i)) {
          case 32:
            if (start === end) {
              start = end = i + 1;
            }
            break;
          case 44:
            list.push(str.substring(start, end));
            start = end = i + 1;
            break;
          default:
            end = i + 1;
            break;
        }
      }
      list.push(str.substring(start, end));
      return list;
    }
    function setHeaders(res, headers) {
      var keys = Object.keys(headers);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        res.setHeader(key, headers[key]);
      }
    }
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    init_esm_shims();
    var buffer = __require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/content-disposition/index.js
var require_content_disposition = __commonJS({
  "node_modules/content-disposition/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = contentDisposition;
    module2.exports.parse = parse;
    var basename = __require("path").basename;
    var Buffer2 = require_safe_buffer2().Buffer;
    var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
    var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
    var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
    var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
    var QESC_REGEXP = /\\([\u0000-\u007f])/g;
    var QUOTE_REGEXP = /([\\"])/g;
    var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
    var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
    var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
    var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
    var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
    function contentDisposition(filename, options) {
      var opts = options || {};
      var type = opts.type || "attachment";
      var params = createparams(filename, opts.fallback);
      return format(new ContentDisposition(type, params));
    }
    function createparams(filename, fallback2) {
      if (filename === void 0) {
        return;
      }
      var params = {};
      if (typeof filename !== "string") {
        throw new TypeError("filename must be a string");
      }
      if (fallback2 === void 0) {
        fallback2 = true;
      }
      if (typeof fallback2 !== "string" && typeof fallback2 !== "boolean") {
        throw new TypeError("fallback must be a string or boolean");
      }
      if (typeof fallback2 === "string" && NON_LATIN1_REGEXP.test(fallback2)) {
        throw new TypeError("fallback must be ISO-8859-1 string");
      }
      var name = basename(filename);
      var isQuotedString = TEXT_REGEXP.test(name);
      var fallbackName = typeof fallback2 !== "string" ? fallback2 && getlatin1(name) : basename(fallback2);
      var hasFallback = typeof fallbackName === "string" && fallbackName !== name;
      if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
        params["filename*"] = name;
      }
      if (isQuotedString || hasFallback) {
        params.filename = hasFallback ? fallbackName : name;
      }
      return params;
    }
    function format(obj) {
      var parameters = obj.parameters;
      var type = obj.type;
      if (!type || typeof type !== "string" || !TOKEN_REGEXP.test(type)) {
        throw new TypeError("invalid type");
      }
      var string = String(type).toLowerCase();
      if (parameters && typeof parameters === "object") {
        var param;
        var params = Object.keys(parameters).sort();
        for (var i = 0; i < params.length; i++) {
          param = params[i];
          var val = param.substr(-1) === "*" ? ustring(parameters[param]) : qstring(parameters[param]);
          string += "; " + param + "=" + val;
        }
      }
      return string;
    }
    function decodefield(str) {
      var match = EXT_VALUE_REGEXP.exec(str);
      if (!match) {
        throw new TypeError("invalid extended field value");
      }
      var charset = match[1].toLowerCase();
      var encoded = match[2];
      var value;
      var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
      switch (charset) {
        case "iso-8859-1":
          value = getlatin1(binary);
          break;
        case "utf-8":
          value = Buffer2.from(binary, "binary").toString("utf8");
          break;
        default:
          throw new TypeError("unsupported charset in extended field");
      }
      return value;
    }
    function getlatin1(val) {
      return String(val).replace(NON_LATIN1_REGEXP, "?");
    }
    function parse(string) {
      if (!string || typeof string !== "string") {
        throw new TypeError("argument string is required");
      }
      var match = DISPOSITION_TYPE_REGEXP.exec(string);
      if (!match) {
        throw new TypeError("invalid type format");
      }
      var index2 = match[0].length;
      var type = match[1].toLowerCase();
      var key;
      var names = [];
      var params = {};
      var value;
      index2 = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ";" ? index2 - 1 : index2;
      while (match = PARAM_REGEXP.exec(string)) {
        if (match.index !== index2) {
          throw new TypeError("invalid parameter format");
        }
        index2 += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (names.indexOf(key) !== -1) {
          throw new TypeError("invalid duplicate parameter");
        }
        names.push(key);
        if (key.indexOf("*") + 1 === key.length) {
          key = key.slice(0, -1);
          value = decodefield(value);
          params[key] = value;
          continue;
        }
        if (typeof params[key] === "string") {
          continue;
        }
        if (value[0] === '"') {
          value = value.substr(1, value.length - 2).replace(QESC_REGEXP, "$1");
        }
        params[key] = value;
      }
      if (index2 !== -1 && index2 !== string.length) {
        throw new TypeError("invalid parameter format");
      }
      return new ContentDisposition(type, params);
    }
    function pdecode(str, hex) {
      return String.fromCharCode(parseInt(hex, 16));
    }
    function pencode(char) {
      return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
    }
    function qstring(val) {
      var str = String(val);
      return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
    }
    function ustring(val) {
      var str = String(val);
      var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
      return "UTF-8''" + encoded;
    }
    function ContentDisposition(type, parameters) {
      this.type = type;
      this.parameters = parameters;
    }
  }
});

// node_modules/fastify-plugin/stackParser.js
var require_stackParser = __commonJS({
  "node_modules/fastify-plugin/stackParser.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var fpStackTracePattern = /at\s{1}(?:.*\.)?plugin\s{1}.*\n\s*(.*)/;
    var fileNamePattern = /(\w*(\.\w*)*)\..*/;
    module2.exports = function extractPluginName(stack2) {
      const m = stack2.match(fpStackTracePattern);
      return m ? m[1].split(/[/\\]/).slice(-1)[0].match(fileNamePattern)[1] : "anonymous";
    };
  }
});

// node_modules/fastify-plugin/plugin.js
var require_plugin2 = __commonJS({
  "node_modules/fastify-plugin/plugin.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var extractPluginName = require_stackParser();
    var count = 0;
    function plugin(fn2, options = {}) {
      let autoName = false;
      if (typeof fn2.default !== "undefined") {
        fn2 = fn2.default;
      }
      if (typeof fn2 !== "function") {
        throw new TypeError(`fastify-plugin expects a function, instead got a '${typeof fn2}'`);
      }
      fn2[Symbol.for("skip-override")] = true;
      const pluginName = options && options.name || checkName(fn2);
      if (typeof options === "string") {
        options = {
          fastify: options
        };
      }
      if (typeof options !== "object" || Array.isArray(options) || options === null) {
        throw new TypeError("The options object should be an object");
      }
      if (options.fastify !== void 0 && typeof options.fastify !== "string") {
        throw new TypeError(`fastify-plugin expects a version string, instead got '${typeof options.fastify}'`);
      }
      if (!options.name) {
        autoName = true;
        options.name = pluginName + "-auto-" + count++;
      }
      fn2[Symbol.for("fastify.display-name")] = options.name;
      fn2[Symbol.for("plugin-meta")] = options;
      if (!fn2.default) {
        fn2.default = fn2;
      }
      const camelCase = toCamelCase(options.name);
      if (!autoName && !fn2[camelCase]) {
        fn2[camelCase] = fn2;
      }
      return fn2;
    }
    function checkName(fn2) {
      if (fn2.name.length > 0)
        return fn2.name;
      try {
        throw new Error("anonymous function");
      } catch (e) {
        return extractPluginName(e.stack);
      }
    }
    function toCamelCase(name) {
      const newName = name.replace(/-(.)/g, function(match, g1) {
        return g1.toUpperCase();
      });
      return newName;
    }
    plugin.default = plugin;
    module2.exports = plugin;
  }
});

// node_modules/encoding-negotiator/index.js
var require_encoding_negotiator = __commonJS({
  "node_modules/encoding-negotiator/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    function negotiate(header, supportedEncodings) {
      if (!header) {
        return void 0;
      }
      const supportedEncodingMap = createMap(supportedEncodings);
      const acceptedEncodings = parse(header).sort((a, b) => comparator(a, b, supportedEncodingMap)).filter(isNonZeroQuality);
      return determinePreffered(acceptedEncodings, supportedEncodingMap);
    }
    function determinePreffered(acceptedEncodings, supportedEncodings) {
      for (const encoding of acceptedEncodings) {
        const selected = supportedEncodings[encoding.name];
        if (selected) {
          return selected.encoding;
        }
      }
      return null;
    }
    function createMap(supported) {
      const supportedEncodings = {};
      let priority = 0;
      if (supported.length > 0) {
        supportedEncodings["*"] = { encoding: supported[0], priority };
        priority++;
      }
      for (const encoding of supported) {
        supportedEncodings[encoding] = { encoding, priority };
        priority++;
      }
      return supportedEncodings;
    }
    function parse(header) {
      const split = header.split(",");
      return split.map(parseEncoding);
    }
    function isNonZeroQuality(encoding) {
      return encoding.quality !== 0;
    }
    function parseEncoding(encoding) {
      const [name, second] = encoding.trim().split(";");
      const quality = getQuality(second);
      return {
        name,
        quality
      };
    }
    function getQuality(second) {
      if (!second) {
        return 1;
      }
      const [, quality] = second.trim().split("=");
      return parseFloat(quality);
    }
    function comparator(a, b, supportedEncodingMap) {
      if (a.quality === b.quality) {
        if (supportedEncodingMap[a.name] && supportedEncodingMap[b.name] && supportedEncodingMap[a.name].priority < supportedEncodingMap[b.name].priority) {
          return -1;
        } else {
          return 1;
        }
      }
      return b.quality - a.quality;
    }
    module2.exports = {
      negotiate
    };
  }
});

// node_modules/yocto-queue/index.js
var require_yocto_queue = __commonJS({
  "node_modules/yocto-queue/index.js"(exports2, module2) {
    init_esm_shims();
    var Node = class {
      constructor(value) {
        this.value = value;
        this.next = void 0;
      }
    };
    var Queue = class {
      constructor() {
        this.clear();
      }
      enqueue(value) {
        const node = new Node(value);
        if (this._head) {
          this._tail.next = node;
          this._tail = node;
        } else {
          this._head = node;
          this._tail = node;
        }
        this._size++;
      }
      dequeue() {
        const current = this._head;
        if (!current) {
          return;
        }
        this._head = this._head.next;
        this._size--;
        return current.value;
      }
      clear() {
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
      }
      get size() {
        return this._size;
      }
      *[Symbol.iterator]() {
        let current = this._head;
        while (current) {
          yield current.value;
          current = current.next;
        }
      }
    };
    module2.exports = Queue;
  }
});

// node_modules/fastify-static/node_modules/p-limit/index.js
var require_p_limit = __commonJS({
  "node_modules/fastify-static/node_modules/p-limit/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var Queue = require_yocto_queue();
    var pLimit = (concurrency) => {
      if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
        throw new TypeError("Expected `concurrency` to be a number from 1 and up");
      }
      const queue2 = new Queue();
      let activeCount = 0;
      const next = () => {
        activeCount--;
        if (queue2.size > 0) {
          queue2.dequeue()();
        }
      };
      const run = async (fn2, resolve, ...args2) => {
        activeCount++;
        const result = (async () => fn2(...args2))();
        resolve(result);
        try {
          await result;
        } catch {
        }
        next();
      };
      const enqueue = (fn2, resolve, ...args2) => {
        queue2.enqueue(run.bind(null, fn2, resolve, ...args2));
        (async () => {
          await Promise.resolve();
          if (activeCount < concurrency && queue2.size > 0) {
            queue2.dequeue()();
          }
        })();
      };
      const generator = (fn2, ...args2) => new Promise((resolve) => {
        enqueue(fn2, resolve, ...args2);
      });
      Object.defineProperties(generator, {
        activeCount: {
          get: () => activeCount
        },
        pendingCount: {
          get: () => queue2.size
        },
        clearQueue: {
          value: () => {
            queue2.clear();
          }
        }
      });
      return generator;
    };
    module2.exports = pLimit;
  }
});

// node_modules/fastify-static/lib/dirList.js
var require_dirList = __commonJS({
  "node_modules/fastify-static/lib/dirList.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var path2 = __require("path");
    var fs = __require("fs").promises;
    var pLimit = require_p_limit();
    var dirList = {
      list: async function(dir2, options) {
        const entries = { dirs: [], files: [] };
        const files = await fs.readdir(dir2);
        if (files.length < 1) {
          return entries;
        }
        const limit = pLimit(4);
        await Promise.all(files.map((filename) => limit(async () => {
          let stats;
          try {
            stats = await fs.stat(path2.join(dir2, filename));
          } catch (error) {
            return;
          }
          const entry = { name: filename, stats };
          if (stats.isDirectory()) {
            if (options.extendedFolderInfo) {
              entry.extendedInfo = await getExtendedInfo(path2.join(dir2, filename));
            }
            entries.dirs.push(entry);
          } else {
            entries.files.push(entry);
          }
        })));
        async function getExtendedInfo(folderPath) {
          const depth = folderPath.split(path2.sep).length;
          let totalSize = 0;
          let fileCount = 0;
          let totalFileCount = 0;
          let folderCount = 0;
          let totalFolderCount = 0;
          let lastModified = 0;
          async function walk(dir3) {
            const files2 = await fs.readdir(dir3);
            const limit2 = pLimit(4);
            await Promise.all(files2.map((filename) => limit2(async () => {
              const filePath = path2.join(dir3, filename);
              let stats;
              try {
                stats = await fs.stat(filePath);
              } catch (error) {
                return;
              }
              if (stats.isDirectory()) {
                totalFolderCount++;
                if (filePath.split(path2.sep).length === depth + 1) {
                  folderCount++;
                }
                await walk(filePath);
              } else {
                totalSize += stats.size;
                totalFileCount++;
                if (filePath.split(path2.sep).length === depth + 1) {
                  fileCount++;
                }
                lastModified = Math.max(lastModified, stats.mtimeMs);
              }
            })));
          }
          await walk(folderPath);
          return {
            totalSize,
            fileCount,
            totalFileCount,
            folderCount,
            totalFolderCount,
            lastModified
          };
        }
        entries.dirs.sort((a, b) => a.name.localeCompare(b.name));
        entries.files.sort((a, b) => a.name.localeCompare(b.name));
        return entries;
      },
      send: async function({ reply, dir: dir2, options, route, prefix }) {
        let entries;
        try {
          entries = await dirList.list(dir2, options);
        } catch (error) {
          return reply.callNotFound();
        }
        const format = reply.request.query.format || options.format;
        if (format !== "html") {
          if (options.jsonFormat !== "extended") {
            const nameEntries = { dirs: [], files: [] };
            entries.dirs.forEach((entry) => nameEntries.dirs.push(entry.name));
            entries.files.forEach((entry) => nameEntries.files.push(entry.name));
            reply.send(nameEntries);
          } else {
            reply.send(entries);
          }
          return;
        }
        const html = options.render(entries.dirs.map((entry) => dirList.htmlInfo(entry, route, prefix, options)), entries.files.map((entry) => dirList.htmlInfo(entry, route, prefix, options)));
        reply.type("text/html").send(html);
      },
      htmlInfo: function(entry, route, prefix, options) {
        if (options.names && options.names.includes(path2.basename(route))) {
          route = path2.normalize(path2.join(route, ".."));
        }
        return {
          href: path2.join(prefix, route, entry.name).replace(/\\/g, "/"),
          name: entry.name,
          stats: entry.stats,
          extendedInfo: entry.extendedInfo
        };
      },
      handle: function(route, options) {
        if (!options.names) {
          return false;
        }
        return options.names.includes(path2.basename(route)) || options.names.includes("/") && route[route.length - 1] === "/";
      },
      path: function(root, route) {
        const _route = route[route.length - 1] === "/" ? route + "none" : route;
        return path2.dirname(path2.join(root, _route));
      },
      validateOptions: function(options) {
        if (!options) {
          return;
        }
        if (options.format && options.format !== "json" && options.format !== "html") {
          return new TypeError("The `list.format` option must be json or html");
        }
        if (options.names && !Array.isArray(options.names)) {
          return new TypeError("The `list.names` option must be an array");
        }
        if (options.format === "html" && typeof options.render !== "function") {
          return new TypeError("The `list.render` option must be a function and is required with html format");
        }
      }
    };
    module2.exports = dirList;
  }
});

// node_modules/fastify-static/index.js
var require_fastify_static = __commonJS({
  "node_modules/fastify-static/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var path2 = __require("path");
    var statSync = __require("fs").statSync;
    var { PassThrough } = require_readable();
    var glob = require_glob();
    var send = require_send();
    var contentDisposition = require_content_disposition();
    var fp = require_plugin2();
    var util = __require("util");
    var globPromise = util.promisify(glob);
    var encodingNegotiator = require_encoding_negotiator();
    var dirList = require_dirList();
    async function fastifyStatic(fastify2, opts) {
      checkRootPathForErrors(fastify2, opts.root);
      const setHeaders = opts.setHeaders;
      if (setHeaders !== void 0 && typeof setHeaders !== "function") {
        throw new TypeError("The `setHeaders` option must be a function");
      }
      const invalidDirListOpts = dirList.validateOptions(opts.list);
      if (invalidDirListOpts) {
        throw invalidDirListOpts;
      }
      const sendOptions = {
        root: opts.root,
        acceptRanges: opts.acceptRanges,
        cacheControl: opts.cacheControl,
        dotfiles: opts.dotfiles,
        etag: opts.etag,
        extensions: opts.extensions,
        immutable: opts.immutable,
        index: opts.index,
        lastModified: opts.lastModified,
        maxAge: opts.maxAge
      };
      const allowedPath = opts.allowedPath;
      if (opts.prefix === void 0)
        opts.prefix = "/";
      let prefix = opts.prefix;
      if (!opts.prefixAvoidTrailingSlash) {
        prefix = opts.prefix[opts.prefix.length - 1] === "/" ? opts.prefix : opts.prefix + "/";
      }
      function pumpSendToReply(request, reply, pathname, rootPath, rootPathOffset = 0, pumpOptions = {}, checkedEncodings) {
        const options = Object.assign({}, sendOptions, pumpOptions);
        if (rootPath) {
          if (Array.isArray(rootPath)) {
            options.root = rootPath[rootPathOffset];
          } else {
            options.root = rootPath;
          }
        }
        if (allowedPath && !allowedPath(pathname, options.root)) {
          return reply.callNotFound();
        }
        let encoding;
        let pathnameForSend = pathname;
        if (opts.preCompressed) {
          if (!checkedEncodings) {
            checkedEncodings = /* @__PURE__ */ new Set();
          }
          encoding = getEncodingHeader(request.headers, checkedEncodings);
          if (encoding) {
            if (pathname.endsWith("/")) {
              pathname = findIndexFile(pathname, options.root, options.index);
              if (!pathname) {
                return reply.callNotFound();
              }
            }
            pathnameForSend = pathname + "." + getEncodingExtension(encoding);
          }
        }
        const stream = send(request.raw, pathnameForSend, options);
        let resolvedFilename;
        stream.on("file", function(file) {
          resolvedFilename = file;
        });
        const wrap2 = new PassThrough({
          flush(cb) {
            this.finished = true;
            if (reply.raw.statusCode === 304) {
              reply.send("");
            }
            cb();
          }
        });
        wrap2.getHeader = reply.getHeader.bind(reply);
        wrap2.setHeader = reply.header.bind(reply);
        wrap2.finished = false;
        Object.defineProperty(wrap2, "filename", {
          get() {
            return resolvedFilename;
          }
        });
        Object.defineProperty(wrap2, "statusCode", {
          get() {
            return reply.raw.statusCode;
          },
          set(code) {
            reply.code(code);
          }
        });
        if (request.method === "HEAD") {
          wrap2.on("finish", reply.send.bind(reply));
        } else {
          wrap2.on("pipe", function() {
            if (encoding) {
              reply.header("content-type", getContentType(pathname));
              reply.header("content-encoding", encoding);
            }
            reply.send(wrap2);
          });
        }
        if (setHeaders !== void 0) {
          stream.on("headers", setHeaders);
        }
        stream.on("directory", function(_, path3) {
          if (opts.list) {
            dirList.send({
              reply,
              dir: path3,
              options: opts.list,
              route: pathname,
              prefix
            }).catch((err) => reply.send(err));
            return;
          }
          if (opts.redirect === true) {
            try {
              reply.redirect(301, getRedirectUrl(request.raw.url));
            } catch (error) {
              reply.send(error);
            }
          } else {
            reply.callNotFound();
          }
        });
        stream.on("error", function(err) {
          if (err.code === "ENOENT") {
            if (opts.list && dirList.handle(pathname, opts.list)) {
              dirList.send({
                reply,
                dir: dirList.path(opts.root, pathname),
                options: opts.list,
                route: pathname,
                prefix
              }).catch((err2) => reply.send(err2));
              return;
            }
            if (Array.isArray(rootPath) && rootPathOffset < rootPath.length - 1) {
              return pumpSendToReply(request, reply, pathname, rootPath, rootPathOffset + 1);
            }
            if (opts.preCompressed && !checkedEncodings.has(encoding)) {
              checkedEncodings.add(encoding);
              return pumpSendToReply(request, reply, pathname, rootPath, void 0, void 0, checkedEncodings);
            }
            return reply.callNotFound();
          }
          if (err.status === 404) {
            return reply.callNotFound();
          }
          reply.send(err);
        });
        stream.pipe(wrap2);
      }
      const errorHandler = (error, request, reply) => {
        if (error && error.code === "ERR_STREAM_PREMATURE_CLOSE") {
          reply.request.raw.destroy();
          return;
        }
        fastify2.errorHandler(error, request, reply);
      };
      const routeOpts = {
        schema: {
          hide: typeof opts.schemaHide !== "undefined" ? opts.schemaHide : true
        },
        errorHandler: fastify2.errorHandler ? errorHandler : void 0
      };
      if (opts.decorateReply !== false) {
        fastify2.decorateReply("sendFile", function(filePath, rootPath, options) {
          const opts2 = typeof rootPath === "object" ? rootPath : options;
          const root = typeof rootPath === "string" ? rootPath : opts2 && opts2.root;
          pumpSendToReply(this.request, this, filePath, root || sendOptions.root, 0, opts2);
          return this;
        });
        fastify2.decorateReply("download", function(filePath, fileName, options = {}) {
          const _a = typeof fileName === "object" ? fileName : options, { root } = _a, opts2 = __objRest(_a, ["root"]);
          fileName = typeof fileName === "string" ? fileName : filePath;
          this.header("content-disposition", contentDisposition(fileName));
          pumpSendToReply(this.request, this, filePath, root, 0, opts2);
          return this;
        });
      }
      if (opts.serve !== false) {
        if (opts.wildcard && typeof opts.wildcard !== "boolean") {
          throw new Error('"wildcard" option must be a boolean');
        }
        if (opts.wildcard === void 0 || opts.wildcard === true) {
          fastify2.head(prefix + "*", routeOpts, function(req, reply) {
            pumpSendToReply(req, reply, "/" + req.params["*"], sendOptions.root);
          });
          fastify2.get(prefix + "*", routeOpts, function(req, reply) {
            pumpSendToReply(req, reply, "/" + req.params["*"], sendOptions.root);
          });
          if (opts.redirect === true && prefix !== opts.prefix) {
            fastify2.get(opts.prefix, routeOpts, function(req, reply) {
              reply.redirect(301, getRedirectUrl(req.raw.url));
            });
          }
        } else {
          const globPattern = "**/*";
          const indexDirs = /* @__PURE__ */ new Map();
          const routes = /* @__PURE__ */ new Set();
          for (const rootPath of Array.isArray(sendOptions.root) ? sendOptions.root : [sendOptions.root]) {
            const files = await globPromise(path2.join(rootPath, globPattern), { nodir: true });
            const indexes = typeof opts.index === "undefined" ? ["index.html"] : [].concat(opts.index);
            for (let file of files) {
              file = file.replace(rootPath.replace(/\\/g, "/"), "").replace(/^\//, "");
              const route = encodeURI(prefix + file).replace(/\/\//g, "/");
              if (routes.has(route)) {
                continue;
              }
              routes.add(route);
              fastify2.head(route, routeOpts, function(req, reply) {
                pumpSendToReply(req, reply, "/" + file, rootPath);
              });
              fastify2.get(route, routeOpts, function(req, reply) {
                pumpSendToReply(req, reply, "/" + file, rootPath);
              });
              const key = path2.posix.basename(route);
              if (indexes.includes(key) && !indexDirs.has(key)) {
                indexDirs.set(path2.posix.dirname(route), rootPath);
              }
            }
          }
          for (const [dirname, rootPath] of indexDirs.entries()) {
            const pathname = dirname + (dirname.endsWith("/") ? "" : "/");
            const file = "/" + pathname.replace(prefix, "");
            fastify2.head(pathname, routeOpts, function(req, reply) {
              pumpSendToReply(req, reply, file, rootPath);
            });
            fastify2.get(pathname, routeOpts, function(req, reply) {
              pumpSendToReply(req, reply, file, rootPath);
            });
            if (opts.redirect === true) {
              fastify2.head(pathname.replace(/\/$/, ""), routeOpts, function(req, reply) {
                pumpSendToReply(req, reply, file.replace(/\/$/, ""), rootPath);
              });
              fastify2.get(pathname.replace(/\/$/, ""), routeOpts, function(req, reply) {
                pumpSendToReply(req, reply, file.replace(/\/$/, ""), rootPath);
              });
            }
          }
        }
      }
    }
    function checkRootPathForErrors(fastify2, rootPath) {
      if (rootPath === void 0) {
        throw new Error('"root" option is required');
      }
      if (Array.isArray(rootPath)) {
        if (!rootPath.length) {
          throw new Error('"root" option array requires one or more paths');
        }
        if ([...new Set(rootPath)].length !== rootPath.length) {
          throw new Error('"root" option array contains one or more duplicate paths');
        }
        rootPath.map((path3) => checkPath(fastify2, path3));
        return;
      }
      if (typeof rootPath === "string") {
        return checkPath(fastify2, rootPath);
      }
      throw new Error('"root" option must be a string or array of strings');
    }
    function checkPath(fastify2, rootPath) {
      if (typeof rootPath !== "string") {
        throw new Error('"root" option must be a string');
      }
      if (path2.isAbsolute(rootPath) === false) {
        throw new Error('"root" option must be an absolute path');
      }
      let pathStat;
      try {
        pathStat = statSync(rootPath);
      } catch (e) {
        if (e.code === "ENOENT") {
          fastify2.log.warn(`"root" path "${rootPath}" must exist`);
          return;
        }
        throw e;
      }
      if (pathStat.isDirectory() === false) {
        throw new Error('"root" option must point to a directory');
      }
    }
    var supportedEncodings = ["br", "gzip", "deflate"];
    function getContentType(path3) {
      const type = send.mime.lookup(path3);
      const charset = send.mime.charsets.lookup(type);
      if (!charset) {
        return type;
      }
      return `${type}; charset=${charset}`;
    }
    function findIndexFile(pathname, root, indexFiles = ["index.html"]) {
      return indexFiles.find((filename) => {
        const p = path2.join(root, pathname, filename);
        try {
          const stats = statSync(p);
          return !stats.isDirectory();
        } catch (e) {
          return false;
        }
      });
    }
    function getEncodingHeader(headers, checked) {
      if (!("accept-encoding" in headers))
        return;
      const header = headers["accept-encoding"].toLowerCase().replace(/\*/g, "gzip");
      return encodingNegotiator.negotiate(header, supportedEncodings.filter((enc) => !checked.has(enc)));
    }
    function getEncodingExtension(encoding) {
      switch (encoding) {
        case "br":
          return "br";
        case "gzip":
          return "gz";
      }
    }
    function getRedirectUrl(url) {
      let i = 0;
      for (i; i < url.length; i++) {
        if (url[i] !== "/" && url[i] !== "\\")
          break;
      }
      url = "/" + url.substr(i);
      try {
        const parsed = new URL(url, "http://localhost.com/");
        return parsed.pathname + (parsed.pathname[parsed.pathname.length - 1] !== "/" ? "/" : "") + (parsed.search || "");
      } catch (error) {
        const err = new Error(`Invalid redirect URL: ${url}`);
        err.statusCode = 400;
        throw err;
      }
    }
    module2.exports = fp(fastifyStatic, {
      fastify: "3.x",
      name: "fastify-static"
    });
  }
});

// node_modules/hashlru/index.js
var require_hashlru = __commonJS({
  "node_modules/hashlru/index.js"(exports2, module2) {
    init_esm_shims();
    module2.exports = function(max) {
      if (!max)
        throw Error("hashlru must have a max value, of type number, greater than 0");
      var size = 0, cache = /* @__PURE__ */ Object.create(null), _cache = /* @__PURE__ */ Object.create(null);
      function update(key, value) {
        cache[key] = value;
        size++;
        if (size >= max) {
          size = 0;
          _cache = cache;
          cache = /* @__PURE__ */ Object.create(null);
        }
      }
      return {
        has: function(key) {
          return cache[key] !== void 0 || _cache[key] !== void 0;
        },
        remove: function(key) {
          if (cache[key] !== void 0)
            cache[key] = void 0;
          if (_cache[key] !== void 0)
            _cache[key] = void 0;
        },
        get: function(key) {
          var v = cache[key];
          if (v !== void 0)
            return v;
          if ((v = _cache[key]) !== void 0) {
            update(key, v);
            return v;
          }
        },
        set: function(key, value) {
          if (cache[key] !== void 0)
            cache[key] = value;
          else
            update(key, value);
        },
        clear: function() {
          cache = /* @__PURE__ */ Object.create(null);
          _cache = /* @__PURE__ */ Object.create(null);
        }
      };
    };
  }
});

// node_modules/point-of-view/index.js
var require_point_of_view = __commonJS({
  "node_modules/point-of-view/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var fp = require_plugin2();
    var readFile = __require("fs").readFile;
    var accessSync = __require("fs").accessSync;
    var existsSync = __require("fs").existsSync;
    var mkdirSync = __require("fs").mkdirSync;
    var readdirSync = __require("fs").readdirSync;
    var resolve = __require("path").resolve;
    var join = __require("path").join;
    var { basename, dirname, extname } = __require("path");
    var HLRU = require_hashlru();
    var supportedEngines = ["ejs", "nunjucks", "pug", "handlebars", "mustache", "art-template", "twig", "liquid", "dot", "eta"];
    function fastifyView(fastify2, opts, next) {
      if (!opts.engine) {
        next(new Error("Missing engine"));
        return;
      }
      const type = Object.keys(opts.engine)[0];
      if (supportedEngines.indexOf(type) === -1) {
        next(new Error(`'${type}' not yet supported, PR? :)`));
        return;
      }
      const charset = opts.charset || "utf-8";
      const propertyName = opts.propertyName || "view";
      const engine = opts.engine[type];
      const globalOptions = opts.options || {};
      const templatesDir = opts.root || resolve(opts.templates || "./");
      const lru = HLRU(opts.maxCache || 100);
      const includeViewExtension = opts.includeViewExtension || false;
      const viewExt = opts.viewExt || "";
      const prod = typeof opts.production === "boolean" ? opts.production : process.env.NODE_ENV === "production";
      const defaultCtx = opts.defaultContext || {};
      const globalLayoutFileName = opts.layout;
      function layoutIsValid(_layoutFileName) {
        if (type !== "dot" && type !== "handlebars" && type !== "ejs" && type !== "eta") {
          throw new Error('Only Dot, Handlebars, EJS, and Eta support the "layout" option');
        }
        if (!hasAccessToLayoutFile(_layoutFileName, getDefaultExtension(type))) {
          throw new Error(`unable to access template "${_layoutFileName}"`);
        }
      }
      if (globalLayoutFileName) {
        try {
          layoutIsValid(globalLayoutFileName);
        } catch (error) {
          next(error);
          return;
        }
      }
      const dotRender = type === "dot" ? viewDot.call(fastify2, preProcessDot.call(fastify2, templatesDir, globalOptions)) : null;
      const renders = {
        ejs: withLayout(viewEjs, globalLayoutFileName),
        handlebars: withLayout(viewHandlebars, globalLayoutFileName),
        mustache: viewMustache,
        nunjucks: viewNunjucks,
        "art-template": viewArtTemplate,
        twig: viewTwig,
        liquid: viewLiquid,
        dot: withLayout(dotRender, globalLayoutFileName),
        eta: withLayout(viewEta, globalLayoutFileName),
        _default: view
      };
      const renderer = renders[type] ? renders[type] : renders._default;
      function viewDecorator() {
        const args2 = Array.from(arguments);
        let done;
        if (typeof args2[args2.length - 1] === "function") {
          done = args2.pop();
        }
        const promise = new Promise((resolve2, reject2) => {
          renderer.apply({
            getHeader: () => {
            },
            header: () => {
            },
            send: (result) => {
              if (result instanceof Error) {
                reject2(result);
                return;
              }
              resolve2(result);
            }
          }, args2);
        });
        if (done && typeof done === "function") {
          promise.then(done.bind(null, null), done);
          return;
        }
        return promise;
      }
      viewDecorator.clearCache = function() {
        lru.clear();
      };
      fastify2.decorate(propertyName, viewDecorator);
      fastify2.decorateReply(propertyName, function() {
        renderer.apply(this, arguments);
        return this;
      });
      function getPage(page, extension) {
        const pageLRU = `getPage-${page}-${extension}`;
        let result = lru.get(pageLRU);
        if (typeof result === "string") {
          return result;
        }
        const filename = basename(page, extname(page));
        result = join(dirname(page), filename + getExtension(page, extension));
        lru.set(pageLRU, result);
        return result;
      }
      function getDefaultExtension(type2) {
        const mappedExtensions = {
          "art-template": "art",
          handlebars: "hbs",
          nunjucks: "njk"
        };
        return viewExt || (mappedExtensions[type2] || type2);
      }
      function getExtension(page, extension) {
        let filextension = extname(page);
        if (!filextension) {
          filextension = "." + getDefaultExtension(type);
        }
        return viewExt ? `.${viewExt}` : includeViewExtension ? `.${extension}` : filextension;
      }
      function isPathExcludedMinification(currentPath, pathsToExclude) {
        return pathsToExclude && Array.isArray(pathsToExclude) ? pathsToExclude.includes(currentPath) : false;
      }
      function useHtmlMinification(globalOpts, requestedPath) {
        return globalOptions.useHtmlMinifier && typeof globalOptions.useHtmlMinifier.minify === "function" && !isPathExcludedMinification(requestedPath, globalOptions.pathsToExcludeHtmlMinifier);
      }
      function getRequestedPath(fastify3) {
        return fastify3 && fastify3.request ? fastify3.request.context.config.url : null;
      }
      const getTemplate = function(file, callback, requestedPath) {
        const data = lru.get(file);
        if (data && prod) {
          callback(null, data);
        } else {
          readFile(join(templatesDir, file), "utf-8", (err, data2) => {
            if (err) {
              callback(err, null);
              return;
            }
            if (useHtmlMinification(globalOptions, requestedPath)) {
              data2 = globalOptions.useHtmlMinifier.minify(data2, globalOptions.htmlMinifierOptions || {});
            }
            if (type === "handlebars") {
              data2 = engine.compile(data2);
            }
            lru.set(file, data2);
            callback(null, data2);
          });
        }
      };
      const getPartials = function(page, { partials, requestedPath }, callback) {
        const partialsObj = lru.get(`${page}-Partials`);
        if (partialsObj && prod) {
          callback(null, partialsObj);
        } else {
          let filesToLoad = Object.keys(partials).length;
          if (filesToLoad === 0) {
            callback(null, {});
            return;
          }
          let error = null;
          const partialsHtml = {};
          Object.keys(partials).forEach((key, index2) => {
            readFile(join(templatesDir, partials[key]), "utf-8", (err, data) => {
              if (err) {
                error = err;
              }
              if (useHtmlMinification(globalOptions, requestedPath)) {
                data = globalOptions.useHtmlMinifier.minify(data, globalOptions.htmlMinifierOptions || {});
              }
              partialsHtml[key] = data;
              if (--filesToLoad === 0) {
                lru.set(`${page}-Partials`, partialsHtml);
                callback(error, partialsHtml);
              }
            });
          });
        }
      };
      function readCallback(that, page, data) {
        return function _readCallback(err, html) {
          const requestedPath = getRequestedPath(that);
          if (err) {
            that.send(err);
            return;
          }
          let compiledPage;
          try {
            if (type === "ejs" && viewExt && !globalOptions.includer) {
              globalOptions.includer = (originalPath, parsedPath) => {
                return {
                  filename: parsedPath || join(templatesDir, originalPath + "." + viewExt)
                };
              };
            }
            globalOptions.filename = join(templatesDir, page);
            compiledPage = engine.compile(html, globalOptions);
          } catch (error) {
            that.send(error);
            return;
          }
          lru.set(page, compiledPage);
          if (!that.getHeader("content-type")) {
            that.header("Content-Type", "text/html; charset=" + charset);
          }
          let cachedPage;
          try {
            cachedPage = lru.get(page)(data);
          } catch (error) {
            cachedPage = error;
          }
          if (useHtmlMinification(globalOptions, requestedPath)) {
            cachedPage = globalOptions.useHtmlMinifier.minify(cachedPage, globalOptions.htmlMinifierOptions || {});
          }
          that.send(cachedPage);
        };
      }
      function preProcessDot(templatesDir2, options) {
        const destinationDir = options.destination || join(__dirname, "out");
        if (!existsSync(destinationDir)) {
          mkdirSync(destinationDir);
        }
        const renderer2 = engine.process(Object.assign({}, options, {
          path: templatesDir2,
          destination: destinationDir
        }));
        for (const file of readdirSync(destinationDir, { withFileTypes: false })) {
          renderer2[basename(file, ".js")] = __require(resolve(join(destinationDir, file)));
        }
        if (Object.keys(renderer2).length === 0) {
          this.log.warn(`WARN: no template found in ${templatesDir2}`);
        }
        return renderer2;
      }
      function view(page, data) {
        if (!page) {
          this.send(new Error("Missing page"));
          return;
        }
        data = Object.assign({}, defaultCtx, this.locals, data);
        page = getPage(page, type);
        const toHtml = lru.get(page);
        if (toHtml && prod) {
          if (!this.getHeader("content-type")) {
            this.header("Content-Type", "text/html; charset=" + charset);
          }
          this.send(toHtml(data));
          return;
        }
        readFile(join(templatesDir, page), "utf8", readCallback(this, page, data));
      }
      function viewEjs(page, data, opts2) {
        if (opts2 && opts2.layout) {
          try {
            layoutIsValid(opts2.layout);
            const that = this;
            return withLayout(viewEjs, opts2.layout).call(that, page, data);
          } catch (error) {
            this.send(error);
            return;
          }
        }
        if (!page) {
          this.send(new Error("Missing page"));
          return;
        }
        data = Object.assign({}, defaultCtx, this.locals, data);
        page = getPage(page, type);
        const requestedPath = getRequestedPath(this);
        getTemplate(page, (err, template) => {
          if (err) {
            this.send(err);
            return;
          }
          const toHtml = lru.get(page);
          if (toHtml && prod && typeof toHtml === "function") {
            if (!this.getHeader("content-type")) {
              this.header("Content-Type", "text/html; charset=" + charset);
            }
            this.send(toHtml(data));
            return;
          }
          readFile(join(templatesDir, page), "utf8", readCallback(this, page, data));
        }, requestedPath);
      }
      function viewArtTemplate(page, data) {
        if (!page) {
          this.send(new Error("Missing page"));
          return;
        }
        data = Object.assign({}, defaultCtx, this.locals, data);
        page = getPage(page, "art");
        const defaultSetting = {
          debug: process.env.NODE_ENV !== "production",
          root: templatesDir
        };
        const confs = Object.assign({}, defaultSetting, globalOptions);
        function render(filename, data2) {
          confs.filename = join(templatesDir, filename);
          const render2 = engine.compile(confs);
          return render2(data2);
        }
        try {
          const html = render(page, data);
          if (!this.getHeader("content-type")) {
            this.header("Content-Type", "text/html; charset=" + charset);
          }
          this.send(html);
        } catch (error) {
          this.send(error);
        }
      }
      function viewNunjucks(page, data) {
        if (!page) {
          this.send(new Error("Missing page"));
          return;
        }
        const env = engine.configure(templatesDir, globalOptions);
        if (typeof globalOptions.onConfigure === "function") {
          globalOptions.onConfigure(env);
        }
        data = Object.assign({}, defaultCtx, this.locals, data);
        page = getPage(page, "njk");
        env.render(join(templatesDir, page), data, (err, html) => {
          const requestedPath = getRequestedPath(this);
          if (err)
            return this.send(err);
          if (useHtmlMinification(globalOptions, requestedPath)) {
            html = globalOptions.useHtmlMinifier.minify(html, globalOptions.htmlMinifierOptions || {});
          }
          this.header("Content-Type", "text/html; charset=" + charset);
          this.send(html);
        });
      }
      function viewHandlebars(page, data, opts2) {
        if (opts2 && opts2.layout) {
          try {
            layoutIsValid(opts2.layout);
            const that = this;
            return withLayout(viewHandlebars, opts2.layout).call(that, page, data);
          } catch (error) {
            this.send(error);
            return;
          }
        }
        if (!page) {
          this.send(new Error("Missing page"));
          return;
        }
        const options = Object.assign({}, globalOptions);
        data = Object.assign({}, defaultCtx, this.locals, data);
        page = getPage(page, "hbs");
        const requestedPath = getRequestedPath(this);
        getTemplate(page, (err, template) => {
          if (err) {
            this.send(err);
            return;
          }
          if (prod) {
            try {
              const html = template(data);
              if (!this.getHeader("content-type")) {
                this.header("Content-Type", "text/html; charset=" + charset);
              }
              this.send(html);
            } catch (e) {
              this.send(e);
            }
          } else {
            getPartials(type, { partials: options.partials || {}, requestedPath }, (err2, partialsObject) => {
              if (err2) {
                this.send(err2);
                return;
              }
              try {
                Object.keys(partialsObject).forEach((name) => {
                  engine.registerPartial(name, engine.compile(partialsObject[name]));
                });
                const html = template(data);
                if (!this.getHeader("content-type")) {
                  this.header("Content-Type", "text/html; charset=" + charset);
                }
                this.send(html);
              } catch (e) {
                this.send(e);
              }
            });
          }
        }, requestedPath);
      }
      function viewMustache(page, data, opts2) {
        if (!page) {
          this.send(new Error("Missing page"));
          return;
        }
        const options = Object.assign({}, opts2);
        data = Object.assign({}, defaultCtx, this.locals, data);
        page = getPage(page, "mustache");
        const requestedPath = getRequestedPath(this);
        getTemplate(page, (err, templateString) => {
          if (err) {
            this.send(err);
            return;
          }
          getPartials(page, { partials: options.partials || {}, requestedPath }, (err2, partialsObject) => {
            if (err2) {
              this.send(err2);
              return;
            }
            const html = engine.render(templateString, data, partialsObject);
            if (!this.getHeader("content-type")) {
              this.header("Content-Type", "text/html; charset=" + charset);
            }
            this.send(html);
          });
        }, requestedPath);
      }
      function viewTwig(page, data, opts2) {
        if (!page) {
          this.send(new Error("Missing page"));
          return;
        }
        data = Object.assign({}, defaultCtx, globalOptions, this.locals, data);
        page = getPage(page, "twig");
        engine.renderFile(join(templatesDir, page), data, (err, html) => {
          const requestedPath = getRequestedPath(this);
          if (err) {
            return this.send(err);
          }
          if (useHtmlMinification(globalOptions, requestedPath)) {
            html = globalOptions.useHtmlMinifier.minify(html, globalOptions.htmlMinifierOptions || {});
          }
          if (!this.getHeader("content-type")) {
            this.header("Content-Type", "text/html; charset=" + charset);
          }
          this.send(html);
        });
      }
      function viewLiquid(page, data, opts2) {
        if (!page) {
          this.send(new Error("Missing page"));
          return;
        }
        data = Object.assign({}, defaultCtx, this.locals, data);
        page = getPage(page, "liquid");
        engine.renderFile(join(templatesDir, page), data, opts2).then((html) => {
          const requestedPath = getRequestedPath(this);
          if (useHtmlMinification(globalOptions, requestedPath)) {
            html = globalOptions.useHtmlMinifier.minify(html, globalOptions.htmlMinifierOptions || {});
          }
          if (!this.getHeader("content-type")) {
            this.header("Content-Type", "text/html; charset=" + charset);
          }
          this.send(html);
        }).catch((err) => {
          this.send(err);
        });
      }
      function viewDot(renderModule) {
        return function _viewDot(page, data, opts2) {
          if (opts2 && opts2.layout) {
            try {
              layoutIsValid(opts2.layout);
              const that = this;
              return withLayout(dotRender, opts2.layout).call(that, page, data);
            } catch (error) {
              this.send(error);
              return;
            }
          }
          if (!page) {
            this.send(new Error("Missing page"));
            return;
          }
          data = Object.assign({}, defaultCtx, this.locals, data);
          let html = renderModule[page](data);
          const requestedPath = getRequestedPath(this);
          if (useHtmlMinification(globalOptions, requestedPath)) {
            html = globalOptions.useHtmlMinifier.minify(html, globalOptions.htmlMinifierOptions || {});
          }
          if (!this.getHeader("content-type")) {
            this.header("Content-Type", "text/html; charset=" + charset);
          }
          this.send(html);
        };
      }
      function viewEta(page, data, opts2) {
        if (opts2 && opts2.layout) {
          try {
            layoutIsValid(opts2.layout);
            const that = this;
            return withLayout(viewEta, opts2.layout).call(that, page, data);
          } catch (error) {
            this.send(error);
            return;
          }
        }
        if (!page) {
          this.send(new Error("Missing page"));
          return;
        }
        lru.define = lru.set;
        engine.configure({
          templates: globalOptions.templates ? globalOptions.templates : lru
        });
        const config = Object.assign({
          cache: prod,
          views: templatesDir
        }, globalOptions);
        data = Object.assign({}, defaultCtx, this.locals, data);
        page = getPage(page, "eta");
        engine.renderFile(page, data, config, (err, html) => {
          if (err)
            return this.send(err);
          if (config.useHtmlMinifier && typeof config.useHtmlMinifier.minify === "function" && !isPathExcludedMinification(getRequestedPath(this), config.pathsToExcludeHtmlMinifier)) {
            html = config.useHtmlMinifier.minify(html, config.htmlMinifierOptions || {});
          }
          this.header("Content-Type", "text/html; charset=" + charset);
          this.send(html);
        });
      }
      if (prod && type === "handlebars" && globalOptions.partials) {
        getPartials(type, { partials: globalOptions.partials || {}, requestedPath: getRequestedPath(this) }, (err, partialsObject) => {
          if (err) {
            next(err);
            return;
          }
          Object.keys(partialsObject).forEach((name) => {
            engine.registerPartial(name, engine.compile(partialsObject[name]));
          });
          next();
        });
      } else {
        next();
      }
      function withLayout(render, layout) {
        if (layout) {
          return function(page, data, opts2) {
            if (opts2 && opts2.layout)
              throw new Error("A layout can either be set globally or on render, not both.");
            const that = this;
            data = Object.assign({}, defaultCtx, this.locals, data);
            render.call({
              getHeader: () => {
              },
              header: () => {
              },
              send: (result) => {
                if (result instanceof Error) {
                  throw result;
                }
                data = Object.assign(data || {}, { body: result });
                render.call(that, layout, data, opts2);
              }
            }, page, data, opts2);
          };
        }
        return render;
      }
      function hasAccessToLayoutFile(fileName, ext) {
        try {
          accessSync(join(templatesDir, getPage(fileName, ext)));
          return true;
        } catch (e) {
          return false;
        }
      }
    }
    module2.exports = fp(fastifyView, {
      fastify: "3.x",
      name: "point-of-view"
    });
  }
});

// packages/platform-fastify/node_modules/fastify-plugin/stackParser.js
var require_stackParser2 = __commonJS({
  "packages/platform-fastify/node_modules/fastify-plugin/stackParser.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var fpStackTracePattern = /at\s{1}(?:.*\.)?plugin\s{1}.*\n\s*(.*)/;
    var fileNamePattern = /(\w*(\.\w*)*)\..*/;
    module2.exports = function extractPluginName(stack2) {
      const m = stack2.match(fpStackTracePattern);
      return m ? m[1].split(/[/\\]/).slice(-1)[0].match(fileNamePattern)[1] : "anonymous";
    };
  }
});

// packages/platform-fastify/node_modules/fastify-plugin/plugin.js
var require_plugin3 = __commonJS({
  "packages/platform-fastify/node_modules/fastify-plugin/plugin.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var extractPluginName = require_stackParser2();
    var count = 0;
    function plugin(fn2, options = {}) {
      let autoName = false;
      if (typeof fn2.default !== "undefined") {
        fn2 = fn2.default;
      }
      if (typeof fn2 !== "function") {
        throw new TypeError(`fastify-plugin expects a function, instead got a '${typeof fn2}'`);
      }
      fn2[Symbol.for("skip-override")] = true;
      const pluginName = options && options.name || checkName(fn2);
      if (typeof options === "string") {
        options = {
          fastify: options
        };
      }
      if (typeof options !== "object" || Array.isArray(options) || options === null) {
        throw new TypeError("The options object should be an object");
      }
      if (options.fastify !== void 0 && typeof options.fastify !== "string") {
        throw new TypeError(`fastify-plugin expects a version string, instead got '${typeof options.fastify}'`);
      }
      if (!options.name) {
        autoName = true;
        options.name = pluginName + "-auto-" + count++;
      }
      fn2[Symbol.for("fastify.display-name")] = options.name;
      fn2[Symbol.for("plugin-meta")] = options;
      if (!fn2.default) {
        fn2.default = fn2;
      }
      const camelCase = toCamelCase(options.name);
      if (!autoName && !fn2[camelCase]) {
        fn2[camelCase] = fn2;
      }
      return fn2;
    }
    function checkName(fn2) {
      if (fn2.name.length > 0)
        return fn2.name;
      try {
        throw new Error("anonymous function");
      } catch (e) {
        return extractPluginName(e.stack);
      }
    }
    function toCamelCase(name) {
      const newName = name.replace(/-(.)/g, function(match, g1) {
        return g1.toUpperCase();
      });
      return newName;
    }
    plugin.default = plugin;
    module2.exports = plugin;
  }
});

// packages/platform-fastify/node_modules/vary/index.js
var require_vary = __commonJS({
  "packages/platform-fastify/node_modules/vary/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    module2.exports = vary;
    module2.exports.append = append;
    var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
    function append(header, field) {
      if (typeof header !== "string") {
        throw new TypeError("header argument is required");
      }
      if (!field) {
        throw new TypeError("field argument is required");
      }
      var fields = !Array.isArray(field) ? parse(String(field)) : field;
      for (var j = 0; j < fields.length; j++) {
        if (!FIELD_NAME_REGEXP.test(fields[j])) {
          throw new TypeError("field argument contains an invalid header name");
        }
      }
      if (header === "*") {
        return header;
      }
      var val = header;
      var vals = parse(header.toLowerCase());
      if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
        return "*";
      }
      for (var i = 0; i < fields.length; i++) {
        var fld = fields[i].toLowerCase();
        if (vals.indexOf(fld) === -1) {
          vals.push(fld);
          val = val ? val + ", " + fields[i] : fields[i];
        }
      }
      return val;
    }
    function parse(header) {
      var end = 0;
      var list = [];
      var start = 0;
      for (var i = 0, len = header.length; i < len; i++) {
        switch (header.charCodeAt(i)) {
          case 32:
            if (start === end) {
              start = end = i + 1;
            }
            break;
          case 44:
            list.push(header.substring(start, end));
            start = end = i + 1;
            break;
          default:
            end = i + 1;
            break;
        }
      }
      list.push(header.substring(start, end));
      return list;
    }
    function vary(res, field) {
      if (!res || !res.getHeader || !res.setHeader) {
        throw new TypeError("res argument is required");
      }
      var val = res.getHeader("Vary") || "";
      var header = Array.isArray(val) ? val.join(", ") : String(val);
      if (val = append(header, field)) {
        res.setHeader("Vary", val);
      }
    }
  }
});

// packages/platform-fastify/node_modules/fastify-cors/vary.js
var require_vary2 = __commonJS({
  "packages/platform-fastify/node_modules/fastify-cors/vary.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var append = require_vary().append;
    module2.exports = function vary(reply, field) {
      let value = reply.getHeader("Vary") || "";
      const header = Array.isArray(value) ? value.join(", ") : String(value);
      if (value = append(header, field)) {
        reply.header("Vary", value);
      }
    };
  }
});

// packages/platform-fastify/node_modules/fastify-cors/index.js
var require_fastify_cors = __commonJS({
  "packages/platform-fastify/node_modules/fastify-cors/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var fp = require_plugin3();
    var vary = require_vary2();
    var defaultOptions = {
      origin: "*",
      methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
      preflightContinue: false,
      optionsSuccessStatus: 204,
      credentials: false,
      exposedHeaders: null,
      allowedHeaders: null,
      maxAge: null,
      preflight: true,
      strictPreflight: true
    };
    function fastifyCors(fastify2, opts, next) {
      fastify2.decorateRequest("corsPreflightEnabled", false);
      let hideOptionsRoute = true;
      if (typeof opts === "function") {
        handleCorsOptionsDelegator(opts, fastify2);
      } else {
        if (opts.hideOptionsRoute !== void 0)
          hideOptionsRoute = opts.hideOptionsRoute;
        const corsOptions = Object.assign({}, defaultOptions, opts);
        fastify2.addHook("onRequest", (req, reply, next2) => {
          onRequest(fastify2, corsOptions, req, reply, next2);
        });
      }
      fastify2.options("*", { schema: { hide: hideOptionsRoute } }, (req, reply) => {
        if (!req.corsPreflightEnabled) {
          reply.callNotFound();
          return;
        }
        reply.send();
      });
      next();
    }
    function handleCorsOptionsDelegator(optionsResolver, fastify2) {
      fastify2.addHook("onRequest", (req, reply, next) => {
        if (optionsResolver.length === 2) {
          handleCorsOptionsCallbackDelegator(optionsResolver, fastify2, req, reply, next);
          return;
        } else {
          const ret = optionsResolver(req);
          if (ret && typeof ret.then === "function") {
            ret.then((options) => Object.assign({}, defaultOptions, options)).then((corsOptions) => onRequest(fastify2, corsOptions, req, reply, next)).catch(next);
            return;
          }
        }
        next(new Error("Invalid CORS origin option"));
      });
    }
    function handleCorsOptionsCallbackDelegator(optionsResolver, fastify2, req, reply, next) {
      optionsResolver(req, (err, options) => {
        if (err) {
          next(err);
        } else {
          const corsOptions = Object.assign({}, defaultOptions, options);
          onRequest(fastify2, corsOptions, req, reply, next);
        }
      });
    }
    function onRequest(fastify2, options, req, reply, next) {
      vary(reply, "Origin");
      const resolveOriginOption = typeof options.origin === "function" ? resolveOriginWrapper(fastify2, options.origin) : (_, cb) => cb(null, options.origin);
      resolveOriginOption(req, (error, resolvedOriginOption) => {
        if (error !== null) {
          return next(error);
        }
        if (resolvedOriginOption === false) {
          return next();
        }
        if (!resolvedOriginOption) {
          return next(new Error("Invalid CORS origin option"));
        }
        addCorsHeaders(req, reply, resolvedOriginOption, options);
        if (req.raw.method === "OPTIONS" && options.preflight === true) {
          if (options.strictPreflight === true && (!req.headers.origin || !req.headers["access-control-request-method"])) {
            reply.status(400).type("text/plain").send("Invalid Preflight Request");
            return;
          }
          req.corsPreflightEnabled = true;
          addPreflightHeaders(req, reply, options);
          if (!options.preflightContinue) {
            reply.code(options.optionsSuccessStatus).header("Content-Length", "0").send();
            return;
          }
        }
        return next();
      });
    }
    function addCorsHeaders(req, reply, originOption, corsOptions) {
      const origin = getAccessControlAllowOriginHeader(req.headers.origin, originOption);
      if (origin) {
        reply.header("Access-Control-Allow-Origin", origin);
      }
      if (corsOptions.credentials) {
        reply.header("Access-Control-Allow-Credentials", "true");
      }
      if (corsOptions.exposedHeaders !== null) {
        reply.header("Access-Control-Expose-Headers", Array.isArray(corsOptions.exposedHeaders) ? corsOptions.exposedHeaders.join(", ") : corsOptions.exposedHeaders);
      }
    }
    function addPreflightHeaders(req, reply, corsOptions) {
      reply.header("Access-Control-Allow-Methods", Array.isArray(corsOptions.methods) ? corsOptions.methods.join(", ") : corsOptions.methods);
      if (corsOptions.allowedHeaders === null) {
        vary(reply, "Access-Control-Request-Headers");
        const reqAllowedHeaders = req.headers["access-control-request-headers"];
        if (reqAllowedHeaders !== void 0) {
          reply.header("Access-Control-Allow-Headers", reqAllowedHeaders);
        }
      } else {
        reply.header("Access-Control-Allow-Headers", Array.isArray(corsOptions.allowedHeaders) ? corsOptions.allowedHeaders.join(", ") : corsOptions.allowedHeaders);
      }
      if (corsOptions.maxAge !== null) {
        reply.header("Access-Control-Max-Age", String(corsOptions.maxAge));
      }
    }
    function resolveOriginWrapper(fastify2, origin) {
      return function(req, cb) {
        const result = origin.call(fastify2, req.headers.origin, cb);
        if (result && typeof result.then === "function") {
          result.then((res) => cb(null, res), cb);
        }
      };
    }
    function getAccessControlAllowOriginHeader(reqOrigin, originOption) {
      if (originOption === "*") {
        return "*";
      }
      if (typeof originOption === "string") {
        return originOption;
      }
      return isRequestOriginAllowed(reqOrigin, originOption) ? reqOrigin : false;
    }
    function isRequestOriginAllowed(reqOrigin, allowedOrigin) {
      if (Array.isArray(allowedOrigin)) {
        for (let i = 0; i < allowedOrigin.length; ++i) {
          if (isRequestOriginAllowed(reqOrigin, allowedOrigin[i])) {
            return true;
          }
        }
        return false;
      } else if (typeof allowedOrigin === "string") {
        return reqOrigin === allowedOrigin;
      } else if (allowedOrigin instanceof RegExp) {
        allowedOrigin.lastIndex = 0;
        return allowedOrigin.test(reqOrigin);
      } else {
        return !!allowedOrigin;
      }
    }
    module2.exports = fp(fastifyCors, {
      fastify: "3.x",
      name: "fastify-cors"
    });
  }
});

// packages/platform-fastify/node_modules/fastify-formbody/formbody.js
var require_formbody = __commonJS({
  "packages/platform-fastify/node_modules/fastify-formbody/formbody.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var fp = require_plugin3();
    var { parse } = __require("querystring");
    function defaultParser(str) {
      return parse(str);
    }
    function formBodyPlugin(fastify2, options, next) {
      const opts = Object.assign({ parser: defaultParser }, options);
      if (typeof opts.parser !== "function") {
        next(new Error("parser must be a function"));
        return;
      }
      function contentParser(req, body, done) {
        done(null, opts.parser(body.toString()));
      }
      fastify2.addContentTypeParser("application/x-www-form-urlencoded", { parseAs: "buffer", bodyLimit: opts.bodyLimit }, contentParser);
      next();
    }
    module2.exports = fp(formBodyPlugin, {
      fastify: "^3.0.0",
      name: "fastify-formbody"
    });
  }
});

// packages/platform-fastify/node_modules/middie/engine.js
var require_engine = __commonJS({
  "packages/platform-fastify/node_modules/middie/engine.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var reusify = require_reusify();
    var { pathToRegexp } = __require("path-to-regexp");
    function middie(complete) {
      const middlewares = [];
      const pool = reusify(Holder);
      return {
        use,
        run
      };
      function use(url, f) {
        if (f === void 0) {
          f = url;
          url = null;
        }
        let regexp;
        if (url) {
          regexp = pathToRegexp(sanitizePrefixUrl(url), [], {
            end: false,
            strict: false
          });
        }
        if (Array.isArray(f)) {
          for (const val of f) {
            middlewares.push({
              regexp,
              fn: val
            });
          }
        } else {
          middlewares.push({
            regexp,
            fn: f
          });
        }
        return this;
      }
      function run(req, res, ctx) {
        if (!middlewares.length) {
          complete(null, req, res, ctx);
          return;
        }
        req.originalUrl = req.url;
        const holder = pool.get();
        holder.req = req;
        holder.res = res;
        holder.url = sanitizeUrl(req.url);
        holder.context = ctx;
        holder.done();
      }
      function Holder() {
        this.next = null;
        this.req = null;
        this.res = null;
        this.url = null;
        this.context = null;
        this.i = 0;
        const that = this;
        this.done = function(err) {
          const req = that.req;
          const res = that.res;
          const url = that.url;
          const context = that.context;
          const i = that.i++;
          req.url = req.originalUrl;
          if (res.finished === true) {
            that.req = null;
            that.res = null;
            that.context = null;
            that.i = 0;
            pool.release(that);
            return;
          }
          if (err || middlewares.length === i) {
            complete(err, req, res, context);
            that.req = null;
            that.res = null;
            that.context = null;
            that.i = 0;
            pool.release(that);
          } else {
            const middleware = middlewares[i];
            const fn2 = middleware.fn;
            const regexp = middleware.regexp;
            if (regexp) {
              const result = regexp.exec(url);
              if (result) {
                req.url = req.url.replace(result[0], "");
                if (req.url.startsWith("/") === false) {
                  req.url = "/" + req.url;
                }
                fn2(req, res, that.done);
              } else {
                that.done();
              }
            } else {
              fn2(req, res, that.done);
            }
          }
        };
      }
    }
    function sanitizeUrl(url) {
      for (var i = 0, len = url.length; i < len; i++) {
        const charCode = url.charCodeAt(i);
        if (charCode === 63 || charCode === 35) {
          return url.slice(0, i);
        }
      }
      return url;
    }
    function sanitizePrefixUrl(url) {
      if (url === "")
        return url;
      if (url === "/")
        return "";
      if (url[url.length - 1] === "/")
        return url.slice(0, -1);
      return url;
    }
    module2.exports = middie;
  }
});

// packages/platform-fastify/node_modules/middie/index.js
var require_middie = __commonJS({
  "packages/platform-fastify/node_modules/middie/index.js"(exports2, module2) {
    "use strict";
    init_esm_shims();
    var fp = require_plugin3();
    var symbols = require_symbols();
    var Middie = require_engine();
    var kMiddlewares = Symbol("fastify-middie-middlewares");
    var kMiddie = Symbol("fastify-middie-instance");
    function middiePlugin(fastify2, options, next) {
      fastify2.decorate("use", use);
      fastify2[kMiddlewares] = [];
      fastify2[kMiddie] = Middie(onMiddieEnd);
      fastify2.addHook(options.hook || "onRequest", runMiddie).addHook("onRegister", onRegister);
      function use(path2, fn2) {
        if (typeof path2 === "string") {
          const prefix = this[symbols.kRoutePrefix];
          path2 = prefix + (path2 === "/" && prefix.length > 0 ? "" : path2);
        }
        this[kMiddlewares].push([path2, fn2]);
        if (fn2 == null) {
          this[kMiddie].use(path2);
        } else {
          this[kMiddie].use(path2, fn2);
        }
        return this;
      }
      function runMiddie(req, reply, next2) {
        if (this[kMiddlewares].length > 0) {
          req.raw.originalUrl = req.raw.url;
          req.raw.id = req.id;
          req.raw.hostname = req.hostname;
          req.raw.ip = req.ip;
          req.raw.ips = req.ips;
          req.raw.log = req.log;
          req.raw.body = req.body;
          req.raw.query = req.query;
          reply.raw.log = req.log;
          this[kMiddie].run(req.raw, reply.raw, next2);
        } else {
          next2();
        }
      }
      function onMiddieEnd(err, req, res, next2) {
        next2(err);
      }
      function onRegister(instance) {
        const middlewares = instance[kMiddlewares].slice();
        instance[kMiddlewares] = [];
        instance[kMiddie] = Middie(onMiddieEnd);
        instance.decorate("use", use);
        for (const middleware of middlewares) {
          instance.use(...middleware);
        }
      }
      next();
    }
    module2.exports = fp(middiePlugin, {
      fastify: ">=3.0.0",
      name: "middie"
    });
  }
});

// packages/platform-fastify/index.ts
init_esm_shims();

// packages/platform-fastify/adapters/index.ts
init_esm_shims();

// packages/platform-fastify/adapters/fastify-adapter.ts
init_esm_shims();

// packages/common/index.ts
init_esm_shims();
import "reflect-metadata";

// packages/common/cache/index.ts
init_esm_shims();

// packages/common/cache/cache.constants.ts
init_esm_shims();
var CACHE_MANAGER = "CACHE_MANAGER";
var CACHE_MODULE_OPTIONS = "CACHE_MODULE_OPTIONS";
var CACHE_KEY_METADATA = "cache_module:cache_key";
var CACHE_TTL_METADATA = "cache_module:cache_ttl";

// packages/common/cache/cache.module.ts
init_esm_shims();

// packages/common/decorators/index.ts
init_esm_shims();

// packages/common/decorators/core/index.ts
init_esm_shims();

// packages/common/decorators/core/bind.decorator.ts
init_esm_shims();

// packages/common/decorators/core/catch.decorator.ts
init_esm_shims();

// packages/common/constants.ts
init_esm_shims();
var MODULE_METADATA = {
  IMPORTS: "imports",
  PROVIDERS: "providers",
  CONTROLLERS: "controllers",
  EXPORTS: "exports"
};
var PATH_METADATA = "path";
var SELF_DECLARED_DEPS_METADATA = "self:paramtypes";
var OPTIONAL_DEPS_METADATA = "optional:paramtypes";
var PROPERTY_DEPS_METADATA = "self:properties_metadata";
var OPTIONAL_PROPERTY_DEPS_METADATA = "optional:properties_metadata";
var SCOPE_OPTIONS_METADATA = "scope:options";
var METHOD_METADATA = "method";
var ROUTE_ARGS_METADATA = "__routeArguments__";
var INJECTABLE_WATERMARK = "__injectable__";

// packages/common/decorators/core/controller.decorator.ts
init_esm_shims();

// packages/common/utils/shared.utils.ts
init_esm_shims();
var isUndefined = (obj) => typeof obj === "undefined";
var isObject = (fn2) => !isNil(fn2) && typeof fn2 === "object";
var isPlainObject = (fn2) => {
  if (!isObject(fn2)) {
    return false;
  }
  const proto = Object.getPrototypeOf(fn2);
  if (proto === null) {
    return true;
  }
  const ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
};
var isFunction = (val) => typeof val === "function";
var isString = (val) => typeof val === "string";
var isNumber = (val) => typeof val === "number";
var isNil = (val) => isUndefined(val) || val === null;

// packages/common/decorators/core/dependencies.decorator.ts
init_esm_shims();

// packages/common/decorators/core/exception-filters.decorator.ts
init_esm_shims();

// packages/common/utils/extend-metadata.util.ts
init_esm_shims();

// packages/common/utils/validate-each.util.ts
init_esm_shims();

// packages/common/decorators/core/inject.decorator.ts
init_esm_shims();
function Inject(token) {
  return (target, key, index2) => {
    const type = token || Reflect.getMetadata("design:type", target, key);
    if (!isUndefined(index2)) {
      let dependencies = Reflect.getMetadata(SELF_DECLARED_DEPS_METADATA, target) || [];
      dependencies = [...dependencies, { index: index2, param: type }];
      Reflect.defineMetadata(SELF_DECLARED_DEPS_METADATA, dependencies, target);
      return;
    }
    let properties = Reflect.getMetadata(PROPERTY_DEPS_METADATA, target.constructor) || [];
    properties = [...properties, { key, type }];
    Reflect.defineMetadata(PROPERTY_DEPS_METADATA, properties, target.constructor);
  };
}

// packages/common/decorators/core/injectable.decorator.ts
init_esm_shims();
import { v4 as uuid } from "uuid";
function Injectable(options) {
  return (target) => {
    Reflect.defineMetadata(INJECTABLE_WATERMARK, true, target);
    Reflect.defineMetadata(SCOPE_OPTIONS_METADATA, options, target);
  };
}

// packages/common/decorators/core/optional.decorator.ts
init_esm_shims();
function Optional() {
  return (target, key, index2) => {
    if (!isUndefined(index2)) {
      const args2 = Reflect.getMetadata(OPTIONAL_DEPS_METADATA, target) || [];
      Reflect.defineMetadata(OPTIONAL_DEPS_METADATA, [...args2, index2], target);
      return;
    }
    const properties = Reflect.getMetadata(OPTIONAL_PROPERTY_DEPS_METADATA, target.constructor) || [];
    Reflect.defineMetadata(OPTIONAL_PROPERTY_DEPS_METADATA, [...properties, key], target.constructor);
  };
}

// packages/common/decorators/core/set-metadata.decorator.ts
init_esm_shims();

// packages/common/decorators/core/use-guards.decorator.ts
init_esm_shims();

// packages/common/decorators/core/use-interceptors.decorator.ts
init_esm_shims();

// packages/common/decorators/core/use-pipes.decorator.ts
init_esm_shims();

// packages/common/decorators/core/apply-decorators.ts
init_esm_shims();

// packages/common/decorators/core/version.decorator.ts
init_esm_shims();

// packages/common/decorators/modules/index.ts
init_esm_shims();

// packages/common/decorators/modules/global.decorator.ts
init_esm_shims();

// packages/common/decorators/modules/module.decorator.ts
init_esm_shims();

// packages/common/utils/validate-module-keys.util.ts
init_esm_shims();
var INVALID_MODULE_CONFIG_MESSAGE = (text, property) => `Invalid property '${property}' passed into the @Module() decorator.`;
var metadataKeys = [
  MODULE_METADATA.IMPORTS,
  MODULE_METADATA.EXPORTS,
  MODULE_METADATA.CONTROLLERS,
  MODULE_METADATA.PROVIDERS
];
function validateModuleKeys(keys) {
  const validateKey = (key) => {
    if (metadataKeys.includes(key)) {
      return;
    }
    throw new Error(INVALID_MODULE_CONFIG_MESSAGE`${key}`);
  };
  keys.forEach(validateKey);
}

// packages/common/decorators/modules/module.decorator.ts
function Module(metadata) {
  const propsKeys = Object.keys(metadata);
  validateModuleKeys(propsKeys);
  return (target) => {
    for (const property in metadata) {
      if (metadata.hasOwnProperty(property)) {
        Reflect.defineMetadata(property, metadata[property], target);
      }
    }
  };
}

// packages/common/decorators/http/index.ts
init_esm_shims();

// packages/common/decorators/http/request-mapping.decorator.ts
init_esm_shims();

// packages/common/enums/request-method.enum.ts
init_esm_shims();

// packages/common/decorators/http/request-mapping.decorator.ts
var defaultMetadata = {
  [PATH_METADATA]: "/",
  [METHOD_METADATA]: 0 /* GET */
};
var RequestMapping = (metadata = defaultMetadata) => {
  const pathMetadata = metadata[PATH_METADATA];
  const path2 = pathMetadata && pathMetadata.length ? pathMetadata : "/";
  const requestMethod = metadata[METHOD_METADATA] || 0 /* GET */;
  return (target, key, descriptor) => {
    Reflect.defineMetadata(PATH_METADATA, path2, descriptor.value);
    Reflect.defineMetadata(METHOD_METADATA, requestMethod, descriptor.value);
    return descriptor;
  };
};
var createMappingDecorator = (method) => (path2) => {
  return RequestMapping({
    [PATH_METADATA]: path2,
    [METHOD_METADATA]: method
  });
};
var Post = createMappingDecorator(1 /* POST */);
var Get = createMappingDecorator(0 /* GET */);
var Delete = createMappingDecorator(3 /* DELETE */);
var Put = createMappingDecorator(2 /* PUT */);
var Patch = createMappingDecorator(4 /* PATCH */);
var Options = createMappingDecorator(6 /* OPTIONS */);
var Head = createMappingDecorator(7 /* HEAD */);
var All = createMappingDecorator(5 /* ALL */);

// packages/common/decorators/http/route-params.decorator.ts
init_esm_shims();

// packages/common/enums/route-paramtypes.enum.ts
init_esm_shims();

// packages/common/decorators/http/route-params.decorator.ts
function assignMetadata(args2, paramtype, index2, data, ...pipes) {
  return __spreadProps(__spreadValues({}, args2), {
    [`${paramtype}:${index2}`]: {
      index: index2,
      data,
      pipes
    }
  });
}
function createRouteParamDecorator(paramtype) {
  return (data) => (target, key, index2) => {
    const args2 = Reflect.getMetadata(ROUTE_ARGS_METADATA, target.constructor, key) || {};
    Reflect.defineMetadata(ROUTE_ARGS_METADATA, assignMetadata(args2, paramtype, index2, data), target.constructor, key);
  };
}
var Request = createRouteParamDecorator(0 /* REQUEST */);
var Next = createRouteParamDecorator(2 /* NEXT */);
var Ip = createRouteParamDecorator(11 /* IP */);
var Session = createRouteParamDecorator(7 /* SESSION */);
var Headers = createRouteParamDecorator(6 /* HEADERS */);

// packages/common/decorators/http/http-code.decorator.ts
init_esm_shims();

// packages/common/decorators/http/create-route-param-metadata.decorator.ts
init_esm_shims();
import { v4 as uuid2 } from "uuid";

// packages/common/utils/assign-custom-metadata.util.ts
init_esm_shims();

// packages/common/decorators/http/render.decorator.ts
init_esm_shims();

// packages/common/decorators/http/header.decorator.ts
init_esm_shims();

// packages/common/decorators/http/redirect.decorator.ts
init_esm_shims();

// packages/common/decorators/http/sse.decorator.ts
init_esm_shims();

// packages/common/cache/cache.providers.ts
init_esm_shims();

// packages/common/utils/load-package.util.ts
init_esm_shims();

// packages/common/services/logger.service.ts
init_esm_shims();

// packages/common/services/console-logger.service.ts
init_esm_shims();

// packages/common/utils/cli-colors.util.ts
init_esm_shims();
import { WriteStream } from "tty";
var isColorAllowed = () => !process.env.NO_COLOR && WriteStream.prototype.hasColors();
var colorIfAllowed = (colorFn) => (text) => isColorAllowed() ? colorFn(text) : text;
var clc = {
  green: colorIfAllowed((text) => `\x1B[32m${text}\x1B[39m`),
  yellow: colorIfAllowed((text) => `\x1B[33m${text}\x1B[39m`),
  red: colorIfAllowed((text) => `\x1B[31m${text}\x1B[39m`),
  magentaBright: colorIfAllowed((text) => `\x1B[95m${text}\x1B[39m`),
  cyanBright: colorIfAllowed((text) => `\x1B[96m${text}\x1B[39m`)
};
var yellow = colorIfAllowed((text) => `\x1B[38;5;3m${text}\x1B[39m`);

// packages/common/services/utils/index.ts
init_esm_shims();

// packages/common/services/utils/is-log-level-enabled.util.ts
init_esm_shims();
var LOG_LEVEL_VALUES = {
  debug: 0,
  verbose: 1,
  log: 2,
  warn: 3,
  error: 4
};
function isLogLevelEnabled(targetLevel, logLevels) {
  var _a;
  if (!logLevels || Array.isArray(logLevels) && (logLevels == null ? void 0 : logLevels.length) === 0) {
    return false;
  }
  if (logLevels.includes(targetLevel)) {
    return true;
  }
  const highestLogLevelValue = (_a = logLevels.map((level) => LOG_LEVEL_VALUES[level]).sort((a, b) => b - a)) == null ? void 0 : _a[0];
  const targetLevelValue = LOG_LEVEL_VALUES[targetLevel];
  return targetLevelValue >= highestLogLevelValue;
}

// packages/common/services/console-logger.service.ts
var DEFAULT_LOG_LEVELS = [
  "log",
  "error",
  "warn",
  "debug",
  "verbose"
];
var ConsoleLogger = class {
  constructor(context, options = {}) {
    this.context = context;
    this.options = options;
    if (!options.logLevels) {
      options.logLevels = DEFAULT_LOG_LEVELS;
    }
    if (context) {
      this.originalContext = context;
    }
  }
  log(message2, ...optionalParams) {
    if (!this.isLevelEnabled("log")) {
      return;
    }
    const { messages, context } = this.getContextAndMessagesToPrint([
      message2,
      ...optionalParams
    ]);
    this.printMessages(messages, context, "log");
  }
  error(message2, ...optionalParams) {
    if (!this.isLevelEnabled("error")) {
      return;
    }
    const { messages, context, stack: stack2 } = this.getContextAndStackAndMessagesToPrint([message2, ...optionalParams]);
    this.printMessages(messages, context, "error", "stderr");
    this.printStackTrace(stack2);
  }
  warn(message2, ...optionalParams) {
    if (!this.isLevelEnabled("warn")) {
      return;
    }
    const { messages, context } = this.getContextAndMessagesToPrint([
      message2,
      ...optionalParams
    ]);
    this.printMessages(messages, context, "warn");
  }
  debug(message2, ...optionalParams) {
    if (!this.isLevelEnabled("debug")) {
      return;
    }
    const { messages, context } = this.getContextAndMessagesToPrint([
      message2,
      ...optionalParams
    ]);
    this.printMessages(messages, context, "debug");
  }
  verbose(message2, ...optionalParams) {
    if (!this.isLevelEnabled("verbose")) {
      return;
    }
    const { messages, context } = this.getContextAndMessagesToPrint([
      message2,
      ...optionalParams
    ]);
    this.printMessages(messages, context, "verbose");
  }
  setLogLevels(levels) {
    if (!this.options) {
      this.options = {};
    }
    this.options.logLevels = levels;
  }
  setContext(context) {
    this.context = context;
  }
  resetContext() {
    this.context = this.originalContext;
  }
  isLevelEnabled(level) {
    var _a;
    const logLevels = (_a = this.options) == null ? void 0 : _a.logLevels;
    return isLogLevelEnabled(level, logLevels);
  }
  getTimestamp() {
    const localeStringOptions = {
      year: "numeric",
      hour: "numeric",
      minute: "numeric",
      second: "numeric",
      day: "2-digit",
      month: "2-digit"
    };
    return new Date(Date.now()).toLocaleString(void 0, localeStringOptions);
  }
  printMessages(messages, context = "", logLevel = "log", writeStreamType) {
    messages.forEach((message2) => {
      const pidMessage = this.formatPid(process.pid);
      const contextMessage = context ? yellow(`[${context}] `) : "";
      const timestampDiff = this.updateAndGetTimestampDiff();
      const formattedLogLevel = logLevel.toUpperCase().padStart(7, " ");
      const formatedMessage = this.formatMessage(logLevel, message2, pidMessage, formattedLogLevel, contextMessage, timestampDiff);
      process[writeStreamType != null ? writeStreamType : "stdout"].write(formatedMessage);
    });
  }
  formatPid(pid) {
    return `[Nest] ${pid}  - `;
  }
  formatMessage(logLevel, message2, pidMessage, formattedLogLevel, contextMessage, timestampDiff) {
    const output = this.stringifyMessage(message2, logLevel);
    pidMessage = this.colorize(pidMessage, logLevel);
    formattedLogLevel = this.colorize(formattedLogLevel, logLevel);
    return `${pidMessage}${this.getTimestamp()} ${formattedLogLevel} ${contextMessage}${output}${timestampDiff}
`;
  }
  stringifyMessage(message2, logLevel) {
    return isPlainObject(message2) ? `${this.colorize("Object:", logLevel)}
${JSON.stringify(message2, (key, value) => typeof value === "bigint" ? value.toString() : value, 2)}
` : this.colorize(message2, logLevel);
  }
  colorize(message2, logLevel) {
    const color = this.getColorByLogLevel(logLevel);
    return color(message2);
  }
  printStackTrace(stack2) {
    if (!stack2) {
      return;
    }
    process.stderr.write(`${stack2}
`);
  }
  updateAndGetTimestampDiff() {
    var _a;
    const includeTimestamp = ConsoleLogger.lastTimestampAt && ((_a = this.options) == null ? void 0 : _a.timestamp);
    const result = includeTimestamp ? yellow(` +${Date.now() - ConsoleLogger.lastTimestampAt}ms`) : "";
    ConsoleLogger.lastTimestampAt = Date.now();
    return result;
  }
  getContextAndMessagesToPrint(args2) {
    if ((args2 == null ? void 0 : args2.length) <= 1) {
      return { messages: args2, context: this.context };
    }
    const lastElement = args2[args2.length - 1];
    const isContext = isString(lastElement);
    if (!isContext) {
      return { messages: args2, context: this.context };
    }
    return {
      context: lastElement,
      messages: args2.slice(0, args2.length - 1)
    };
  }
  getContextAndStackAndMessagesToPrint(args2) {
    const { messages, context } = this.getContextAndMessagesToPrint(args2);
    if ((messages == null ? void 0 : messages.length) <= 1) {
      return { messages, context };
    }
    const lastElement = messages[messages.length - 1];
    const isStack = isString(lastElement);
    if (!isStack) {
      return { messages, context };
    }
    return {
      stack: lastElement,
      messages: messages.slice(0, messages.length - 1),
      context
    };
  }
  getColorByLogLevel(level) {
    switch (level) {
      case "debug":
        return clc.magentaBright;
      case "warn":
        return clc.yellow;
      case "error":
        return clc.red;
      case "verbose":
        return clc.cyanBright;
      default:
        return clc.green;
    }
  }
};
ConsoleLogger = __decorateClass([
  Injectable(),
  __decorateParam(0, Optional()),
  __decorateParam(1, Optional())
], ConsoleLogger);

// packages/common/services/logger.service.ts
var DEFAULT_LOGGER = new ConsoleLogger();
var Logger = class {
  constructor(context, options = {}) {
    this.context = context;
    this.options = options;
  }
  get localInstance() {
    if (Logger.staticInstanceRef === DEFAULT_LOGGER) {
      return this.registerLocalInstanceRef();
    } else if (Logger.staticInstanceRef instanceof Logger) {
      const prototype = Object.getPrototypeOf(Logger.staticInstanceRef);
      if (prototype.constructor === Logger) {
        return this.registerLocalInstanceRef();
      }
    }
    return Logger.staticInstanceRef;
  }
  error(message2, ...optionalParams) {
    var _a;
    optionalParams = this.context ? optionalParams.concat(this.context) : optionalParams;
    (_a = this.localInstance) == null ? void 0 : _a.error(message2, ...optionalParams);
  }
  log(message2, ...optionalParams) {
    var _a;
    optionalParams = this.context ? optionalParams.concat(this.context) : optionalParams;
    (_a = this.localInstance) == null ? void 0 : _a.log(message2, ...optionalParams);
  }
  warn(message2, ...optionalParams) {
    var _a;
    optionalParams = this.context ? optionalParams.concat(this.context) : optionalParams;
    (_a = this.localInstance) == null ? void 0 : _a.warn(message2, ...optionalParams);
  }
  debug(message2, ...optionalParams) {
    var _a, _b;
    optionalParams = this.context ? optionalParams.concat(this.context) : optionalParams;
    (_b = (_a = this.localInstance) == null ? void 0 : _a.debug) == null ? void 0 : _b.call(_a, message2, ...optionalParams);
  }
  verbose(message2, ...optionalParams) {
    var _a, _b;
    optionalParams = this.context ? optionalParams.concat(this.context) : optionalParams;
    (_b = (_a = this.localInstance) == null ? void 0 : _a.verbose) == null ? void 0 : _b.call(_a, message2, ...optionalParams);
  }
  static error(message2, ...optionalParams) {
    var _a;
    (_a = this.staticInstanceRef) == null ? void 0 : _a.error(message2, ...optionalParams);
  }
  static log(message2, ...optionalParams) {
    var _a;
    (_a = this.staticInstanceRef) == null ? void 0 : _a.log(message2, ...optionalParams);
  }
  static warn(message2, ...optionalParams) {
    var _a;
    (_a = this.staticInstanceRef) == null ? void 0 : _a.warn(message2, ...optionalParams);
  }
  static debug(message2, ...optionalParams) {
    var _a, _b;
    (_b = (_a = this.staticInstanceRef) == null ? void 0 : _a.debug) == null ? void 0 : _b.call(_a, message2, ...optionalParams);
  }
  static verbose(message2, ...optionalParams) {
    var _a, _b;
    (_b = (_a = this.staticInstanceRef) == null ? void 0 : _a.verbose) == null ? void 0 : _b.call(_a, message2, ...optionalParams);
  }
  static flush() {
    this.isBufferAttached = false;
    this.logBuffer.forEach((item) => item.methodRef(...item.arguments));
    this.logBuffer = [];
  }
  static attachBuffer() {
    this.isBufferAttached = true;
  }
  static detachBuffer() {
    this.isBufferAttached = false;
  }
  static getTimestamp() {
    const localeStringOptions = {
      year: "numeric",
      hour: "numeric",
      minute: "numeric",
      second: "numeric",
      day: "2-digit",
      month: "2-digit"
    };
    return new Date(Date.now()).toLocaleString(void 0, localeStringOptions);
  }
  static overrideLogger(logger2) {
    var _a;
    if (Array.isArray(logger2)) {
      Logger.logLevels = logger2;
      return (_a = this.staticInstanceRef) == null ? void 0 : _a.setLogLevels(logger2);
    }
    if (isObject(logger2)) {
      if (logger2 instanceof Logger && logger2.constructor !== Logger) {
        const errorMessage = `Using the "extends Logger" instruction is not allowed in Nest v8. Please, use "extends ConsoleLogger" instead.`;
        this.staticInstanceRef.error(errorMessage);
        throw new Error(errorMessage);
      }
      this.staticInstanceRef = logger2;
    } else {
      this.staticInstanceRef = void 0;
    }
  }
  static isLevelEnabled(level) {
    const logLevels = Logger.logLevels;
    return isLogLevelEnabled(level, logLevels);
  }
  registerLocalInstanceRef() {
    var _a;
    if (this.localInstanceRef) {
      return this.localInstanceRef;
    }
    this.localInstanceRef = new ConsoleLogger(this.context, {
      timestamp: (_a = this.options) == null ? void 0 : _a.timestamp,
      logLevels: Logger.logLevels
    });
    return this.localInstanceRef;
  }
};
Logger.logBuffer = new Array();
Logger.staticInstanceRef = DEFAULT_LOGGER;
Logger.WrapBuffer = (target, propertyKey, descriptor) => {
  const originalFn = descriptor.value;
  descriptor.value = function(...args2) {
    if (Logger.isBufferAttached) {
      Logger.logBuffer.push({
        methodRef: originalFn.bind(this),
        arguments: args2
      });
      return;
    }
    return originalFn.call(this, ...args2);
  };
};
__decorateClass([
  Logger.WrapBuffer
], Logger.prototype, "error", 1);
__decorateClass([
  Logger.WrapBuffer
], Logger.prototype, "log", 1);
__decorateClass([
  Logger.WrapBuffer
], Logger.prototype, "warn", 1);
__decorateClass([
  Logger.WrapBuffer
], Logger.prototype, "debug", 1);
__decorateClass([
  Logger.WrapBuffer
], Logger.prototype, "verbose", 1);
__decorateClass([
  Logger.WrapBuffer
], Logger, "error", 1);
__decorateClass([
  Logger.WrapBuffer
], Logger, "log", 1);
__decorateClass([
  Logger.WrapBuffer
], Logger, "warn", 1);
__decorateClass([
  Logger.WrapBuffer
], Logger, "debug", 1);
__decorateClass([
  Logger.WrapBuffer
], Logger, "verbose", 1);
Logger = __decorateClass([
  Injectable(),
  __decorateParam(0, Optional()),
  __decorateParam(1, Optional())
], Logger);

// packages/common/utils/load-package.util.ts
var MISSING_REQUIRED_DEPENDENCY = (name, reason) => `The "${name}" package is missing. Please, make sure to install this library ($ npm install ${name}) to take advantage of ${reason}.`;
var logger = new Logger("PackageLoader");
function loadPackage(packageName, context, loaderFn) {
  try {
    return loaderFn ? loaderFn() : __require(packageName);
  } catch (e) {
    logger.error(MISSING_REQUIRED_DEPENDENCY(packageName, context));
    Logger.flush();
    process.exit(1);
  }
}

// packages/common/cache/default-options.ts
init_esm_shims();
var defaultCacheOptions = {
  ttl: 5,
  max: 100,
  store: "memory"
};

// packages/common/cache/cache.providers.ts
function createCacheManager() {
  return {
    provide: CACHE_MANAGER,
    useFactory: (options) => {
      const cacheManager = loadPackage("cache-manager", "CacheModule", () => require_cache_manager());
      return Array.isArray(options) ? cacheManager.multiCaching(options.map((store) => cacheManager.caching(__spreadValues(__spreadValues({}, defaultCacheOptions), store || {})))) : cacheManager.caching(__spreadValues(__spreadValues({}, defaultCacheOptions), options || {}));
    },
    inject: [CACHE_MODULE_OPTIONS]
  };
}

// packages/common/cache/cache.module.ts
var CacheModule = class {
  static register(options = {}) {
    return {
      module: CacheModule,
      global: options.isGlobal,
      providers: [{ provide: CACHE_MODULE_OPTIONS, useValue: options }]
    };
  }
  static registerAsync(options) {
    return {
      module: CacheModule,
      global: options.isGlobal,
      imports: options.imports,
      providers: [
        ...this.createAsyncProviders(options),
        ...options.extraProviders || []
      ]
    };
  }
  static createAsyncProviders(options) {
    if (options.useExisting || options.useFactory) {
      return [this.createAsyncOptionsProvider(options)];
    }
    return [
      this.createAsyncOptionsProvider(options),
      {
        provide: options.useClass,
        useClass: options.useClass
      }
    ];
  }
  static createAsyncOptionsProvider(options) {
    if (options.useFactory) {
      return {
        provide: CACHE_MODULE_OPTIONS,
        useFactory: options.useFactory,
        inject: options.inject || []
      };
    }
    return {
      provide: CACHE_MODULE_OPTIONS,
      useFactory: async (optionsFactory) => optionsFactory.createCacheOptions(),
      inject: [options.useExisting || options.useClass]
    };
  }
};
CacheModule = __decorateClass([
  Module({
    providers: [createCacheManager()],
    exports: [CACHE_MANAGER]
  })
], CacheModule);

// packages/common/cache/decorators/index.ts
init_esm_shims();

// packages/common/cache/decorators/cache-key.decorator.ts
init_esm_shims();

// packages/common/cache/decorators/cache-ttl.decorator.ts
init_esm_shims();

// packages/common/cache/interceptors/index.ts
init_esm_shims();

// packages/common/cache/interceptors/cache.interceptor.ts
init_esm_shims();
import { of } from "rxjs";
import { tap } from "rxjs/operators";
var HTTP_ADAPTER_HOST = "HttpAdapterHost";
var REFLECTOR = "Reflector";
var CacheInterceptor = class {
  constructor(cacheManager, reflector) {
    this.cacheManager = cacheManager;
    this.reflector = reflector;
    this.allowedMethods = ["GET"];
  }
  async intercept(context, next) {
    var _a;
    const key = this.trackBy(context);
    const ttlValueOrFactory = (_a = this.reflector.get(CACHE_TTL_METADATA, context.getHandler())) != null ? _a : null;
    if (!key) {
      return next.handle();
    }
    try {
      const value = await this.cacheManager.get(key);
      if (!isNil(value)) {
        return of(value);
      }
      const ttl = isFunction(ttlValueOrFactory) ? await ttlValueOrFactory(context) : ttlValueOrFactory;
      return next.handle().pipe(tap((response) => {
        const args2 = isNil(ttl) ? [key, response] : [key, response, { ttl }];
        this.cacheManager.set(...args2);
      }));
    } catch {
      return next.handle();
    }
  }
  trackBy(context) {
    const httpAdapter = this.httpAdapterHost.httpAdapter;
    const isHttpApp = httpAdapter && !!httpAdapter.getRequestMethod;
    const cacheMetadata = this.reflector.get(CACHE_KEY_METADATA, context.getHandler());
    if (!isHttpApp || cacheMetadata) {
      return cacheMetadata;
    }
    const request = context.getArgByIndex(0);
    if (!this.isRequestCacheable(context)) {
      return void 0;
    }
    return httpAdapter.getRequestUrl(request);
  }
  isRequestCacheable(context) {
    const req = context.switchToHttp().getRequest();
    return this.allowedMethods.includes(req.method);
  }
};
__decorateClass([
  Optional(),
  Inject(HTTP_ADAPTER_HOST)
], CacheInterceptor.prototype, "httpAdapterHost", 2);
CacheInterceptor = __decorateClass([
  Injectable(),
  __decorateParam(0, Inject(CACHE_MANAGER)),
  __decorateParam(1, Inject(REFLECTOR))
], CacheInterceptor);

// packages/common/cache/interfaces/index.ts
init_esm_shims();

// packages/common/cache/interfaces/cache-manager.interface.ts
init_esm_shims();

// packages/common/cache/interfaces/cache-module.interface.ts
init_esm_shims();

// packages/common/enums/index.ts
init_esm_shims();

// packages/common/enums/http-status.enum.ts
init_esm_shims();

// packages/common/enums/shutdown-signal.enum.ts
init_esm_shims();

// packages/common/enums/version-type.enum.ts
init_esm_shims();

// packages/common/exceptions/index.ts
init_esm_shims();

// packages/common/exceptions/bad-request.exception.ts
init_esm_shims();

// packages/common/exceptions/http.exception.ts
init_esm_shims();
var HttpException = class extends Error {
  constructor(response, status) {
    super();
    this.response = response;
    this.status = status;
    this.initMessage();
    this.initName();
  }
  initMessage() {
    if (isString(this.response)) {
      this.message = this.response;
    } else if (isObject(this.response) && isString(this.response.message)) {
      this.message = this.response.message;
    } else if (this.constructor) {
      this.message = this.constructor.name.match(/[A-Z][a-z]+|[0-9]+/g).join(" ");
    }
  }
  initName() {
    this.name = this.constructor.name;
  }
  getResponse() {
    return this.response;
  }
  getStatus() {
    return this.status;
  }
  static createBody(objectOrError, description, statusCode) {
    if (!objectOrError) {
      return { statusCode, message: description };
    }
    return isObject(objectOrError) && !Array.isArray(objectOrError) ? objectOrError : { statusCode, message: objectOrError, error: description };
  }
};

// packages/common/exceptions/bad-request.exception.ts
var BadRequestException = class extends HttpException {
  constructor(objectOrError, description = "Bad Request") {
    super(HttpException.createBody(objectOrError, description, 400 /* BAD_REQUEST */), 400 /* BAD_REQUEST */);
  }
};

// packages/common/exceptions/unauthorized.exception.ts
init_esm_shims();
var UnauthorizedException = class extends HttpException {
  constructor(objectOrError, description = "Unauthorized") {
    super(HttpException.createBody(objectOrError, description, 401 /* UNAUTHORIZED */), 401 /* UNAUTHORIZED */);
  }
};

// packages/common/exceptions/method-not-allowed.exception.ts
init_esm_shims();
var MethodNotAllowedException = class extends HttpException {
  constructor(objectOrError, description = "Method Not Allowed") {
    super(HttpException.createBody(objectOrError, description, 405 /* METHOD_NOT_ALLOWED */), 405 /* METHOD_NOT_ALLOWED */);
  }
};

// packages/common/exceptions/not-found.exception.ts
init_esm_shims();
var NotFoundException = class extends HttpException {
  constructor(objectOrError, description = "Not Found") {
    super(HttpException.createBody(objectOrError, description, 404 /* NOT_FOUND */), 404 /* NOT_FOUND */);
  }
};

// packages/common/exceptions/forbidden.exception.ts
init_esm_shims();
var ForbiddenException = class extends HttpException {
  constructor(objectOrError, description = "Forbidden") {
    super(HttpException.createBody(objectOrError, description, 403 /* FORBIDDEN */), 403 /* FORBIDDEN */);
  }
};

// packages/common/exceptions/not-acceptable.exception.ts
init_esm_shims();
var NotAcceptableException = class extends HttpException {
  constructor(objectOrError, description = "Not Acceptable") {
    super(HttpException.createBody(objectOrError, description, 406 /* NOT_ACCEPTABLE */), 406 /* NOT_ACCEPTABLE */);
  }
};

// packages/common/exceptions/request-timeout.exception.ts
init_esm_shims();
var RequestTimeoutException = class extends HttpException {
  constructor(objectOrError, description = "Request Timeout") {
    super(HttpException.createBody(objectOrError, description, 408 /* REQUEST_TIMEOUT */), 408 /* REQUEST_TIMEOUT */);
  }
};

// packages/common/exceptions/conflict.exception.ts
init_esm_shims();
var ConflictException = class extends HttpException {
  constructor(objectOrError, description = "Conflict") {
    super(HttpException.createBody(objectOrError, description, 409 /* CONFLICT */), 409 /* CONFLICT */);
  }
};

// packages/common/exceptions/gone.exception.ts
init_esm_shims();
var GoneException = class extends HttpException {
  constructor(objectOrError, description = "Gone") {
    super(HttpException.createBody(objectOrError, description, 410 /* GONE */), 410 /* GONE */);
  }
};

// packages/common/exceptions/payload-too-large.exception.ts
init_esm_shims();
var PayloadTooLargeException = class extends HttpException {
  constructor(objectOrError, description = "Payload Too Large") {
    super(HttpException.createBody(objectOrError, description, 413 /* PAYLOAD_TOO_LARGE */), 413 /* PAYLOAD_TOO_LARGE */);
  }
};

// packages/common/exceptions/unsupported-media-type.exception.ts
init_esm_shims();
var UnsupportedMediaTypeException = class extends HttpException {
  constructor(objectOrError, description = "Unsupported Media Type") {
    super(HttpException.createBody(objectOrError, description, 415 /* UNSUPPORTED_MEDIA_TYPE */), 415 /* UNSUPPORTED_MEDIA_TYPE */);
  }
};

// packages/common/exceptions/unprocessable-entity.exception.ts
init_esm_shims();
var UnprocessableEntityException = class extends HttpException {
  constructor(objectOrError, description = "Unprocessable Entity") {
    super(HttpException.createBody(objectOrError, description, 422 /* UNPROCESSABLE_ENTITY */), 422 /* UNPROCESSABLE_ENTITY */);
  }
};

// packages/common/exceptions/internal-server-error.exception.ts
init_esm_shims();
var InternalServerErrorException = class extends HttpException {
  constructor(objectOrError, description = "Internal Server Error") {
    super(HttpException.createBody(objectOrError, description, 500 /* INTERNAL_SERVER_ERROR */), 500 /* INTERNAL_SERVER_ERROR */);
  }
};

// packages/common/exceptions/not-implemented.exception.ts
init_esm_shims();
var NotImplementedException = class extends HttpException {
  constructor(objectOrError, description = "Not Implemented") {
    super(HttpException.createBody(objectOrError, description, 501 /* NOT_IMPLEMENTED */), 501 /* NOT_IMPLEMENTED */);
  }
};

// packages/common/exceptions/http-version-not-supported.exception.ts
init_esm_shims();

// packages/common/exceptions/bad-gateway.exception.ts
init_esm_shims();
var BadGatewayException = class extends HttpException {
  constructor(objectOrError, description = "Bad Gateway") {
    super(HttpException.createBody(objectOrError, description, 502 /* BAD_GATEWAY */), 502 /* BAD_GATEWAY */);
  }
};

// packages/common/exceptions/service-unavailable.exception.ts
init_esm_shims();
var ServiceUnavailableException = class extends HttpException {
  constructor(objectOrError, description = "Service Unavailable") {
    super(HttpException.createBody(objectOrError, description, 503 /* SERVICE_UNAVAILABLE */), 503 /* SERVICE_UNAVAILABLE */);
  }
};

// packages/common/exceptions/gateway-timeout.exception.ts
init_esm_shims();
var GatewayTimeoutException = class extends HttpException {
  constructor(objectOrError, description = "Gateway Timeout") {
    super(HttpException.createBody(objectOrError, description, 504 /* GATEWAY_TIMEOUT */), 504 /* GATEWAY_TIMEOUT */);
  }
};

// packages/common/exceptions/im-a-teapot.exception.ts
init_esm_shims();
var ImATeapotException = class extends HttpException {
  constructor(objectOrError, description = `I'm a teapot`) {
    super(HttpException.createBody(objectOrError, description, 418 /* I_AM_A_TEAPOT */), 418 /* I_AM_A_TEAPOT */);
  }
};

// packages/common/exceptions/precondition-failed.exception.ts
init_esm_shims();
var PreconditionFailedException = class extends HttpException {
  constructor(objectOrError, description = "Precondition Failed") {
    super(HttpException.createBody(objectOrError, description, 412 /* PRECONDITION_FAILED */), 412 /* PRECONDITION_FAILED */);
  }
};

// packages/common/exceptions/misdirected.exception.ts
init_esm_shims();

// packages/common/file-stream/index.ts
init_esm_shims();

// packages/common/file-stream/streamable-file.ts
init_esm_shims();
import { Readable } from "stream";
import { types } from "util";
var StreamableFile = class {
  constructor(bufferOrReadStream, options = {}) {
    this.options = options;
    if (types.isUint8Array(bufferOrReadStream)) {
      this.stream = new Readable();
      this.stream.push(bufferOrReadStream);
      this.stream.push(null);
    } else if (bufferOrReadStream.pipe && isFunction(bufferOrReadStream.pipe)) {
      this.stream = bufferOrReadStream;
    }
  }
  getStream() {
    return this.stream;
  }
  getHeaders() {
    const {
      type = "application/octet-stream",
      disposition = void 0,
      length = void 0
    } = this.options;
    return {
      type,
      disposition,
      length
    };
  }
};

// packages/common/http/index.ts
init_esm_shims();

// packages/common/http/http.module.ts
init_esm_shims();
import Axios2 from "axios";

// packages/common/utils/random-string-generator.util.ts
init_esm_shims();
import { v4 as uuid3 } from "uuid";
var randomStringGenerator = () => uuid3();

// packages/common/http/http.constants.ts
init_esm_shims();
var AXIOS_INSTANCE_TOKEN = "AXIOS_INSTANCE_TOKEN";
var HTTP_MODULE_ID = "HTTP_MODULE_ID";
var HTTP_MODULE_OPTIONS = "HTTP_MODULE_OPTIONS";

// packages/common/http/http.service.ts
init_esm_shims();
import Axios from "axios";
import { Observable as Observable2 } from "rxjs";

// packages/common/services/index.ts
init_esm_shims();

// packages/common/http/http.service.ts
var HttpService = class {
  constructor(instance = Axios) {
    this.instance = instance;
    this.logger = new Logger(HttpService.name);
    this.logger.warn('DEPRECATED! "HttpModule" (from the "@nestjs/common" package) is deprecated and will be removed in the next major release. Please, use the "@nestjs/axios" package instead.');
  }
  request(config) {
    return this.makeObservable(this.instance.request, config);
  }
  get(url, config) {
    return this.makeObservable(this.instance.get, url, config);
  }
  delete(url, config) {
    return this.makeObservable(this.instance.delete, url, config);
  }
  head(url, config) {
    return this.makeObservable(this.instance.head, url, config);
  }
  post(url, data, config) {
    return this.makeObservable(this.instance.post, url, data, config);
  }
  put(url, data, config) {
    return this.makeObservable(this.instance.put, url, data, config);
  }
  patch(url, data, config) {
    return this.makeObservable(this.instance.patch, url, data, config);
  }
  get axiosRef() {
    return this.instance;
  }
  makeObservable(axios, ...args2) {
    return new Observable2((subscriber) => {
      const config = __spreadValues({}, args2[args2.length - 1] || {});
      let cancelSource;
      if (!config.cancelToken) {
        cancelSource = Axios.CancelToken.source();
        config.cancelToken = cancelSource.token;
      }
      axios(...args2).then((res) => {
        subscriber.next(res);
        subscriber.complete();
      }).catch((err) => {
        subscriber.error(err);
      });
      return () => {
        if (config.responseType === "stream") {
          return;
        }
        if (cancelSource) {
          cancelSource.cancel();
        }
      };
    });
  }
};
HttpService = __decorateClass([
  __decorateParam(0, Inject(AXIOS_INSTANCE_TOKEN))
], HttpService);

// packages/common/http/http.module.ts
var HttpModule = class {
  static register(config) {
    return {
      module: HttpModule,
      providers: [
        {
          provide: AXIOS_INSTANCE_TOKEN,
          useValue: Axios2.create(config)
        },
        {
          provide: HTTP_MODULE_ID,
          useValue: randomStringGenerator()
        }
      ]
    };
  }
  static registerAsync(options) {
    return {
      module: HttpModule,
      imports: options.imports,
      providers: [
        ...this.createAsyncProviders(options),
        {
          provide: AXIOS_INSTANCE_TOKEN,
          useFactory: (config) => Axios2.create(config),
          inject: [HTTP_MODULE_OPTIONS]
        },
        {
          provide: HTTP_MODULE_ID,
          useValue: randomStringGenerator()
        },
        ...options.extraProviders || []
      ]
    };
  }
  static createAsyncProviders(options) {
    if (options.useExisting || options.useFactory) {
      return [this.createAsyncOptionsProvider(options)];
    }
    return [
      this.createAsyncOptionsProvider(options),
      {
        provide: options.useClass,
        useClass: options.useClass
      }
    ];
  }
  static createAsyncOptionsProvider(options) {
    if (options.useFactory) {
      return {
        provide: HTTP_MODULE_OPTIONS,
        useFactory: options.useFactory,
        inject: options.inject || []
      };
    }
    return {
      provide: HTTP_MODULE_OPTIONS,
      useFactory: async (optionsFactory) => optionsFactory.createHttpOptions(),
      inject: [options.useExisting || options.useClass]
    };
  }
};
HttpModule = __decorateClass([
  Module({
    providers: [
      HttpService,
      {
        provide: AXIOS_INSTANCE_TOKEN,
        useValue: Axios2
      }
    ],
    exports: [HttpService]
  })
], HttpModule);

// packages/common/http/interfaces/index.ts
init_esm_shims();

// packages/common/http/interfaces/http-module.interface.ts
init_esm_shims();

// packages/common/interfaces/index.ts
init_esm_shims();

// packages/common/interfaces/abstract.interface.ts
init_esm_shims();

// packages/common/interfaces/controllers/controller-metadata.interface.ts
init_esm_shims();

// packages/common/interfaces/controllers/controller.interface.ts
init_esm_shims();

// packages/common/interfaces/exceptions/exception-filter.interface.ts
init_esm_shims();

// packages/common/interfaces/exceptions/rpc-exception-filter.interface.ts
init_esm_shims();

// packages/common/interfaces/exceptions/ws-exception-filter.interface.ts
init_esm_shims();

// packages/common/interfaces/external/validation-error.interface.ts
init_esm_shims();

// packages/common/interfaces/features/arguments-host.interface.ts
init_esm_shims();

// packages/common/interfaces/features/can-activate.interface.ts
init_esm_shims();

// packages/common/interfaces/features/custom-route-param-factory.interface.ts
init_esm_shims();

// packages/common/interfaces/features/execution-context.interface.ts
init_esm_shims();

// packages/common/interfaces/features/nest-interceptor.interface.ts
init_esm_shims();

// packages/common/interfaces/features/paramtype.interface.ts
init_esm_shims();

// packages/common/interfaces/features/pipe-transform.interface.ts
init_esm_shims();

// packages/common/interfaces/global-prefix-options.interface.ts
init_esm_shims();

// packages/common/interfaces/hooks/index.ts
init_esm_shims();

// packages/common/interfaces/hooks/before-application-shutdown.interface.ts
init_esm_shims();

// packages/common/interfaces/hooks/on-application-bootstrap.interface.ts
init_esm_shims();

// packages/common/interfaces/hooks/on-application-shutdown.interface.ts
init_esm_shims();

// packages/common/interfaces/hooks/on-destroy.interface.ts
init_esm_shims();

// packages/common/interfaces/hooks/on-init.interface.ts
init_esm_shims();

// packages/common/interfaces/http/index.ts
init_esm_shims();

// packages/common/interfaces/http/http-server.interface.ts
init_esm_shims();

// packages/common/interfaces/http/message-event.interface.ts
init_esm_shims();

// packages/common/interfaces/injectable.interface.ts
init_esm_shims();

// packages/common/interfaces/microservices/nest-hybrid-application-options.interface.ts
init_esm_shims();

// packages/common/interfaces/middleware/index.ts
init_esm_shims();

// packages/common/interfaces/middleware/middleware-config-proxy.interface.ts
init_esm_shims();

// packages/common/interfaces/middleware/middleware-configuration.interface.ts
init_esm_shims();

// packages/common/interfaces/middleware/middleware-consumer.interface.ts
init_esm_shims();

// packages/common/interfaces/middleware/nest-middleware.interface.ts
init_esm_shims();

// packages/common/interfaces/modules/index.ts
init_esm_shims();

// packages/common/interfaces/modules/dynamic-module.interface.ts
init_esm_shims();

// packages/common/interfaces/modules/forward-reference.interface.ts
init_esm_shims();

// packages/common/interfaces/modules/injection-token.interface.ts
init_esm_shims();

// packages/common/interfaces/modules/introspection-result.interface.ts
init_esm_shims();

// packages/common/interfaces/modules/module-metadata.interface.ts
init_esm_shims();

// packages/common/interfaces/modules/nest-module.interface.ts
init_esm_shims();

// packages/common/interfaces/modules/optional-factory-dependency.interface.ts
init_esm_shims();

// packages/common/interfaces/modules/provider.interface.ts
init_esm_shims();

// packages/common/interfaces/nest-application-context.interface.ts
init_esm_shims();

// packages/common/interfaces/nest-application-options.interface.ts
init_esm_shims();

// packages/common/interfaces/nest-application.interface.ts
init_esm_shims();

// packages/common/interfaces/nest-microservice.interface.ts
init_esm_shims();

// packages/common/interfaces/scope-options.interface.ts
init_esm_shims();

// packages/common/interfaces/type.interface.ts
init_esm_shims();

// packages/common/interfaces/version-options.interface.ts
init_esm_shims();
var VERSION_NEUTRAL = Symbol("VERSION_NEUTRAL");

// packages/common/interfaces/websockets/web-socket-adapter.interface.ts
init_esm_shims();

// packages/common/pipes/index.ts
init_esm_shims();

// packages/common/pipes/default-value.pipe.ts
init_esm_shims();
var DefaultValuePipe = class {
  constructor(defaultValue) {
    this.defaultValue = defaultValue;
  }
  transform(value, _metadata) {
    if (isNil(value) || isNumber(value) && isNaN(value)) {
      return this.defaultValue;
    }
    return value;
  }
};
DefaultValuePipe = __decorateClass([
  Injectable()
], DefaultValuePipe);

// packages/common/pipes/parse-array.pipe.ts
init_esm_shims();

// packages/common/utils/http-error-by-code.util.ts
init_esm_shims();
var HttpErrorByCode = {
  [502 /* BAD_GATEWAY */]: BadGatewayException,
  [400 /* BAD_REQUEST */]: BadRequestException,
  [409 /* CONFLICT */]: ConflictException,
  [403 /* FORBIDDEN */]: ForbiddenException,
  [504 /* GATEWAY_TIMEOUT */]: GatewayTimeoutException,
  [410 /* GONE */]: GoneException,
  [418 /* I_AM_A_TEAPOT */]: ImATeapotException,
  [500 /* INTERNAL_SERVER_ERROR */]: InternalServerErrorException,
  [405 /* METHOD_NOT_ALLOWED */]: MethodNotAllowedException,
  [406 /* NOT_ACCEPTABLE */]: NotAcceptableException,
  [404 /* NOT_FOUND */]: NotFoundException,
  [501 /* NOT_IMPLEMENTED */]: NotImplementedException,
  [413 /* PAYLOAD_TOO_LARGE */]: PayloadTooLargeException,
  [412 /* PRECONDITION_FAILED */]: PreconditionFailedException,
  [408 /* REQUEST_TIMEOUT */]: RequestTimeoutException,
  [503 /* SERVICE_UNAVAILABLE */]: ServiceUnavailableException,
  [401 /* UNAUTHORIZED */]: UnauthorizedException,
  [422 /* UNPROCESSABLE_ENTITY */]: UnprocessableEntityException,
  [415 /* UNSUPPORTED_MEDIA_TYPE */]: UnsupportedMediaTypeException
};

// packages/common/pipes/validation.pipe.ts
init_esm_shims();
import { iterate } from "iterare";
var classValidator = {};
var classTransformer = {};
var ValidationPipe = class {
  constructor(options) {
    options = options || {};
    const _a = options, {
      transform: transform2,
      disableErrorMessages,
      errorHttpStatusCode,
      expectedType,
      transformOptions,
      validateCustomDecorators
    } = _a, validatorOptions = __objRest(_a, [
      "transform",
      "disableErrorMessages",
      "errorHttpStatusCode",
      "expectedType",
      "transformOptions",
      "validateCustomDecorators"
    ]);
    this.isTransformEnabled = !!transform2;
    this.validatorOptions = validatorOptions;
    this.transformOptions = transformOptions;
    this.isDetailedOutputDisabled = disableErrorMessages;
    this.validateCustomDecorators = validateCustomDecorators || false;
    this.errorHttpStatusCode = errorHttpStatusCode || 400 /* BAD_REQUEST */;
    this.expectedType = expectedType;
    this.exceptionFactory = options.exceptionFactory || this.createExceptionFactory();
    classValidator = this.loadValidator(options.validatorPackage);
    classTransformer = this.loadTransformer(options.transformerPackage);
  }
  loadValidator(validatorPackage) {
    return validatorPackage != null ? validatorPackage : loadPackage("class-validator", "ValidationPipe", () => __require("class-validator"));
  }
  loadTransformer(transformerPackage) {
    return transformerPackage != null ? transformerPackage : loadPackage("class-transformer", "ValidationPipe", () => __require("class-transformer"));
  }
  async transform(value, metadata) {
    if (this.expectedType) {
      metadata = __spreadProps(__spreadValues({}, metadata), { metatype: this.expectedType });
    }
    const metatype = metadata.metatype;
    if (!metatype || !this.toValidate(metadata)) {
      return this.isTransformEnabled ? this.transformPrimitive(value, metadata) : value;
    }
    const originalValue = value;
    value = this.toEmptyIfNil(value);
    const isNil2 = value !== originalValue;
    const isPrimitive = this.isPrimitive(value);
    this.stripProtoKeys(value);
    let entity = classTransformer.plainToClass(metatype, value, this.transformOptions);
    const originalEntity = entity;
    const isCtorNotEqual = entity.constructor !== metatype;
    if (isCtorNotEqual && !isPrimitive) {
      entity.constructor = metatype;
    } else if (isCtorNotEqual) {
      entity = { constructor: metatype };
    }
    const errors = await this.validate(entity, this.validatorOptions);
    if (errors.length > 0) {
      throw await this.exceptionFactory(errors);
    }
    if (isPrimitive) {
      entity = originalEntity;
    }
    if (this.isTransformEnabled) {
      return entity;
    }
    if (isNil2) {
      return originalValue;
    }
    return Object.keys(this.validatorOptions).length > 0 ? classTransformer.classToPlain(entity, this.transformOptions) : value;
  }
  createExceptionFactory() {
    return (validationErrors = []) => {
      if (this.isDetailedOutputDisabled) {
        return new HttpErrorByCode[this.errorHttpStatusCode]();
      }
      const errors = this.flattenValidationErrors(validationErrors);
      return new HttpErrorByCode[this.errorHttpStatusCode](errors);
    };
  }
  toValidate(metadata) {
    const { metatype, type } = metadata;
    if (type === "custom" && !this.validateCustomDecorators) {
      return false;
    }
    const types2 = [String, Boolean, Number, Array, Object, Buffer];
    return !types2.some((t2) => metatype === t2) && !isNil(metatype);
  }
  transformPrimitive(value, metadata) {
    if (!metadata.data) {
      return value;
    }
    const { type, metatype } = metadata;
    if (type !== "param" && type !== "query") {
      return value;
    }
    if (metatype === Boolean) {
      return value === true || value === "true";
    }
    if (metatype === Number) {
      return +value;
    }
    return value;
  }
  toEmptyIfNil(value) {
    return isNil(value) ? {} : value;
  }
  stripProtoKeys(value) {
    delete value.__proto__;
    const keys = Object.keys(value);
    iterate(keys).filter((key) => isObject(value[key]) && value[key]).forEach((key) => this.stripProtoKeys(value[key]));
  }
  isPrimitive(value) {
    return ["number", "boolean", "string"].includes(typeof value);
  }
  validate(object, validatorOptions) {
    return classValidator.validate(object, validatorOptions);
  }
  flattenValidationErrors(validationErrors) {
    return iterate(validationErrors).map((error) => this.mapChildrenToValidationErrors(error)).flatten().filter((item) => !!item.constraints).map((item) => Object.values(item.constraints)).flatten().toArray();
  }
  mapChildrenToValidationErrors(error, parentPath) {
    if (!(error.children && error.children.length)) {
      return [error];
    }
    const validationErrors = [];
    parentPath = parentPath ? `${parentPath}.${error.property}` : error.property;
    for (const item of error.children) {
      if (item.children && item.children.length) {
        validationErrors.push(...this.mapChildrenToValidationErrors(item, parentPath));
      }
      validationErrors.push(this.prependConstraintsWithParentProp(parentPath, item));
    }
    return validationErrors;
  }
  prependConstraintsWithParentProp(parentPath, error) {
    const constraints = {};
    for (const key in error.constraints) {
      constraints[key] = `${parentPath}.${error.constraints[key]}`;
    }
    return __spreadProps(__spreadValues({}, error), {
      constraints
    });
  }
};
ValidationPipe = __decorateClass([
  Injectable(),
  __decorateParam(0, Optional())
], ValidationPipe);

// packages/common/pipes/parse-array.pipe.ts
var VALIDATION_ERROR_MESSAGE = "Validation failed (parsable array expected)";
var DEFAULT_ARRAY_SEPARATOR = ",";
var ParseArrayPipe = class {
  constructor(options = {}) {
    this.options = options;
    this.validationPipe = new ValidationPipe(__spreadValues({
      transform: true,
      validateCustomDecorators: true
    }, options));
    const { exceptionFactory, errorHttpStatusCode = 400 /* BAD_REQUEST */ } = options;
    this.exceptionFactory = exceptionFactory || ((error) => new HttpErrorByCode[errorHttpStatusCode](error));
  }
  async transform(value, metadata) {
    if (!value && !this.options.optional) {
      throw this.exceptionFactory(VALIDATION_ERROR_MESSAGE);
    } else if (isNil(value) && this.options.optional) {
      return value;
    }
    if (!Array.isArray(value)) {
      if (!isString(value)) {
        throw this.exceptionFactory(VALIDATION_ERROR_MESSAGE);
      } else {
        try {
          value = value.trim().split(this.options.separator || DEFAULT_ARRAY_SEPARATOR);
        } catch {
          throw this.exceptionFactory(VALIDATION_ERROR_MESSAGE);
        }
      }
    }
    if (this.options.items) {
      const validationMetadata = {
        metatype: this.options.items,
        type: "query"
      };
      const isExpectedTypePrimitive = this.isExpectedTypePrimitive();
      const toClassInstance = (item, index2) => {
        try {
          item = JSON.parse(item);
        } catch {
        }
        if (isExpectedTypePrimitive) {
          return this.validatePrimitive(item, index2);
        }
        return this.validationPipe.transform(item, validationMetadata);
      };
      if (this.options.stopAtFirstError === false) {
        let errors = [];
        const targetArray = value;
        for (let i = 0; i < targetArray.length; i++) {
          try {
            targetArray[i] = await toClassInstance(targetArray[i]);
          } catch (err) {
            let message2;
            if (err.getResponse) {
              const response = err.getResponse();
              if (Array.isArray(response.message)) {
                message2 = response.message.map((item) => `[${i}] ${item}`);
              } else {
                message2 = `[${i}] ${response.message}`;
              }
            } else {
              message2 = err;
            }
            errors = errors.concat(message2);
          }
        }
        if (errors.length > 0) {
          throw this.exceptionFactory(errors);
        }
        return targetArray;
      } else {
        value = await Promise.all(value.map(toClassInstance));
      }
    }
    return value;
  }
  isExpectedTypePrimitive() {
    return [Boolean, Number, String].includes(this.options.items);
  }
  validatePrimitive(originalValue, index2) {
    if (this.options.items === Number) {
      const value = originalValue !== null && originalValue !== "" ? +originalValue : NaN;
      if (isNaN(value)) {
        throw this.exceptionFactory(`${isUndefined(index2) ? "" : `[${index2}] `}item must be a number`);
      }
      return value;
    } else if (this.options.items === String) {
      if (!isString(originalValue)) {
        return `${originalValue}`;
      }
    } else if (this.options.items === Boolean) {
      if (typeof originalValue !== "boolean") {
        throw this.exceptionFactory(`${isUndefined(index2) ? "" : `[${index2}] `}item must be a boolean value`);
      }
    }
    return originalValue;
  }
};
ParseArrayPipe = __decorateClass([
  Injectable(),
  __decorateParam(0, Optional())
], ParseArrayPipe);

// packages/common/pipes/parse-bool.pipe.ts
init_esm_shims();
var ParseBoolPipe = class {
  constructor(options) {
    options = options || {};
    const { exceptionFactory, errorHttpStatusCode = 400 /* BAD_REQUEST */ } = options;
    this.exceptionFactory = exceptionFactory || ((error) => new HttpErrorByCode[errorHttpStatusCode](error));
  }
  async transform(value, metadata) {
    if (value === true || value === "true") {
      return true;
    }
    if (value === false || value === "false") {
      return false;
    }
    throw this.exceptionFactory("Validation failed (boolean string is expected)");
  }
};
ParseBoolPipe = __decorateClass([
  Injectable(),
  __decorateParam(0, Optional())
], ParseBoolPipe);

// packages/common/pipes/parse-int.pipe.ts
init_esm_shims();
var ParseIntPipe = class {
  constructor(options) {
    options = options || {};
    const { exceptionFactory, errorHttpStatusCode = 400 /* BAD_REQUEST */ } = options;
    this.exceptionFactory = exceptionFactory || ((error) => new HttpErrorByCode[errorHttpStatusCode](error));
  }
  async transform(value, metadata) {
    const isNumeric = ["string", "number"].includes(typeof value) && /^-?\d+$/.test(value) && isFinite(value);
    if (!isNumeric) {
      throw this.exceptionFactory("Validation failed (numeric string is expected)");
    }
    return parseInt(value, 10);
  }
};
ParseIntPipe = __decorateClass([
  Injectable(),
  __decorateParam(0, Optional())
], ParseIntPipe);

// packages/common/pipes/parse-float.pipe.ts
init_esm_shims();
var ParseFloatPipe = class {
  constructor(options) {
    options = options || {};
    const { exceptionFactory, errorHttpStatusCode = 400 /* BAD_REQUEST */ } = options;
    this.exceptionFactory = exceptionFactory || ((error) => new HttpErrorByCode[errorHttpStatusCode](error));
  }
  async transform(value, metadata) {
    const isNumeric = ["string", "number"].includes(typeof value) && !isNaN(parseFloat(value)) && isFinite(value);
    if (!isNumeric) {
      throw this.exceptionFactory("Validation failed (numeric string is expected)");
    }
    return parseFloat(value);
  }
};
ParseFloatPipe = __decorateClass([
  Injectable(),
  __decorateParam(0, Optional())
], ParseFloatPipe);

// packages/common/pipes/parse-enum.pipe.ts
init_esm_shims();
var ParseEnumPipe = class {
  constructor(enumType, options) {
    this.enumType = enumType;
    if (!enumType) {
      throw new Error(`"ParseEnumPipe" requires "enumType" argument specified (to validate input values).`);
    }
    options = options || {};
    const { exceptionFactory, errorHttpStatusCode = 400 /* BAD_REQUEST */ } = options;
    this.exceptionFactory = exceptionFactory || ((error) => new HttpErrorByCode[errorHttpStatusCode](error));
  }
  async transform(value, metadata) {
    if (!this.isEnum(value)) {
      throw this.exceptionFactory("Validation failed (enum string is expected)");
    }
    return value;
  }
  isEnum(value) {
    const enumValues = Object.keys(this.enumType).map((item) => this.enumType[item]);
    return enumValues.includes(value);
  }
};
ParseEnumPipe = __decorateClass([
  Injectable(),
  __decorateParam(1, Optional())
], ParseEnumPipe);

// packages/common/pipes/parse-uuid.pipe.ts
init_esm_shims();

// packages/common/utils/is-uuid.ts
init_esm_shims();
var uuid4 = {
  3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
  4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
  5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
  all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
};
function isUUID(str, version = "all") {
  if (!isString(str)) {
    throw new BadRequestException("The value passed as UUID is not a string");
  }
  const pattern = uuid4[version];
  return pattern && pattern.test(str);
}

// packages/common/pipes/parse-uuid.pipe.ts
var ParseUUIDPipe = class {
  constructor(options) {
    options = options || {};
    const {
      exceptionFactory,
      errorHttpStatusCode = 400 /* BAD_REQUEST */,
      version
    } = options;
    this.version = version;
    this.exceptionFactory = exceptionFactory || ((error) => new HttpErrorByCode[errorHttpStatusCode](error));
  }
  async transform(value, metadata) {
    if (!isUUID(value, this.version)) {
      throw this.exceptionFactory(`Validation failed (uuid ${this.version ? "v" + this.version : ""} is expected)`);
    }
    return value;
  }
};
ParseUUIDPipe = __decorateClass([
  Injectable(),
  __decorateParam(0, Optional())
], ParseUUIDPipe);

// packages/common/serializer/index.ts
init_esm_shims();

// packages/common/serializer/class-serializer.interceptor.ts
init_esm_shims();
import { map as map2 } from "rxjs/operators";

// packages/common/serializer/class-serializer.constants.ts
init_esm_shims();
var CLASS_SERIALIZER_OPTIONS = "class_serializer:options";

// packages/common/serializer/class-serializer.interceptor.ts
var classTransformer2 = {};
var REFLECTOR2 = "Reflector";
var ClassSerializerInterceptor = class {
  constructor(reflector, defaultOptions = {}) {
    this.reflector = reflector;
    this.defaultOptions = defaultOptions;
    var _a;
    classTransformer2 = (_a = defaultOptions == null ? void 0 : defaultOptions.transformerPackage) != null ? _a : loadPackage("class-transformer", "ClassSerializerInterceptor", () => __require("class-transformer"));
    if (!(defaultOptions == null ? void 0 : defaultOptions.transformerPackage)) {
      __require("class-transformer");
    }
  }
  intercept(context, next) {
    const contextOptions = this.getContextOptions(context);
    const options = __spreadValues(__spreadValues({}, this.defaultOptions), contextOptions);
    return next.handle().pipe(map2((res) => this.serialize(res, options)));
  }
  serialize(response, options) {
    if (!isObject(response) || response instanceof StreamableFile) {
      return response;
    }
    return Array.isArray(response) ? response.map((item) => this.transformToPlain(item, options)) : this.transformToPlain(response, options);
  }
  transformToPlain(plainOrClass, options) {
    return plainOrClass ? classTransformer2.classToPlain(plainOrClass, options) : plainOrClass;
  }
  getContextOptions(context) {
    return this.reflectSerializeMetadata(context.getHandler()) || this.reflectSerializeMetadata(context.getClass());
  }
  reflectSerializeMetadata(obj) {
    return this.reflector.get(CLASS_SERIALIZER_OPTIONS, obj);
  }
};
ClassSerializerInterceptor = __decorateClass([
  Injectable(),
  __decorateParam(0, Inject(REFLECTOR2)),
  __decorateParam(1, Optional())
], ClassSerializerInterceptor);

// packages/common/serializer/decorators/index.ts
init_esm_shims();

// packages/common/serializer/decorators/serialize-options.decorator.ts
init_esm_shims();

// packages/common/utils/index.ts
init_esm_shims();

// packages/common/utils/forward-ref.util.ts
init_esm_shims();

// packages/core/adapters/http-adapter.ts
init_esm_shims();
var AbstractHttpAdapter = class {
  constructor(instance) {
    this.instance = instance;
  }
  async init() {
  }
  use(...args2) {
    return this.instance.use(...args2);
  }
  get(...args2) {
    return this.instance.get(...args2);
  }
  post(...args2) {
    return this.instance.post(...args2);
  }
  head(...args2) {
    return this.instance.head(...args2);
  }
  delete(...args2) {
    return this.instance.delete(...args2);
  }
  put(...args2) {
    return this.instance.put(...args2);
  }
  patch(...args2) {
    return this.instance.patch(...args2);
  }
  all(...args2) {
    return this.instance.all(...args2);
  }
  options(...args2) {
    return this.instance.options(...args2);
  }
  listen(port, hostname, callback) {
    return this.instance.listen(port, hostname, callback);
  }
  getHttpServer() {
    return this.httpServer;
  }
  setHttpServer(httpServer) {
    this.httpServer = httpServer;
  }
  setInstance(instance) {
    this.instance = instance;
  }
  getInstance() {
    return this.instance;
  }
};

// packages/platform-fastify/adapters/fastify-adapter.ts
var import_fastify = __toESM(require_fastify());
var import_reply = __toESM(require_reply());
var FastifyAdapter = class extends AbstractHttpAdapter {
  constructor(instanceOrOptions) {
    super();
    this.versionConstraint = {
      name: "version",
      validate(value) {
        if (!isString(value) && !Array.isArray(value)) {
          throw new Error("Version constraint should be a string or an array of strings.");
        }
      },
      storage() {
        const versions = /* @__PURE__ */ new Map();
        return {
          get(version) {
            if (Array.isArray(version)) {
              return versions.get(version.find((v) => versions.has(v))) || null;
            }
            return versions.get(version) || null;
          },
          set(versionOrVersions, store) {
            const storeVersionConstraint = (version) => versions.set(version, store);
            if (Array.isArray(versionOrVersions))
              versionOrVersions.forEach(storeVersionConstraint);
            else
              storeVersionConstraint(versionOrVersions);
          },
          del(version) {
            if (Array.isArray(version)) {
              version.forEach((v) => versions.delete(v));
            } else {
              versions.delete(version);
            }
          },
          empty() {
            versions.clear();
          }
        };
      },
      deriveConstraint: (req) => {
        var _a, _b, _c, _d;
        if (this.versioningOptions.type === 2 /* MEDIA_TYPE */) {
          const MEDIA_TYPE_HEADER = "Accept";
          const acceptHeaderValue = ((_a = req.headers) == null ? void 0 : _a[MEDIA_TYPE_HEADER]) || ((_b = req.headers) == null ? void 0 : _b[MEDIA_TYPE_HEADER.toLowerCase()]);
          const acceptHeaderVersionParameter = acceptHeaderValue ? acceptHeaderValue.split(";")[1] : "";
          if (acceptHeaderVersionParameter) {
            const headerVersion = acceptHeaderVersionParameter.split(this.versioningOptions.key)[1];
            return headerVersion;
          }
        } else if (this.versioningOptions.type === 1 /* HEADER */) {
          const customHeaderVersionParameter = ((_c = req.headers) == null ? void 0 : _c[this.versioningOptions.header]) || ((_d = req.headers) == null ? void 0 : _d[this.versioningOptions.header.toLowerCase()]);
          if (customHeaderVersionParameter) {
            return customHeaderVersionParameter;
          }
        } else if (this.versioningOptions.type === 3 /* CUSTOM */) {
          return this.versioningOptions.extractor(req);
        }
        return void 0;
      },
      mustMatchWhenDerived: false
    };
    const instance = instanceOrOptions && instanceOrOptions.server ? instanceOrOptions : (0, import_fastify.fastify)(__spreadValues({
      constraints: {
        version: this.versionConstraint
      }
    }, instanceOrOptions));
    this.setInstance(instance);
  }
  get isParserRegistered() {
    return !!this._isParserRegistered;
  }
  async init() {
    if (this.isMiddieRegistered) {
      return;
    }
    await this.registerMiddie();
  }
  listen(port, ...args2) {
    return this.instance.listen(port, ...args2);
  }
  get(...args2) {
    return this.injectConstraintsIfVersioned("get", ...args2);
  }
  post(...args2) {
    return this.injectConstraintsIfVersioned("post", ...args2);
  }
  head(...args2) {
    return this.injectConstraintsIfVersioned("head", ...args2);
  }
  delete(...args2) {
    return this.injectConstraintsIfVersioned("delete", ...args2);
  }
  put(...args2) {
    return this.injectConstraintsIfVersioned("put", ...args2);
  }
  patch(...args2) {
    return this.injectConstraintsIfVersioned("patch", ...args2);
  }
  options(...args2) {
    return this.injectConstraintsIfVersioned("options", ...args2);
  }
  applyVersionFilter(handler, version, versioningOptions) {
    if (!this.versioningOptions) {
      this.versioningOptions = versioningOptions;
    }
    const versionedRoute = handler;
    versionedRoute.version = version;
    return versionedRoute;
  }
  reply(response, body, statusCode) {
    const fastifyReply = this.isNativeResponse(response) ? new import_reply.default(response, {
      context: {
        preSerialization: null,
        preValidation: [],
        preHandler: [],
        onSend: [],
        onError: []
      }
    }, {}) : response;
    if (statusCode) {
      fastifyReply.status(statusCode);
    }
    if (body instanceof StreamableFile) {
      const streamHeaders = body.getHeaders();
      if (fastifyReply.getHeader("Content-Type") === void 0 && streamHeaders.type !== void 0) {
        fastifyReply.header("Content-Type", streamHeaders.type);
      }
      if (fastifyReply.getHeader("Content-Disposition") === void 0 && streamHeaders.disposition !== void 0) {
        fastifyReply.header("Content-Disposition", streamHeaders.disposition);
      }
      if (fastifyReply.getHeader("Content-Length") === void 0 && streamHeaders.length !== void 0) {
        fastifyReply.header("Content-Length", streamHeaders.length);
      }
      body = body.getStream();
    }
    return fastifyReply.send(body);
  }
  status(response, statusCode) {
    if (this.isNativeResponse(response)) {
      response.statusCode = statusCode;
      return response;
    }
    return response.code(statusCode);
  }
  render(response, view, options) {
    return response && response.view(view, options);
  }
  redirect(response, statusCode, url) {
    const code = statusCode != null ? statusCode : 302 /* FOUND */;
    return response.status(code).redirect(url);
  }
  setErrorHandler(handler) {
    return this.instance.setErrorHandler(handler);
  }
  setNotFoundHandler(handler) {
    return this.instance.setNotFoundHandler(handler);
  }
  getHttpServer() {
    return this.instance.server;
  }
  getInstance() {
    return this.instance;
  }
  register(plugin, opts) {
    return this.instance.register(plugin, opts);
  }
  inject(opts) {
    return this.instance.inject(opts);
  }
  async close() {
    try {
      return await this.instance.close();
    } catch (err) {
      if (err.code !== "ERR_SERVER_NOT_RUNNING") {
        throw err;
      }
      return;
    }
  }
  initHttpServer() {
    this.httpServer = this.instance.server;
  }
  useStaticAssets(options) {
    return this.register(loadPackage("fastify-static", "FastifyAdapter.useStaticAssets()", () => require_fastify_static()), options);
  }
  setViewEngine(options) {
    if (isString(options)) {
      new Logger("FastifyAdapter").error("setViewEngine() doesn't support a string argument.");
      process.exit(1);
    }
    return this.register(loadPackage("point-of-view", "FastifyAdapter.setViewEngine()", () => require_point_of_view()), options);
  }
  setHeader(response, name, value) {
    return response.header(name, value);
  }
  getRequestHostname(request) {
    return request.hostname;
  }
  getRequestMethod(request) {
    return request.raw ? request.raw.method : request.method;
  }
  getRequestUrl(request) {
    return this.getRequestOriginalUrl(request.raw || request);
  }
  enableCors(options) {
    this.register(Promise.resolve().then(() => __toESM(require_fastify_cors())), options);
  }
  registerParserMiddleware() {
    if (this._isParserRegistered) {
      return;
    }
    this.register(Promise.resolve().then(() => __toESM(require_formbody())));
    this._isParserRegistered = true;
  }
  async createMiddlewareFactory(requestMethod) {
    if (!this.isMiddieRegistered) {
      await this.registerMiddie();
    }
    return (path2, callback) => {
      let normalizedPath = path2.endsWith("/*") ? `${path2.slice(0, -1)}(.*)` : path2;
      normalizedPath = normalizedPath === "/(.*)" ? "(.*)" : normalizedPath;
      this.instance.use(normalizedPath, callback);
    };
  }
  getType() {
    return "fastify";
  }
  registerWithPrefix(factory, prefix = "/") {
    return this.instance.register(factory, { prefix });
  }
  isNativeResponse(response) {
    return !("status" in response);
  }
  async registerMiddie() {
    this.isMiddieRegistered = true;
    await this.register(Promise.resolve().then(() => __toESM(require_middie())));
  }
  getRequestOriginalUrl(rawRequest) {
    return rawRequest.originalUrl || rawRequest.url;
  }
  injectConstraintsIfVersioned(routerMethodKey, ...args2) {
    const handlerRef = args2[args2.length - 1];
    const isVersioned = !isUndefined(handlerRef.version) && handlerRef.version !== VERSION_NEUTRAL;
    if (isVersioned) {
      const isPathAndRouteTuple = args2.length === 2;
      if (isPathAndRouteTuple) {
        const options = {
          constraints: {
            version: handlerRef.version
          }
        };
        const path2 = args2[0];
        return this.instance[routerMethodKey](path2, options, handlerRef);
      }
    }
    return this.instance[routerMethodKey](...args2);
  }
};

// packages/platform-fastify/interfaces/index.ts
init_esm_shims();

// packages/platform-fastify/interfaces/nest-fastify-application.interface.ts
init_esm_shims();
export {
  FastifyAdapter
};
/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * depd
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * depd
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * depd
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * depd
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * destroy
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
/*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * proxy-addr
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
//# sourceMappingURL=index.mjs.map